{"posts":[{"title":"[笔记] 二维偏序专题","content":"二维偏序问题是一个常见的模型，有很多方法可以解决，这篇文章总结了一些常见的解法。 定义 暴力解法 数据结构维护 树状数组/线段树 Policy-Based Data Structure 利用归并排序 注：本文中的代码是在特定算法竞赛模板下实现的，可以认为是 C++ 风格的伪代码。 定义 给定一个有 nnn 个元素的集合，其中每个元素有两个属性 (xk,yk)(x_k,y_k)(xk​,yk​)，求集合中 xi&lt;xjx_i&lt;x_jxi​&lt;xj​ 且 yi&lt;yjy_i&lt;y_jyi​&lt;yj​ 的 (i,j)(i,j)(i,j) 对数。 很多问题都可以化归成二维偏序问题的模型，例如顺序对问题： 给定一个长度为 nnn 的序列 aaa，求满足 i&lt;ji&lt;ji&lt;j 且 ai&lt;aja_i&lt;a_jai​&lt;aj​ 的 (i,j)(i,j)(i,j) 对数。 以及经典的逆序对问题： 给定一个长度为 nnn 的序列 aaa，求满足 i&lt;ji&lt;ji&lt;j 且 ai&gt;aja_i&gt;a_jai​&gt;aj​ 的 (i,j)(i,j)(i,j) 对数。 将序列 aaa 中的所有元素取为相反数，实际上就可以将逆序对问题化归成顺序对问题。 暴力解法 很明显，直接通过二重循环进行统计，很容易得到一个 O(n2)O(n^2)O(n2) 的解法： ll bruteforce(ll n,vpll&amp;a){ ll ans=0; f(i,0,n)f(j,0,i) if(a[i].fi&lt;a[j].fi&amp;&amp;a[i].sc&lt;a[j].sc)ans++; return ans; } 如果相等也被包含在偏序关系中，只需要将 if 中的小于号改为小于等于号即可。 但是算法竞赛中 O(n2)O(n^2)O(n2) 的解法往往是不可接受的，我们来看看别的方法。 数据结构维护 这类方法往往先使用 O(nlog⁡n)O(n\\log n)O(nlogn) 的时间对第一维 xkx_kxk​ 排序，然后再用数据结构维护第二维 yky_kyk​，在遍历每个元素的第二维 yjy_jyj​ 时用 O(log⁡n)O(\\log n)O(logn) 的时间统计目前数据结构中有多少个元素满足 yi&lt;yjy_i&lt;y_jyi​&lt;yj​，因此实现在 O(nlog⁡n)O(n\\log n)O(nlogn) 的时间内完成统计。 由于需要先对第一维排序，因此这类方法无论使用在线或离线的数据结构都是离线算法。 树状数组/线段树 维护一个权值为下标的树状数组（也就是维护第二维 yky_kyk​ 的计数桶），每次统计在本质上就是进行一次 [min⁡{y},yk][\\min\\{y\\},y_k][min{y},yk​] 的区间查询，耗费 O(log⁡max⁡{y})O(\\log \\max\\{y\\})O(logmax{y}) 的时间，在统计后将 yky_kyk​ 更新到桶中，本质上就是进行一次 yky_kyk​ 的单点更新，同样耗费 O(log⁡max⁡{y})O(\\log \\max\\{y\\})O(logmax{y}) 的时间。 ll sort_with_tree(ll n,vpll&amp;a){ sort(all(a)); ll ma=-inf; fe(u,a)tmax(ma,u.sc); fwi tr(ma); ll ans=0; fe(u,a){ ans+=tr.query(u.sc-1); tr.update(u.sc,1); } return ans; } 其硬伤在于只能维护 yky_kyk​ 为正整数的情况。如果 yky_kyk​ 为非正整数，需要根据值域偏移到正整数区间；如果 yky_kyk​ 的值域过大，则需要先对第二维进行离散化后进行处理，或者在线段树中使用动态开点线段树。 如果相等也被包含在偏序关系中，只需要将 query 中的 u.sc-1 改为 u.sc 即可。 Policy-Based Data Structure 直接使用 PBDS 中支持排名查询的红黑树即可直接在 O(log⁡n)O(\\log n)O(logn) 时间内进行统计。 ll sort_with_pbds(ll n,vpll&amp;a){ sort(all(a)); rbt&lt;ll,nulltype,greater&lt;ll&gt;&gt;tr; ll ans=0; fe(u,a){ ans+=tr.order_of_key(u.sc); tr.ist(u.sc); } return ans; } 实战首选该方法，优点是码量小，无视值域，思路简单粗暴。缺点是常数较大，并且由于其高度封装，难以添加额外功能（假如要额外维护别的东西，比较难修改代码）。 除此之外，如果有第二维有重复元素，可以修改第三个属性为 less_equal 以支持多重集，但是会导致 find 和 erase 方法不可用。更稳妥的方案是将元素改为 pair&lt;int,int&gt;，第一元维护元素值，第二元维护编号，以保证元素不重复，进而能够进行正确的查询。 ll sort_with_pbds(ll n,vpll&amp;a){ sort(all(a)); rbt&lt;pll,nulltype,greater&lt;pll&gt;&gt;tr; ll ans=0,cnt=0; fe(u,a){ ans+=tr.order_of_key({u.sc,inf}); tr.ist({u.sc,cnt}); cnt++; } return ans; } 如果相等也被包含在偏序关系中，只需要将 order_of_key 中的 inf 改为 -inf 即可。 利用归并排序 首先使用 O(nlog⁡n)O(n\\log n)O(nlogn) 的时间对第一维 xkx_kxk​ 排序，然后再对第二维进行归并排序，由于在归并的过程中第一维原本就有序，因此可以借此统计二维偏序。 在归并的某一步时，有两个重要性质： 左半部分和右半部分的第二维均有序。 对于第一维而言，左半部分的元素总是小于右半部分的元素。 此时可以统计从左半部分和右半部分各选取一个元素后符合的个数。对于右半部分的每个元素，需要找出左半部分中第二维小于它的元素个数。 很显然可以一边合并一边统计：当合并后的数组接下来要加入一个左半部分的元素时，计数器 cnt 自增；要加入一个右半部分的元素时，左半部分的元素中第二维小于它的元素个数正好就是计数器的个数，因此在答案中添加 cnt 即可。 不难发现只要在归并排序的每一步合并都进行统计，最终其和即为二维偏序的对数。 ll solve_merge(ll l,ll r,vpll&amp;a,vpll&amp;t){ if(l&gt;=r)return 0; ll m=l+(r-l)/2,i=l,j=m+1,k=l; ll cnt=0,ans=solve_merge(l,m,a,t)+solve_merge(m+1,r,a,t); while(i&lt;=m||j&lt;=r){ if(i&lt;=m&amp;&amp;(j&gt;r||a[i].sc&lt;a[j].sc)){ t[k++]=a[i++]; cnt++; }else{ t[k++]=a[j++]; ans+=cnt; } } f(p,l,r+1)a[p]=t[p]; return ans; } ll merge_sort(ll n,vpll&amp;a){ sort(all(a)); vpll t(n); return solve_merge(0,n-1,a,t); } 如果相等也被包含在偏序关系中，只需要将 while 的 if 中的 &lt; 改为 &lt;= 即可。 ","link":"https://zihim.me/post/KgQh-f60pI/"},{"title":"[随笔] 2025 ICPC 香港站游记","content":"前几天第一次参加了 ICPC 区域赛，在此写一篇比赛和旅游游记。 虽然打铁了，但这次经历还是比较深刻的，也算是学习和提升认知了。 Day -x (x&gt;2) 当时教练问我们是否报名香港站区域赛，并且学校不给报销。虽然手头拮据，但机会难得，和队友考虑再三后最终决定去参与一下，预计人均最终消费 1000+ RMB。 一开始付款就犯了难，报名费 1800 HKD，PayPal 一直支付不成功（不想被 PayPal 收 70 RMB 的手续费），后面注册了一个 PayPal 账号，添加卡后终于支付成功。 考虑到正赛在早上九点，最终决定周五在深圳住一天（住在靠近罗湖关口的酒店，一晚约 300 RMB），在香港住两天（旺角某大厦的公寓，两晚约 1400 RMB）。 Day -2 &amp; -1 虽然没什么课，但是要考数据结构。两天一共花了五六个小时，大概熟悉了一下考点和本学期学了的内容，剩下时间都在加练备赛。 第二天下午的数据结构考试，原本想着半小时手起刀落秒了，结果出现一系列问题： 出题人把快排填空题出错了，折腾了几十分钟还以为我学了个假的快排。 读代码题中有一个队列题，函数名 enQueue(Q, x) 和 deQueue(Q, x) 不知道是啥玩意（也没写函数实现，貌似出题人默认我们会了），思考十分钟后灵光乍现是入队和出队，有惊无险地解决了本题。 （话说代码题考 C 但是又拓展了引用特性未免有些奇怪...） 最后做完还剩一个小时，想着还是检查一遍吧，最终非常幸运地检查出了三个错误。但是考后复盘发现堆操作题忘记把最后一个重复元素入堆了... 晚上在收拾行李，顺便采购了一些赛场上要吃的食物，结果买得有点太多了，提了一大袋子回宿舍... 晚上准备去取快递（英标转接头），没想到事出反常，快递站竟然关门了...只好祈祷明天早上会开门。 Day 0 早上九点的高铁，遗憾的是快递站并没有开门。 到了深圳先在酒店安顿行李，发现房间比较小，而且床是正四边形的，三个人只能乱睡，不过反正只住一天，随便凑合了一下。 打算在这座从未涉足的城市随便逛逛，先前在高铁上随便做了些攻略，放下行李后便沿贯穿东西的深南大道游玩。 从一号线坐到老街站，打卡了中国内地第一家麦当劳，这家麦当劳足足有三层，顶层还有一个小花园。但可能是白天的缘故，并不多人，老街的地下商场以服装售卖居多，也并无特别吸引人之处。 下一站原想参观全球最大的电子元器件集散地——华强北，但考虑到同行队友对电子产品并不特别感兴趣，以及社交媒体上“华强北主打批发，对散客不友好”的资讯，便决定直接去深圳博物馆。 想起之前一位朋友所述，“来到一座新城市，就应该去一下这座城市的博物馆。”博物馆内有足足三层，考虑到时间有限，我们只游览了顶层改革开放相关展厅。博物馆走走停停看看，不一会便腰酸背痛，下午两点左右到附近的市民中心随便应付了午饭。 下一站是梅拉尼亚小镇，这实际上是个商业气息略重，人气却并不高的景点。队友 yxuan 太困，在椅子上睡了一个半小时。小镇的旁边就是著名的世界之窗，可惜门票性价比并不高，故只在外面潦草地拍了几张照。 黄昏降临，打算去深圳湾公园，想感受一下当地居民在晚风中散步的惬意，可惜地铁周转麻烦，于是选择了叫网约车。周五的晚高峰往往是最拥堵的，到达公园后晚霞已经消散得差不多了，只剩下巨大的夜幕和远处地平线的落日余晖。 太久没有旅游，傍晚时已力竭，正巧妈妈在宝安机场转机，匆匆赶至机场短暂小聚后直接坐地铁回酒店了。 一天的深圳游，说长不长，说短不短，遗憾的是没有到南山区看看南山科技园和众多高等学府，也因疲惫没能在被誉为深圳之眼的岗厦北地铁站驻足。感觉深圳的人文底蕴并不特别突出，路边总缺少一种“烟火气”，又或许是我太过匆匆，没能静下心来品一碗人间烟火吧。 Day 1 早上起床洗了个澡，收拾行李入关。香港的公寓不提供免费的一次性用品，故临走时在酒店薅了几套牙具。 过关非常顺利，可以在走廊的玻璃上看到出深圳河的过程，出境后直接可以用微信小程序直接乘坐港铁东铁线。 香港有一个和内地不同的“左行右立”的习惯，扶梯左侧是留空供时间紧急的行人迅速通过的，而右侧才允许站立。 坐在座位上看着东铁线穿过山丘和平房缓缓驶入市区，下地面换乘观塘线坐到旺角，在经过数不清的扶梯和阶梯后来到地面，脑海中关于香港的想象都具象化在了眼前。面前极具香港特色的霓虹般的景象让我想起了小时候看过的一本书，叫《时代广场的蟋蟀》，里面的蟋蟀在跳出纽约地铁来到地面时，大概和我的感受差不多吧。 穿梭熙熙攘攘的人群，进入公寓所在的大厦，直梯是狭小的，走廊是狭小的，前台是狭小的，房间也是狭小的。行李箱在地上打不开，卫生间只够转身。但在香港这个寸土寸金的地方，能以这个价格在繁华的旺角住两天也未尝不可。 安顿好行李后乘坐地铁和小巴到达港科大北门，小巴仅支持八达通和港币现金，司机们虽然驾驶的是体型略显笨重的小巴，但我想他们都有一个飙车梦，中间连续飞了几个站（无人下车和上车，司机直接不停靠站点）后，我们很快到达了目的地。 下车后往前走几步就见到坐落在 Entrance Piazza 的标志性红鸟，略微合照后来到旁边的星巴克签到领取物资。每人一件粉色赛事卫衣（我在包装上看到天猫，想必是内地购买寄到香港的）、一张选手证、三张 50 HKD 的餐券和带有港科大标识的手机支架。或许是第一次参加不太清楚（其它赛站是否也与此相同），又或者是主办方和赞助商非常热情大方，而我惊讶的是，在这里，星巴克是随便免费喝的，现场有三个赞助商——HUAWEI、Jane Street 和 HRT，用英语略微沟通后得知它们的物料也是随便拿的（她说 Just grab anything you like），并且也物料非常丰富： HUAWEI：奶龙玩具、帆布袋和随便喝的现磨太平洋咖啡。 Jane Street：桌子上的随便拿，有两种文化衫、魔方、花切扑克和一些益智小玩具。 HRT：两种文化衫，一件运动裤，一个水杯。 拍完队伍合照后在科大校园闲逛，校园坐山紧邻牛尾海，可以欣赏到不错的海景。地上建筑有多层，地下还有多层，层与层之间往往以扶梯相接。午饭品尝了最经典的港式烧味饭，搭配港式冻奶茶，吃的令人飘飘欲仙。后来手机没电了，故回到签到处，在椅子上稍作小憩后便去到何善衡体育馆开始今天的热身赛。 找到座位后直接震惊了，前面坐的就是北大 Naive Birds（呆呆鸟）队伍。比赛用机屏幕非常小，配置也很低，但对于 Ubuntu GNOME 而言绰绰有余。 看到赛事手册上为系统提供了两个命令： submit A.cpp // 提交 A 题 printfile A.cpp // 打印 A.cpp 的代码 这个功能简直炫酷又方便！运行 printfile 后一分钟之内工作人员就会拿着打印好的代码送到你的桌前。 由于赛题仍需要保密，关于赛时的经历将在未来更新。 比赛结束后去校内另一家餐厅吃了一份萝卜排骨和鸡翅饭，感觉并无中午的烧味饭好吃。 鉴于热身赛的表现，~~而且我选修课结课作业还没交，~~我们决定先不旅游，而是乘小巴和港铁回公寓加练。 Day 2 今天睡了一个好觉，早早起床洗漱后坐港铁到钻石山寻找赛事接驳大巴上车点，成为第一个上车的队伍。 在车上和星巴克复习了一些算法和 pbds（虽然大多数基本没用上）后，进入体育馆准备开始今天的正赛。 由于赛题仍需要保密，关于赛时的经历将在未来更新。 比赛结束后大家都有些许闷闷不乐，也许是最后没能调出 K 题冲铜吧。 后面才发现 H 题（粉色气球，是本场赛事主题色）和 K 是最简单的，莫非对应 Hong Kong，是个小彩蛋？ 在体育馆外领取了一些用作午饭的星巴克面包，去到 LT-J 报告厅等待题解和滚榜，由于是两小时后开始，便在此期间做了一些香港游玩攻略。事实证明队伍水平还不够，只能说菜就多练。但毕竟已经结束了，就好好地旅游吧。 题解和滚榜全程英文进行，讲题解的小哥有些中文口音和阅读习惯，如“J”读成“勾”，以及“I don’t know how to speak it in English, but in Chinese we call it 线性基.”，最搞笑的是 O(nlog⁡2n)O(n\\log^2n)O(nlog2n) 嘴一瓢读成了“n log 方 n”。 后来有一个 HUAWEI Theory Lab 的大牛发表宣讲，他一开始给了一张扑克牌 K 的照片，上面有一道题，是他在瑞典出题时的一些废案，难度从 A 到 K 逐渐增加。他说如果有人能在他宣讲完后能做出这道题的人，奬一个华为手表。 他的宣讲题目大概关于 Practice and Theory，在中间举了一个例子去解释理论和实践的区别：现在的矩阵乘法可以将复杂度降到 O(n2.37)O(n^{2.37})O(n2.37) 左右，但是现在为什么主流还是在使用 O(n3)O(n^3)O(n3) 的朴素算法呢？原因是因为它非常适合并行运算。 后面的滚榜和合照也是非常有氛围，可惜没能获奖。 最后主办方说有多余的赛服、键盘和鼠标在外面，可以自行领取。结果一看，这键鼠不是我们比赛时用的吗？？实在有些搞笑，主办方说这些东西在香港的购买成本远低于储存成本。最终也是随便拿了件衣服就走了。 在餐厅吃了最后一顿饭，这顿饭十分难吃，淡而无味如白人饭，但为了不浪费粮食，最终也是吃完了。 坐小巴和地铁回公寓，放下东西轻装上阵到中环随便逛逛，中环站和香港站正好有一个李小龙 85 周年的地铁展，于是去参观了一下，领取了一张纪念卡。 从中环 J 出口出来是素雅的终审法院，橘黄的灯光下，来来往往的叮叮车给中环更添了几分港味。一路沿着人行道走到中环街市，街市里很多店门都紧闭着，可能是星期天或者太晚的原因，并不非常热闹。 中环有太多路口，每隔两三步就是一个红绿灯，天桥是缩短行程的一大工具。中环的天桥很长很广，就像给行人专供的路网，可能从这栋建筑里穿进去，又从另一栋建筑里穿出来，可以通过天桥来到几乎所有的被马路分隔开的建筑区块。 经过天桥的兜兜转转，路口的来来往往，在导航的随机偏移下终于到达了中环的摩天轮地标。摩天轮很便宜，每人 20 HKD 就可以转三圈。此时人并不多，我们很快就上去体验了，虽然最高点并不太高，但是足以远眺到维多利亚港和对面的尖沙咀。 天星小轮的码头就在摩天轮旁边，它并不是观光游轮，而是一个搭载和运输的工具。价格非常亲民，5 HKD 就可以从中环到尖沙咀，虽然时间并不长，但足以让我们在维港上欣赏这座城市最美丽的夜景。 下船后我们直奔旁边的麦当劳，其实这也是此行的一个任务——体验香港的麦当劳。在花费 30 分钟折腾 App 后决定在点餐机上点餐。早在社交媒体上听说内地的麦当劳和香港的不一样，事实也的确如此，香港的小薯相当于内地的中薯，而且吃法是将粉包和薯条一起倒进一个纸袋里 shake，与内地蘸番茄酱的吃法也略有差异。 我选择了套餐里一个内地没有见过的汉堡，以及内地早已下架的奶昔。美味是必然的，只是突然想起陈奕迅那首《麦当劳之歌》： 麦当劳汉堡 好好好~ 麦当劳薯条 条条条~ 麦当劳奶昔 奶奶奶奶奶奶奶~ 顺便感谢队友 yxuan 请我吃麦当劳作为生日礼物，实在是破费了！ 其实吃完麦当劳已经快十二点了，于是我们便直接搭乘港铁回公寓休息了。 Day 3 睡到自然醒，今天打算在油尖旺区随便逛逛。 在公寓琢磨了一个小时在思考去哪个冰室才好吃且态度好，但听说茶餐厅本来就是用来快速填饱肚子走人的，不应对服务态度有过高的奢求，所以最终选择了尖沙咀的红茶冰室。 但出乎意料的是，服务员大叔友善且耐心地给我们解释，并不像社交媒体上说的“不耐烦”，在听见同行的队友使用普通话聊天后，他便切换到一口发音并不特别标准的普通话和我们沟通。我点了一个菠萝油和牛奶红豆冰，队友点了车仔面，都是非常经典的港式茶餐厅菜肴，总体而言体验是出乎意料的好。 队友提议到九龙公园散会步，刚进公园不久就看到香港文物探知馆，里面有一个名为“唐风万里”的展览吸引了我们，于是决定一探究竟，事实证明我们来对地方了。 这个展在公园内，人气并不高，里面工作人员的人数甚至比游客还多。它相比众多内地的博物馆简直高级太多。里面有很多的互动设施，如覆盖在馆内各个角落的套色章、和展览相关的电子游戏、一个可以全视角观看的木质建筑（为了避免破坏，建筑被放在一个圆形转盘上，转盘的一部分露出展柜供游客旋转欣赏，甚至提供了三个观赏窗以观察内部构造），馆内甚至有一个中型的中式建筑风格的乐高积木展柜，而这一切都是免费的！ 我写了个意见表，建议它们多做宣传，还收到了馆方的两件小礼品。原本在研究这个意见表怎么写和提交，旁边的工作人员大叔主动上来帮助我，后面临走时顺便还和闲谈了一会，这是我第一次这么长时间体验真实的香港对话情景。大叔非常友好，说话也风趣幽默，他跟我们介绍这个展其实办起来费了好大功夫，从内地的多个博物馆分别借了几十件组合出来的，还问我们从哪来，并分享他去那些地方的旅游经历。 从九龙公园出来可以直接通过天桥走到中港城，在一个叫做 China Ferry Terminal Observation Deck（当时并不知道那个地方叫什么，但是 Google Maps 上是这么写的）的地方拍了拍维港对面的上环景色。 此时剩余的时间不太充裕，快要接近开始返程的时间了，但我们最终还是决定速览一下星光大道。经过疾行，我们最终在一点半赶到星光大道，并像许多游客一样，将自己的手掌与著名明星相对比。可惜天气不太好，抑或是白天的原因，拍出的维多利亚港和中环建筑是灰蒙蒙的一片。 两点便回公寓取走寄存的行李，坐港铁回罗湖过关后坐高铁回校，这次的香港之旅就结束了。 读万卷书，行万里路。虽然比赛打铁了，但是能去现场感受 ICPC 的氛围，能去香港走一圈，本就是我大学生涯里难忘的经历，是我人生中精彩的一页。 ","link":"https://zihim.me/post/BVwBk01-3g/"},{"title":"[趣题] 弥哈尤部落的军队","content":"在遥远的提瓦特大陆，弥哈尤部落正准备发动一场决定生死存亡的远征。为了赢得这场战争，大先知决定举行一场古老的献祭仪式，以祈求元神的祝福。 按照传统习俗，部落需要在出征前从军队中挑选一名士兵进行献祭。作为部落的首席军事策略家，需要评估献祭每一名士兵后对军队整体力量的影响，以便大先知能做出最明智的决策。 题目 题目描述 部落拥有一支由 nnn 名士兵组成的军队。第 iii 名士兵的力量值为 aia_iai​。一支军队的总力量定义为其中所有士兵力量值的乘积。 请计算，对于从 111 到 nnn 的每一名士兵 iii，依次计算当其被献祭后，由剩余 n−1n-1n−1 名士兵组成的军队的总力量。 由于计算结果可能很大，所有计算出的总力量都需要对 998244353998244353998244353 取模。 输入格式 输入共两行。 第一行输入一个整数 n (2≤n≤107)n\\ (2\\le n\\le{10}^7)n (2≤n≤107)，代表士兵的数量。 第二行输入 nnn 个整数 a1,a2,…,an (0≤ai≤100)a_1, a_2, \\dots, a_n\\ (0\\le a_i\\le100)a1​,a2​,…,an​ (0≤ai​≤100)，代表每名士兵的力量值。 输出格式 输出共一行，包含 nnn 个整数，以空格分隔。 第 iii 个整数表示献祭第 iii 名士兵后，军队中剩余士兵的总力量对 998244353998244353998244353 取模的结果。 这道题是怎么来的 此题是我在网上冲浪时在 Google面试题中的两道趣题 | Matrix67: The Aha Moments 中看到的。题目如下： 给定长度为 nnn 的序列 aaa，在 O(n)O(n)O(n) 的时间内构造一个长度为 nnn 的序列 bbb，使得 bi=1ai∏k=1naib_i=\\dfrac{1}{a_i}\\prod\\limits_{k=1}^n a_i bi​=ai​1​k=1∏n​ai​ 当时就在思考是否能将此题变成一道算法竞赛题，最终也是成功改编成了今年新生赛的某道题目。 以下是我的思考历程： 很显然本题有一个 O(n2)O(n^2)O(n2) 的做法，就是使用 O(n)O(n)O(n) 的时间计算 bib_ibi​，可以通过增大 nnn 的范围来轻松卡掉这个方法。 那既然增大了 nnn 的范围，很显然会有 bib_ibi​ 溢出的可能性，故将题面改为求 bi=(1ai∏k=1nai) mod Mb_i={\\left(\\dfrac{1}{a_i}\\prod\\limits_{k=1}^n a_i\\right)}\\bmod M bi​=(ai​1​k=1∏n​ai​)modM 其中 MMM 可以将输出结果限制在可控的 int 或 long long 范围内。除此之外，这还有一个优点，就是选手不能直接使用除法了，因为在计算 (∏k=1n(ai mod M)) mod M{\\left(\\prod\\limits_{k=1}^n {\\left(a_i\\bmod M\\right)}\\right)}\\bmod M(k=1∏n​(ai​modM))modM 后不能再执行除法，其中包含的因子被模掉了，直接应用除法会出现浮点数。 对于老道有经验的选手而言，它们会使用模意义下的除法来解决该问题，这也是对于他们而言最方便直接的做法。 在这里给新手解释一下什么是逆元： 首先回想小学学习的除法，我们是从倒数开始学习，将 ba\\dfrac baab​ 看成 b⋅1ab\\cdot\\dfrac 1ab⋅a1​，其中 1a\\dfrac 1aa1​ 就是满足 ax=1ax=1ax=1 的数字 xxx。 那么在模意义下也是类似的，设满足 ax≡1(modp)ax\\equiv1\\pmod p ax≡1(modp) 的 x (0&lt;x&lt;p)x\\ (0&lt;x&lt;p)x (0&lt;x&lt;p) 称为 aaa 在模 ppp 下的逆元，也可以认为是 x≡1a(modp)x\\equiv \\dfrac1a \\pmod p x≡a1​(modp) 可以想一想，为什么只有 aaa 和 ppp 互质时才有逆元，且这个逆元是唯一的。 模意义下的除法实际上就是将式子乘上除数的逆元。 故此题目前还可以使用费马小定理搭配快速幂，或者使用拓展欧几里得算法在 O(log⁡a)O(\\log a)O(loga) 的时间复杂度中算出每个数 aia_iai​ 的逆元，对于每个数都进行如此操作的总时间复杂度为 O(nlog⁡a)O(n\\log a)O(nloga)。 故我仍然想尝试将 nnn 和 aaa 的范围拓展到 107{10}^7107 和 109{10}^9109，但是由于此量级下 C/C++ 和其它编程语言的速度优劣势会拉开差距，并且即便在 C++ 中关闭输入输出流同步，所有数据读入的时间也远超 1s。 除此之外，即便能卡掉 O(nlog⁡a)O(n\\log a)O(nloga) 的做法，也有一个经典的方法可以在 O(n)O(n)O(n) 求出 nnn 个数字的逆元，所以使用逆元的方法可以将此题优化到 O(n)O(n)O(n)。 所以当时我只优化到了这步，便端上新生赛中给各位大一同学品尝。于是就有了上文中的题面。 正解 此题正解为前缀后缀积，可以在 O(n)O(n)O(n) 的时间内预处理 pi=(∏k=1iai) mod Msi=(∏k=inai) mod M\\begin{aligned} p_i&amp;={\\left(\\prod\\limits_{k=1}^ia_i\\right)}\\bmod M \\\\ s_i&amp;={\\left(\\prod\\limits_{k=i}^na_i\\right)}\\bmod M \\\\ \\end{aligned} pi​si​​=(k=1∏i​ai​)modM=(k=i∏n​ai​)modM​ 那么输出 (pi−1si+1) mod M{(p_{i-1}s_{i+1})}\\bmod M(pi−1​si+1​)modM 即可，这个过程同样是 O(n)O(n)O(n) 的，注意判断边界条件。 代码如下（略去了代码模板）： const ll mod=998244353; void test(){ ll n;cin&gt;&gt;n; vll a(n),p(n),s(n); fe(u,a)cin&gt;&gt;u; auto e=[&amp;](ll x,ll y){return x*y%mod;}; partial_sum(all(a),p.begin(),e); partial_sum(rall(a),s.rbegin(),e); f(i,0,n){ ll l=(i==0)?1:p[i-1]; ll r=(i==n-1)?1:s[i+1]; cout&lt;&lt;l*r%mod&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; return; } 还能再升级吗 在新生赛进行到一半的过程中，我突然想到模逆元其实就是建立在互质的基础上的，所以说可以将模数改成 998224353998224353998224353 或 988244353988244353988244353 来混淆选手（这两个都是合数），或者要求输入自定的模数。 碎碎念 赛后发现还是有两名同学用正解方法求出本题，令人欣慰... ","link":"https://zihim.me/post/gIvx0-lX36/"},{"title":"[随笔] 2024 年新生程序竞赛游记","content":"就在今日，今年校区的程序设计新生赛落下帷幕。作为一名参赛者，还是对这次比赛的趣味性非常满意甚至而言是惊喜的。 校区的老师和学长（和学姐？）们考虑的非常周到，几乎完全使用了 XCPC 的风格——ACM 赛制、题目随机难度、气球、封榜滚榜。 早上有数竞培训，上到十一点半，草草的吃完饭，记了记缺省源和一些板子，便和 HAVEN 赶到考场准备十二点半开始为期五小时的比赛。到达考场已经是二十来分，我赶紧上机测试编程环境，结果发现 VSCode 啥插件也没装彩色记事本了属于是，于是用回不知多久没用过的 Dev-C++，但总的来说 Dev-C++ 对我这次比赛还是有挺大影响的，比如我总是把 F5 当成 F11 来按… 赶紧打了个缺省源，结果还没打完就开赛了，急于拿一血的我赶紧登录账号看 A 题。A 题是一道数学题，但是当时实在过于急躁，以至于忘记这是一个几何分布，写了好几次都算错，然后越来越急。结果过了几分钟看到一血气球已经送出，于是我选择跳过 A 题，转向 B 题，结果一看，题目又臭又长，估计是一些难题，又直接跳过（此时的我还不知道本次比赛的难度如何，我仍以为会像历年题目考线段树、网络流、以及一些抽象概率题，因此看到 B 题直接跳过）。 然后随便点了一道 F 题，此时我真的非常急于过一道题，甚至在 F 题条件还没有看完就直接构造，提交一发直接 WA，再定睛一看发现题目有两个约束条件，于是开始解方程，但是方程不是很好解的样子，而且当时实在是很难静下心来构造一道题（因为我不知道考场上大家水平如何，我怕 F 题的一血又被拿下），但是还好在搜索解的时候发现有一类特殊解，直接构造后提交拿下 F 题一血。 此时离开赛已经半个小时。准备看榜做题，看到大家都只做了 A 题，所以只能再随便选了一道 M 题，发现是简单的字符串查找和栈的使用。直接写了一个模拟，提交 TLE。这时又急了，感到今天貌似有些出师不利，又去看榜做题，发现有几个人做了 H 题，读完题目发现是数论打卡题，因此直接一发 AC。 然后又回看 M 题，想再拿个一血，换了一个指针做法，WA，仔细思索后发现貌似指针不行，而且改起来很麻烦，所以又把它放在一边。再看榜时发现天塌了，榜一已经比我多做三道题，于是跟着榜一的脚步一发提交通过了 一道模拟题 D 题。然后跟着榜一做了 E 题，结果因为输入输出流解绑定问题送了 20 分钟罚时。一朝被蛇咬，十年怕井绳，后面的题再没敢用快读快写和输入输出流解绑定了，好在题目不卡输入输出。 这时就大概有点摸清这次比赛的整体难度了，对我来说不会特别难，因此心态也逐渐放平，开始回头做 A 题，终于想起是几何分布，结果当时居然没想起它的期望就是概率的倒数，直接迭代 1e5 次暴力计算期望，结果 WA，我以为还是输入输出流解绑定问题，打了注释再交一遍还是错，这时又有些崩溃了，所以到处乱改，改输出小数位数，改迭代次数后再交，终于 AC。后面赛题讲解时才发现是迭代次数过少…所以赛场上纯粹是运气好… 然后打算再拿一道一血，看了看所有还没有 AC 的题目，然后把目光转向了 G 题，结果一看，又是字符串，而且要比 M 难一些。大概模拟了一下写了一坨屎山代码提交，结果 WA，叹一口气后决定重构代码，重构后思路变得无比清晰，直接 AC。此时对字符串信心大增，突然想到 M 题超时有没有可能是栈的问题，于是换成了数组维护，结果 AC…今天比赛实在令人汗颜，总是在莫名其妙的地方出问题。 此时正在激烈地和榜一竞争，于是我开始看他 AC 里我还没完成的 K, L, I 三题，结果一看，好家伙，全是模拟题，直接爽刷，在 L 题四舍五入输出错误罚了 20 分钟的情况下，一个小时提交四次 A 了三题，超过榜一成为榜一。 最后一小时，进入封榜，看到 C 题只有一位学长大佬 AC，其他题还没有 AC 记录。遂打算从 C 题入手。发现是搜索题，尝试第二个样例时发现递归层数过高爆栈了，因此开始转向记忆化搜索，在此过程中发现棋盘的情况与结果无关，考虑能不能打表，最后发现 1M 的代码过长不允许提交，遂放弃。但实际上记忆化搜索远远够用，因此我直接上记忆化搜索，成功 AC。 现在剩下 47 分钟，放在我面前的是两道没人 AC 的题——B 题和 J 题。考虑到我实在害怕 B 题那种又臭又长的题目，又恰巧前面写某道题时貌似有一些对 J 题的想法，因此决定先做 J 题。结果发现这题还挺有意思的，因为我突然发现所谓阶乘存在一种进制的性质，一下子就写完了，全过程只用了七分钟，我愿称此题为封神之题！ 最后半个多小时，开始看 B 题，仔细读完后貌似不太难，只是有很多需要分类讨论的地方，写完代码调试完只剩下五分钟，提交后错误，最后一分钟加了一个特判，再次提交，还是错误。最后以差一题 AK 来结束本场比赛。 比赛结束后自然是合照、赛题讲解、滚榜、以及一个抽奖环节（虽然什么也没抽到）。 滚榜过程还是非常刺激的，四到六名激烈竞争，一到三名下面断层，也是激烈竞争（但是上面提到的学长是打星参赛的，所以实际上是我和另一名选手 snowdrop 争，不过我也通过上次和他打蓝桥团队赛认识了他）。最终我比打星参赛的学长多一题 J 题的优势拿下榜一和金牌，比银牌榜三 snowdrop 多三题，比铜牌榜四 漾颂 多六题（是的，我甚至认识铜牌，因为我和他同班）。 考完后重构了 B 题的实现方法，又增加了几个特判，最终在赛后完成了这套题。第二天就收到了校区 ACM 集训队发来的邀请函，最终和比赛二到六名的选手们（不包括打星参赛的学长，所以实际上是三到七名）一起进了集训队，接下来的时间就要和集训队的朋友们一起学习和合作了。 这次比赛真的学到挺多新东西，比如上面说到的进制，而且因为自己是第一次打这个赛制的比赛，所以也认识到自己对待 ACM 赛制的比赛的心态上需要有一些调整（以往 OI 赛制的比赛不需要争夺时间，但是 ACM 赛制越快做完越好，也是因为这个原因这次实在是非常急），也知道自己在字符串方面有很大欠缺，希望下次还有机会能参加这类比赛。 ","link":"https://zihim.me/post/dpIDBTZ0ul/"},{"title":"[科普] 胎教微积分——微积分从入门到入坟","content":"本文主要对象为希望简要理解微积分的高中生，因此会缺少一些严谨性，见谅. 定义 微积分基本定理 一些例子 不等式放缩 几何体的体积 正态分布期望值 带阻力的下落运动 交变电流的等效电流 定义 我们希望能求出函数下方与坐标轴围成的面积的大小，于是积分就被定义出来了： 定义函数 f′(x)f&#x27;(x)f′(x) 在 [a,b][a,b][a,b] 上与坐标轴围成的面积 S=∫abf′(x)dxS=\\displaystyle\\int_a^bf&#x27;(x)\\text d xS=∫ab​f′(x)dx. 注意，我们认为曲线在坐标轴下方时面积是负的. 我们采用微元法，将面积分为许多个细长的小矩形面积之和. 假设分为 nnn 个小矩形，当 n→∞n\\to\\inftyn→∞ 时小矩形面积之和就趋近于曲线下与坐标轴围成的面积，因此得到另一种表达方式： S=lim⁡n→∞∑k=0n[f′(a+b−ank)⋅b−an]S=\\lim\\limits_{n\\to\\infty}\\sum\\limits_{k=0}^{n}\\left[f&#x27;\\left(a+\\dfrac{b-a}{n}k\\right)\\cdot\\dfrac{b-a}{n}\\right] S=n→∞lim​k=0∑n​[f′(a+nb−a​k)⋅nb−a​] 其中 f′(a+b−ank)f&#x27;\\left(a+\\dfrac{b-a}{n}k\\right)f′(a+nb−a​k) 为第 kkk 个矩形的高，而 b−an\\dfrac{b-a}{n}nb−a​ 为小矩形的宽. 微积分基本定理 微积分基本定理（又名 Newton-Leibniz 公式）： ∫abf′(x)dx=f(b)−f(a)\\displaystyle\\int_a^bf&#x27;(x)\\text d x=f(b)-f(a) ∫ab​f′(x)dx=f(b)−f(a) 该式用于积分的求值. 这个式子揭示了导数与积分的关系实际上是互为逆运算，下面是（并不严谨但够用的）证明： 根据导数的定义 f′(x)=lim⁡Δx→0f(x+Δx)−f(x)Δxf&#x27;(x)=\\lim\\limits_{\\Delta x\\to0}\\dfrac{f(x+\\Delta x)-f(x)}{\\Delta x}f′(x)=Δx→0lim​Δxf(x+Δx)−f(x)​，由于 n→∞n\\to\\inftyn→∞ 时 b−an→0\\dfrac{b-a}{n}\\to0nb−a​→0， 可以认为 f′(x)=lim⁡n→∞f(x+b−an)−f(x)b−anf&#x27;(x)=\\lim\\limits_{n\\to\\infty}\\dfrac{f\\left(x+\\dfrac{b-a}{n}\\right)-f\\left(x\\right)}{\\dfrac{b-a}{n}}f′(x)=n→∞lim​nb−a​f(x+nb−a​)−f(x)​. 因此 S=lim⁡n→∞∑k=0n[f′(a+(b−a)kn)⋅b−an]=lim⁡n→∞∑k=0n[b−an⋅lim⁡n→∞f(a+(b−a)kn+b−an)−f(a+(b−a)kn)b−an]=lim⁡n→∞∑k=0n[f(a+(b−a)k+1n)−f(a+(b−a)kn)]=lim⁡n→∞[f(a+(b−a)n+1n)−f(a+(b−a)0n)]=lim⁡n→∞[f(a+(b−a)(1−1n))−f(a)]=f(b)−f(a)\\begin{aligned} S&amp;=\\lim\\limits_{n\\to\\infty}\\sum\\limits_{k=0}^{n}\\left[f&#x27;\\left(a+(b-a)\\dfrac{k}{n}\\right)\\cdot\\dfrac{b-a}{n}\\right]\\\\ &amp;=\\lim\\limits_{n\\to\\infty}\\sum\\limits_{k=0}^{n}\\left[\\dfrac{b-a}{n}\\cdot\\lim\\limits_{n\\to\\infty}\\dfrac{f\\left(a+(b-a)\\dfrac{k}{n}+\\dfrac{b-a}{n}\\right)-f\\left(a+(b-a)\\dfrac{k}{n}\\right)}{\\dfrac{b-a}{n}}\\right]\\\\ &amp;=\\lim\\limits_{n\\to\\infty}\\sum\\limits_{k=0}^{n}\\left[f\\left(a+(b-a)\\dfrac{k+1}{n}\\right)-f\\left(a+(b-a)\\dfrac{k}{n}\\right)\\right]\\\\ &amp;=\\lim\\limits_{n\\to\\infty}\\left[f\\left(a+(b-a)\\dfrac{n+1}{n}\\right)-f\\left(a+(b-a)\\dfrac{0}{n}\\right)\\right]\\\\ &amp;=\\lim\\limits_{n\\to\\infty}\\left[f\\left(a+(b-a)\\left(1-\\dfrac{1}{n}\\right)\\right)-f\\left(a\\right)\\right]\\\\ &amp;=f(b)-f(a)\\\\ \\end{aligned} S​=n→∞lim​k=0∑n​[f′(a+(b−a)nk​)⋅nb−a​]=n→∞lim​k=0∑n​⎣⎢⎢⎡​nb−a​⋅n→∞lim​nb−a​f(a+(b−a)nk​+nb−a​)−f(a+(b−a)nk​)​⎦⎥⎥⎤​=n→∞lim​k=0∑n​[f(a+(b−a)nk+1​)−f(a+(b−a)nk​)]=n→∞lim​[f(a+(b−a)nn+1​)−f(a+(b−a)n0​)]=n→∞lim​[f(a+(b−a)(1−n1​))−f(a)]=f(b)−f(a)​ 综上即有 ∫abf′(x)dx=f(b)−f(a)\\displaystyle\\int_a^bf&#x27;(x)\\text d x=f(b)-f(a)∫ab​f′(x)dx=f(b)−f(a). 这个公式表明，如果我们想要算出一个函数与坐标轴围成的面积，只需找到它的原函数，然后代入两个端点的值后相减即可. 一些例子 不等式放缩 例 1：证明当 n→∞n\\to\\inftyn→∞ 时 ∑k=1n1k→∞\\displaystyle\\sum\\limits_{k=1}^{n}\\dfrac1k\\to\\inftyk=1∑n​k1​→∞. 根据不规则面积小于矩形面积我们知道 1×1n&gt;∫nn+11xdx1\\times\\dfrac{1}{n}&gt;\\displaystyle \\int_n^{n+1}\\dfrac1x\\text dx1×n1​&gt;∫nn+1​x1​dx 即 1n&gt;ln⁡(n+1)−ln⁡n\\dfrac 1n&gt;\\ln{(n+1)}-\\ln{n}n1​&gt;ln(n+1)−lnn. 两边求和得 ∑k=1n1k&gt;ln⁡(n+1)\\displaystyle\\sum\\limits_{k=1}^{n}\\dfrac1k&gt;\\ln{(n+1)}k=1∑n​k1​&gt;ln(n+1). 由于 n→∞n\\to\\inftyn→∞ 时 ln⁡(n+1)→∞\\ln{(n+1)}\\to\\inftyln(n+1)→∞，因此也会有 ∑k=1n1k→∞\\displaystyle\\sum\\limits_{k=1}^{n}\\dfrac1k\\to\\inftyk=1∑n​k1​→∞. 例 2：比较 ln⁡2\\ln2ln2 和 2e\\dfrac2ee2​ 的大小. 2e−ln⁡2=∫2e(1x−1e)dx\\dfrac2e-\\ln2=\\displaystyle\\int_{2}^e\\left(\\dfrac{1}x-\\dfrac1e\\right)\\text dxe2​−ln2=∫2e​(x1​−e1​)dx，由于函数在 [2,e][2,e][2,e] 上都在 xxx 轴上方，因此面积大于 000. 即 2e&gt;ln⁡2\\dfrac 2e&gt;\\ln2e2​&gt;ln2. 几何体的体积 柱锥台体体积推导，此处以圆锥为例： 将圆锥沿底面切成无数圆片，每个圆片的面积为 π(rhx)2\\pi{\\left(\\dfrac rhx\\right)}^2π(hr​x)2. 因此圆锥体积即为 xxx 从 000 到 hhh 的圆的面积的和，即 V=∫0hπ(rhx)2dx=π3⋅r2h2⋅h3−π3⋅r2h2⋅03=13πr2h\\begin{aligned} V&amp;=\\int_0^h\\pi{\\left(\\dfrac rhx\\right)}^2\\text dx\\\\ &amp;=\\dfrac\\pi3\\cdot\\dfrac{r^2}{h^2}\\cdot h^3-\\dfrac\\pi3\\cdot\\dfrac{r^2}{h^2}\\cdot0^3\\\\ &amp;=\\dfrac13\\pi r^2h\\\\ \\end{aligned} V​=∫0h​π(hr​x)2dx=3π​⋅h2r2​⋅h3−3π​⋅h2r2​⋅03=31​πr2h​ 球体积推导： 将球分成无数个球面（剥皮），每个球面的面积为 4πx24\\pi x^24πx2. 因此球体积即为 xxx 从 000 到 rrr 的球面的表面积的和，即 V=∫0r4πx2dx=4π3⋅r3−4π3⋅03=43πr3\\begin{aligned} V&amp;=\\int_0^r4\\pi x^2\\text dx\\\\ &amp;=\\dfrac{4\\pi}3\\cdot r^3-\\dfrac{4\\pi}3\\cdot 0^3\\\\ &amp;=\\dfrac43\\pi r^3\\\\ \\end{aligned} V​=∫0r​4πx2dx=34π​⋅r3−34π​⋅03=34​πr3​ 正态分布期望值 由于图像沿 xxx 轴平移不影响面积，因此 E(X)=∫−∞∞x⋅1σ2πe−(x−μ)22σ2dx=∫−∞∞(x+μ)⋅1σ2πe−x22σ2dx=∫−∞∞x⋅1σ2πe−x22σ2dx+μ∫−∞∞1σ2πe−x22σ2dx=0+μ⋅1=μ\\begin{aligned} E(X)&amp;=\\int^\\infty_{-\\infty}x\\cdot\\dfrac{1}{\\sigma\\sqrt{2\\pi}}e^{-\\frac{{(x-\\mu)}^2}{2\\sigma^2}}\\text dx\\\\ &amp;=\\int^\\infty_{-\\infty}(x+\\mu)\\cdot\\dfrac{1}{\\sigma\\sqrt{2\\pi}}e^{-\\frac{x^2}{2\\sigma^2}}\\text dx\\\\ &amp;=\\int^\\infty_{-\\infty}x\\cdot\\dfrac{1}{\\sigma\\sqrt{2\\pi}}e^{-\\frac{x^2}{2\\sigma^2}}\\text dx+\\mu\\int^\\infty_{-\\infty}\\dfrac{1}{\\sigma\\sqrt{2\\pi}}e^{-\\frac{x^2}{2\\sigma^2}}\\text dx\\\\ &amp;=0+\\mu\\cdot1=\\mu \\end{aligned} E(X)​=∫−∞∞​x⋅σ2π​1​e−2σ2(x−μ)2​dx=∫−∞∞​(x+μ)⋅σ2π​1​e−2σ2x2​dx=∫−∞∞​x⋅σ2π​1​e−2σ2x2​dx+μ∫−∞∞​σ2π​1​e−2σ2x2​dx=0+μ⋅1=μ​ 其中最后一步用到了奇函数面积和为 000 和正态分布概率和为 111 的性质. 带阻力的下落运动 假设阻力和速度成正比，即 f=kvf=kvf=kv，质量为 mmm 的物体从初速度为 000 只受重力和阻力作用下落，求速度关于时间的函数 v(t)v(t)v(t). 由牛顿第二定律有 mg−kv(t)=ma(t)gekm−kmekmv(t)=ekma(t)\\begin{aligned} mg-kv(t)&amp;=ma(t)\\\\ ge^{\\frac km}-\\dfrac kme^{\\frac km}v(t)&amp;=e^{\\frac km}a(t)\\\\ \\end{aligned} mg−kv(t)gemk​−mk​emk​v(t)​=ma(t)=emk​a(t)​ 由于 a(t)=v′(t)a(t)=v&#x27;(t)a(t)=v′(t)，注意到移项后可以配导数： (ekmtv(t))′=gekmtekmtv(t)=∫gekmtdtv(t)=mgk+Ce−kmt\\begin{aligned} \\left(e^{\\frac kmt}v(t)\\right)&#x27;&amp;=ge^{\\frac kmt}\\\\ e^{\\frac kmt}v(t)&amp;=\\int ge^{\\frac kmt}\\text dt\\\\ v(t)&amp;=\\dfrac{mg}k+Ce^{-\\frac kmt} \\end{aligned} (emk​tv(t))′emk​tv(t)v(t)​=gemk​t=∫gemk​tdt=kmg​+Ce−mk​t​ 其中 CCC 为常数. 根据 v(0)=0v(0)=0v(0)=0 解得 C=−mgkC=-\\dfrac{mg}kC=−kmg​​. 因此 v(t)=mgk(1−e−kmt)v(t)=\\dfrac{mg}k\\left(1-e^{-\\frac kmt}\\right) v(t)=kmg​(1−e−mk​t) Update 2025/03/06 由于本文实际上并没有提及到不定积分，因此原解法可能会带来一定的超纲内容，笔者在初高中时期习惯于使用不定积分后再确定常数 CCC 以求解积分类问题。但对于大多数物理情景而言，更适合的方法是使用定积分。 ∫0t0gekmtdt=∫0t0(ekmtv(t))′dtmgk(ekmt0−1)=v(t0)ekmt0−v(0)v(t0)=mgk(1−e−kmt0)\\begin{aligned} \\int_0^{t_0}{ge^{\\frac kmt}\\mathrm d t}&amp;=\\int_0^{t_0}{\\left(e^{\\frac kmt}v(t)\\right)&#x27;\\mathrm d t}\\\\ \\dfrac{mg}{k}\\left(e^{\\frac kmt_0}-1\\right)&amp;=v(t_0)e^{\\frac kmt_0}-v(0)\\\\ v(t_0)&amp;=\\dfrac{mg}k\\left(1-e^{-\\frac kmt_0}\\right) \\end{aligned} ∫0t0​​gemk​tdtkmg​(emk​t0​−1)v(t0​)​=∫0t0​​(emk​tv(t))′dt=v(t0​)emk​t0​−v(0)=kmg​(1−e−mk​t0​)​ 和上面得到的答案相同。 交变电流的等效电流 设 I(t)=Imaxsin⁡(2πTt)I(t)=I_{\\rm max}\\sin\\left(\\dfrac{2\\pi}Tt\\right)I(t)=Imax​sin(T2π​t). 注意到 (x−sin⁡xcos⁡x2)′=sin⁡2x\\left(\\dfrac{x-\\sin x\\cos x}{2}\\right)&#x27;=\\sin^2x (2x−sinxcosx​)′=sin2x 因此根据等效电流的定义有 I02RT=∫0TI2(t)RdtI02T=∫0TImax2sin⁡2(2πTt)dtI02T=Imax2⋅T2π(2πTT−sin⁡(2πT⋅T)cos⁡(2πT⋅T)2−2πT0−sin⁡(2πT⋅0)cos⁡(2πT⋅0)2)I02T=T2Imax2\\begin{aligned} I^2_0RT&amp;=\\displaystyle\\int_0^TI^2(t)R\\text dt\\\\ I^2_0T&amp;=\\displaystyle\\int_0^TI_{\\text{max}}^2\\sin^2\\left(\\dfrac{2\\pi}{T}t\\right)\\text dt\\\\ I^2_0T&amp;=I_{\\text{max}}^2\\cdot\\dfrac{T}{2\\pi}\\left(\\dfrac{\\frac{2\\pi}{T}T-\\sin\\left(\\frac{2\\pi}{T}\\cdot T\\right)\\cos\\left(\\frac{2\\pi}{T}\\cdot T\\right)}{2}-\\dfrac{\\frac{2\\pi}{T}0-\\sin\\left(\\frac{2\\pi}{T}\\cdot 0\\right)\\cos\\left(\\frac{2\\pi}{T}\\cdot 0\\right)}{2}\\right)\\\\ I_0^2T&amp;=\\dfrac T2I_{\\text{max}}^2 \\end{aligned} I02​RTI02​TI02​TI02​T​=∫0T​I2(t)Rdt=∫0T​Imax2​sin2(T2π​t)dt=Imax2​⋅2πT​(2T2π​T−sin(T2π​⋅T)cos(T2π​⋅T)​−2T2π​0−sin(T2π​⋅0)cos(T2π​⋅0)​)=2T​Imax2​​ 即 I0=Imax2I_0=\\dfrac{I_\\text{max}}{\\sqrt2} I0​=2​Imax​​ ","link":"https://zihim.me/post/7oSZGWllA/"},{"title":"[科普] 优雅地在高考中使用二次曲线系","content":"本文仅作科普，相关结论比较基础，请读者自行证明. 二次曲线 定义 分类 曲线类型的判断 二次曲线系 定义 特点 使用方法 相关模型 一类定点问题 一个小结论 坎迪定理 二次曲线的切线 椭圆 双曲线 抛物线 二次曲线 定义 方程 Γ(x,y)=Ax2+Bxy+Cy2+Dx+Ey+F=0\\Gamma(x,y)=Ax^2+Bxy+Cy^2+Dx+Ey+F=0 Γ(x,y)=Ax2+Bxy+Cy2+Dx+Ey+F=0 形成的曲线称为二次曲线，也称圆锥曲线. 其中 A2+B2+C2=0A^2+B^2+C^2\\not=0A2+B2+C2​=0. 由此可知五点确定一条二次曲线. 退化二次曲线的方程形如 Γ(x,y)=(A1x+B1y+C1)(A2x+B2y+C2)=0\\Gamma(x,y)=(A_1x+B_1y+C_1)(A_2x+B_2y+C_2)=0 Γ(x,y)=(A1​x+B1​y+C1​)(A2​x+B2​y+C2​)=0 可以发现退化二次曲线就是二次曲线五点中有三点共线的情况. 除此之外可以知道，两条二次曲线相交至多有四个交点. 分类 二次曲线{非退化二次曲线{圆椭圆双曲线抛物线退化二次曲线{两条相交直线两条平行直线二次曲线 \\left\\{\\begin{aligned} &amp;非退化二次曲线 \\left\\{\\begin{aligned} &amp;圆\\\\ &amp;椭圆\\\\ &amp;双曲线\\\\ &amp;抛物线\\\\ \\end{aligned}\\right.\\\\ &amp;退化二次曲线 \\left\\{\\begin{aligned} &amp;两条相交直线\\\\ &amp;两条平行直线\\\\ \\end{aligned}\\right.\\\\ \\end{aligned}\\right. 二次曲线⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​​非退化二次曲线⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​​圆椭圆双曲线抛物线​退化二次曲线{​两条相交直线两条平行直线​​ 曲线类型的判断 假设二次曲线 Γ(x,y)=0\\Gamma(x,y)=0Γ(x,y)=0 的 Δ=∣AB/2B/2C∣,δ=∣AB/2D/2B/2CE/2D/2E/2F∣\\Delta=\\begin{vmatrix}A&amp;B/2\\\\B/2&amp;C\\end{vmatrix},\\delta=\\begin{vmatrix}A&amp;B/2&amp;D/2\\\\B/2&amp;C&amp;E/2 \\\\D/2&amp;E/2&amp;F\\end{vmatrix}Δ=∣∣∣∣​AB/2​B/2C​∣∣∣∣​,δ=∣∣∣∣∣∣​AB/2D/2​B/2CE/2​D/2E/2F​∣∣∣∣∣∣​. δ=0\\delta=0δ=0 时二次曲线为退化二次曲线. 此时 Δ\\DeltaΔ &gt;0&gt;0&gt;0 =0=0=0 &lt;0&lt;0&lt;0 曲线形状 一个点 两条平行/重合直线 两条相交直线 由什么退化得到 椭圆 抛物线 双曲线 δ=0\\delta\\not=0δ​=0 时二次曲线为非退化二次曲线. 此时 Δ\\DeltaΔ &gt;0&gt;0&gt;0 =0=0=0 &lt;0&lt;0&lt;0 曲线形状 椭圆 抛物线 双曲线 特殊情况 A=C,B=0A=C,B=0A=C,B=0 时为圆 A+CA+CA+C 时为等轴双曲线 二次曲线系 定义 过二次曲线 Γ1(x,y)=0\\Gamma_1(x,y)=0Γ1​(x,y)=0 和 Γ2(x,y)=0\\Gamma_2(x,y)=0Γ2​(x,y)=0 交点的二次曲线系为 Γ3(x,y)=λΓ1(x,y)+μΓ2(x,y)=0\\Gamma_3(x,y)=\\lambda\\Gamma_1(x,y)+\\mu\\Gamma_2(x,y)=0 Γ3​(x,y)=λΓ1​(x,y)+μΓ2​(x,y)=0 特点 Γ3\\Gamma_3Γ3​ 过 Γ1,Γ2\\Gamma_1,\\Gamma_2Γ1​,Γ2​ 的交点，且不与 Γ1,Γ2\\Gamma_1,\\Gamma_2Γ1​,Γ2​ 交于其它点. 如果 Γ1,Γ2\\Gamma_1,\\Gamma_2Γ1​,Γ2​ 在某个切点相切，则 Γ3\\Gamma_3Γ3​ 也在这个点相切，常见于两个曲线交点少于四个的情况. 注：退化二次曲线在交点处切线方向任意，在其它点的切线方向与所在直线的直线方向相同. 使用方法 令 Γ3\\Gamma_3Γ3​ 表示成具有相同性质的二次曲线 Γ0\\Gamma_0Γ0​，只需令 Γ3\\Gamma_3Γ3​ 和 Γ0\\Gamma_0Γ0​ 对应项系数相等，解方程即可. 当使用 μ=1\\mu=1μ=1 的形式时： Γ3(x,y)=λΓ1(x,y)+Γ2(x,y)=0\\Gamma_3(x,y)=\\lambda\\Gamma_1(x,y)+\\Gamma_2(x,y)=0 Γ3​(x,y)=λΓ1​(x,y)+Γ2​(x,y)=0 此时 Γ3\\Gamma_3Γ3​ 与 Γ0\\Gamma_0Γ0​ 形状可以一样，但方程不一定相同，即两个方程相差一个倍数，对应项的比相同. 优先比较 x2,y2,Cx^2,y^2,Cx2,y2,C 项系数，因为其涉及的变量一般比较少. 除此之外，一般不需要对比所有系数. 计算 Γ3\\Gamma_3Γ3​ 的 Δ,δ\\Delta,\\deltaΔ,δ 使其为某一类型曲线. 与直线联立，得到的解为曲线系与直线的交点，再进一步使用韦达定理进行说明. 若曲线系过某点 (x0,y0)(x_0,y_0)(x0​,y0​)，则将该点代入可以解出 λ\\lambdaλ 的值. 相关模型 二次曲线系可以解决绝大多数极点极线为背景的问题. 除此之外再给出几个应用场景. 一类定点问题 二次曲线 Ax2+Cy2+Dx+Ey+F=0Ax^2+Cy^2+Dx+Ey+F=0Ax2+Cy2+Dx+Ey+F=0 上一点 PPP 引出两条斜率为 k1,k2k_1,k_2k1​,k2​ 的直线交该二次曲线于 A,BA,BA,B​. 则 k1k2或(k1+k2)为定值 ⟺ AB过定点或AB斜率为定值k_1k_2或(k_1+k_2)为定值\\iff AB过定点或AB斜率为定值 k1​k2​或(k1​+k2​)为定值⟺AB过定点或AB斜率为定值 一个小结论 过一点引出两条有斜率的直线与二次曲线 Ax2+Cy2+Dx+Ey+F=0Ax^2+Cy^2+Dx+Ey+F=0Ax2+Cy2+Dx+Ey+F=0 相交于四点，且该四点共圆. 则两条直线的斜率之和为 000. 证明： 设二次曲线和两条直线构成的二次曲线系为 λ(Ax2+Cy2+Dx+Ey+F)+(y−k1x−b1)(y−k2x−b2)=0\\lambda(Ax^2+Cy^2+Dx+Ey+F)+(y-k_1x-b_1)(y-k_2x-b_2)=0λ(Ax2+Cy2+Dx+Ey+F)+(y−k1​x−b1​)(y−k2​x−b2​)=0. 令其表示成一个圆，则曲线系的 xyxyxy 项系数为 000. 即 k1+k2=0k_1+k_2=0k1​+k2​=0，证毕. 坎迪定理 两条二次曲线 Γ1,Γ2\\Gamma_1,\\Gamma_2Γ1​,Γ2​ 相交于 A,B,C,DA,B,C,DA,B,C,D 四点，AC∩BD=OAC\\cap BD=OAC∩BD=O. 过 OOO 作直线交 Γ1,Γ2\\Gamma_1,\\Gamma_2Γ1​,Γ2​ 于 E,FE,FE,F 和 G,HG,HG,H. 则有 1∣OG∣−1∣OE∣=1∣OH∣−1∣OF∣\\dfrac1{|OG|}-\\dfrac1{|OE|}=\\dfrac1{|OH|}-\\dfrac1{|OF|} ∣OG∣1​−∣OE∣1​=∣OH∣1​−∣OF∣1​ 证明： 以 GHGHGH 为 xxx 轴，OOO 为原点建立坐标系. 不妨设 H,FH,FH,F 在 xxx 轴正半轴. 设 Γ1(x,y)=Ax2+Bxy+Cy2+Dx+Ey+F=0,AC:y=k1x,BD:y=k2x\\Gamma_1(x,y)=Ax^2+Bxy+Cy^2+Dx+Ey+F=0,AC:y=k_1x,BD:y=k_2xΓ1​(x,y)=Ax2+Bxy+Cy2+Dx+Ey+F=0,AC:y=k1​x,BD:y=k2​x. 当 y=0y=0y=0 时由韦达定理知 1∣OF∣−1∣OE∣=x1+x2x1x2=−DF\\dfrac1{|OF|}-\\dfrac1{|OE|}=\\dfrac{x_1+x_2}{x_1x_2}=\\dfrac{-D}{F}∣OF∣1​−∣OE∣1​=x1​x2​x1​+x2​​=F−D​. 可知 Γ2\\Gamma_2Γ2​ 总能用曲线系 λΓ1(x,y)+(y−k1x)(y−k2x)=0\\lambda\\Gamma_1(x,y)+(y-k_1x)(y-k_2x)=0λΓ1​(x,y)+(y−k1​x)(y−k2​x)=0 表示，当 y=0y=0y=0 时由韦达定理知 1∣OH∣−1∣OG∣=x1+x2x1x2=−DF=1∣OF∣−1∣OE∣\\dfrac1{|OH|}-\\dfrac1{|OG|}=\\dfrac{x_1+x_2}{x_1x_2}=\\dfrac{-D}{F}=\\dfrac1{|OF|}-\\dfrac1{|OE|} ∣OH∣1​−∣OG∣1​=x1​x2​x1​+x2​​=F−D​=∣OF∣1​−∣OE∣1​ 即 1∣OG∣−1∣OE∣=1∣OH∣−1∣OF∣\\dfrac1{|OG|}-\\dfrac1{|OE|}=\\dfrac1{|OH|}-\\dfrac1{|OF|}∣OG∣1​−∣OE∣1​=∣OH∣1​−∣OF∣1​，证毕. 蝴蝶定理是坎迪定理的弱化版：增设条件 ∣OE∣=∣OF∣|OE|=|OF|∣OE∣=∣OF∣，证明 ∣OG∣=∣OH∣|OG|=|OH|∣OG∣=∣OH∣. 二次曲线的切线 这里为了贴合高考，仅抛砖引玉地给出了非退化二次曲线的标准方程的切线方程推导. 本质上是两个二次曲线构造曲线系后通过调整 λ\\lambdaλ 的值使其为一条直线，并证明该直线是二次曲线的切线. 椭圆 过 x2a2+y2b2=1\\dfrac{x^2}{a^2}+\\dfrac{y^2}{b^2}=1a2x2​+b2y2​=1 上一点 P(x0,y0)P(x_0,y_0)P(x0​,y0​) 的切线为 x2a2+y2b2−1−(x−x0)2a2−(y−y0)2b2=0(∗)\\dfrac{x^2}{a^2}+\\dfrac{y^2}{b^2}-1-\\dfrac{{(x-x_0)}^2}{a^2}-\\dfrac{{(y-y_0)}^2}{b^2}=0\\quad(*)a2x2​+b2y2​−1−a2(x−x0​)2​−b2(y−y0​)2​=0(∗) 即 xx0a2+yy0b2=1\\dfrac{xx_0}{a^2}+\\dfrac{yy_0}{b^2}=1 a2xx0​​+b2yy0​​=1 证明： 显然 P(x0,y0)P(x_0,y_0)P(x0​,y0​) 在 (∗)(*)(∗) 上，若异于 PPP 一点 Q(x1,y1)Q(x_1,y_1)Q(x1​,y1​) 在 (∗)(*)(∗) 上则有 (x1−x0)2a2+(y1−y0)2b2=0\\dfrac{{(x_1-x_0)}^2}{a^2}+\\dfrac{{(y_1-y_0)}^2}{b^2}=0 a2(x1​−x0​)2​+b2(y1​−y0​)2​=0 即 x1=x0,y1=y0x_1=x_0,y_1=y_0x1​=x0​,y1​=y0​，即 P=QP=QP=Q，矛盾. 因此 (∗)(*)(∗) 与椭圆仅有一个交点. 综上 (∗)(*)(∗) 为椭圆切线. 双曲线 过 x2a2−y2b2=1\\dfrac{x^2}{a^2}-\\dfrac{y^2}{b^2}=1a2x2​−b2y2​=1 上一点 P(x0,y0)P(x_0,y_0)P(x0​,y0​) 的切线为 x2a2−y2b2−1−(x−x0)2a2+(y−y0)2b2=0(∗)\\dfrac{x^2}{a^2}-\\dfrac{y^2}{b^2}-1-\\dfrac{{(x-x_0)}^2}{a^2}+\\dfrac{{(y-y_0)}^2}{b^2}=0\\quad(*)a2x2​−b2y2​−1−a2(x−x0​)2​+b2(y−y0​)2​=0(∗)​ 即 xx0a2−yy0b2=1\\dfrac{xx_0}{a^2}-\\dfrac{yy_0}{b^2}=1 a2xx0​​−b2yy0​​=1 证明： 显然 P(x0,y0)P(x_0,y_0)P(x0​,y0​) 在 (∗)(*)(∗) 上，若异于 PPP 一点 Q(x1,y1)Q(x_1,y_1)Q(x1​,y1​) 在 (∗)(*)(∗)​ 上则有 (x1−x0)2a2=(y1−y0)2b2\\dfrac{{(x_1-x_0)}^2}{a^2}=\\dfrac{{(y_1-y_0)}^2}{b^2} a2(x1​−x0​)2​=b2(y1​−y0​)2​ 即 PQPQPQ 与渐近线平行，矛盾. 因此 (∗)(*)(∗) 与双曲线仅有一个交点. 若 (∗)(*)(∗) 与渐近线平行，则 ±1b⋅x0a2=1a⋅y0b2\\pm\\dfrac1b\\cdot\\dfrac{x_0}{a^2}=\\dfrac1a\\cdot\\dfrac{y_0}{b^2}±b1​⋅a2x0​​=a1​⋅b2y0​​ 即 PPP 在渐近线上，矛盾. 综上 (∗)(*)(∗) 为双曲线切线. 抛物线 过 y2=2pxy^2=2pxy2=2px 上一点 P(x0,y0)P(x_0,y_0)P(x0​,y0​) 的切线为 y2−2px−(y−y0)2=0(∗)y^2-2px-{(y-y_0)}^2=0\\quad(*)y2−2px−(y−y0​)2=0(∗)​ 即 yy0=p(x+x0)yy_0=p(x+x_0) yy0​=p(x+x0​) 证明： 显然 P(x0,y0)P(x_0,y_0)P(x0​,y0​) 在 (∗)(*)(∗) 上，若异于 PPP 一点 Q(x1,y1)Q(x_1,y_1)Q(x1​,y1​) 在 (∗)(*)(∗)​ 上则有 (y1−y0)2=0{(y_1-y_0)}^2=0 (y1​−y0​)2=0 即 y1=y0y_1=y_0y1​=y0​，即 P=QP=QP=Q，矛盾. 因此 (∗)(*)(∗) 与抛物线仅有一个交点. 综上 (∗)(*)(∗) 为抛物线切线. ","link":"https://zihim.me/post/8TqSKrzLP/"},{"title":"[笔记] 9-计数原理","content":"这是高中数学知识点汇总系列的第九篇. 两个计数原理 加法和乘法经过推广成为分类加法计数原理和分步乘法计数原理. 分类加法计数原理 : 完成一件事有 nnn 类不同方案, 在第 kkk 类方案中有 NkN_kNk​ 种不同的方法 (每类不同方案中的方法互不相同), 那么完成这件事共有 N=∑k=1nNk\\displaystyle N=\\sum\\limits_{k=1}^n N_kN=k=1∑n​Nk​ 种不同的方法. 分步乘法计数原理 : 完成一件事需要 nnn 个步骤, 做第 kkk 个步骤有 NkN_kNk​ 种不同的方法 (无论每一步采用哪种方法, 其下一步方法数均相同), 那么完成这件事共有 N=∏k=1nNk\\displaystyle N=\\prod\\limits_{k=1}^n N_kN=k=1∏n​Nk​ 种不同的方法. 排列组合 nnn 的阶乘 n!n!n!: 正整数 111 到 nnn 的连乘积. 规定 0!=10!=10!=1. 性质: 裂项 n⋅n!=(n+1)!−n!n\\cdot n!=(n+1)!-n!n⋅n!=(n+1)!−n!. (一个)排列: 从 nnn 个不同元素中取出 mmm 个元素, 并按照一定的顺序排成一列. (强调顺序) 排列数: 从 nnn 个不同元素中取出 mmm 个元素的所有不同排列的个数, 用 Anm\\text{A}^m_nAnm​ 或 Pnm\\text{P}_n^mPnm​ 表示. 排列数公式: Anm=n(n−1)⋯(n−m+1)=n!(n−m)!\\text{A}^m_n=n(n-1)\\cdots(n-m+1)=\\dfrac{n!}{(n-m)!}Anm​=n(n−1)⋯(n−m+1)=(n−m)!n!​. 全排列: 把 nnn 个不同的元素全部取出的一个排列. Ann=n(n−1)⋯(3)(2)(1)=n!\\text{A}^n_n=n(n-1)\\cdots(3)(2)(1)=n!Ann​=n(n−1)⋯(3)(2)(1)=n!. 性质: Anm=AnkAn−km−k\\text{A}_n^m=\\text{A}_n^k\\text{A}_{n-k}^{m-k}Anm​=Ank​An−km−k​, (#) nnn 元情形: 若 m0=0,∑k=0t+1mk=mm_0=0,\\sum\\limits_{k=0}^{t+1}m_k=mm0​=0,k=0∑t+1​mk​=m, 则 Anm=∏j=0tAn−∑k=0jmkmj+1\\displaystyle \\text{A}_n^m=\\prod\\limits_{j=0}^t\\text{A}_{n-\\sum\\limits_{k=0}^jm_k}^{m_{j+1}}Anm​=j=0∏t​An−k=0∑j​mk​mj+1​​. 注: m&lt;nm&lt;nm&lt;n 时称为选排列. (一个)组合: 从 nnn 个不同元素中取出 mmm 个元素作为一组. (不强调顺序) 组合数: 从 nnn 个不同元素中取出 mmm 个元素的所有不同组合的个数, 用 Cnm\\text{C}_n^mCnm​ 或 (nm)\\dbinom{n}{m}(mn​) 表示. 组合数公式: Cnm=AnmAmm=n(n−1)⋯(n−m+1)m!=n!m!(n−m)!\\text{C}^m_n=\\dfrac{\\text{A}_n^m}{\\text{A}^m_m}=\\dfrac{n(n-1)\\cdots(n-m+1)}{m!}=\\dfrac{n!}{m!(n-m)!}Cnm​=Amm​Anm​​=m!n(n−1)⋯(n−m+1)​=m!(n−m)!n!​. 性质: 对称恒等 Cnk=Cnn−k\\text{C}_n^k=\\text{C}_n^{n-k}Cnk​=Cnn−k​. 组合解释: nnn 个球中取 kkk 个球 ⟺ \\iff⟺ nnn 个球中取 (n−k)(n-k)(n−k) 个球扔掉. 最大值: 当 nnn 为偶数时, Cnn2\\text{C}_{n}^{\\frac n2}Cn2n​​ 取最大值; 当 nnn 为奇数时, Cnn−12\\text{C}_{n}^{\\frac{n-1}2}Cn2n−1​​ 和 Cnn+12\\text{C}_{n}^{\\frac {n+1}2}Cn2n+1​​ 相等且取最大值. 求和恒等 Cn+1k=Cnk+Cnk−1\\text{C}_{n+1}^k=\\text{C}_n^k+\\text{C}_n^{k-1}Cn+1k​=Cnk​+Cnk−1​. 推论: 裂项 ∑k=mnCkt=Cn+1t+1−Cmt+1\\sum\\limits_{k=m}^n \\text{C}_k^t=\\text{C}_{n+1}^{t+1}-\\text{C}_m^{t+1}k=m∑n​Ckt​=Cn+1t+1​−Cmt+1​. 组合解释: (n+1)(n+1)(n+1) 个球中取 kkk 个球 ⟺ \\iff⟺ 先考虑第一个球, 若取则相当于在剩下 nnn 个球中取 kkk 个; 若不取则相当于在剩下 nnn 个球中取 (k−1)(k-1)(k−1) 个, 两种情况求和. CnkCkj=CnjCn−jk−j\\text{C}_n^k\\text{C}_k^j=\\text{C}_n^j\\text{C}_{n-j}^{k-j}Cnk​Ckj​=Cnj​Cn−jk−j​, 推论: jjj 恒等式 ∑k=1nkjCnk\\sum\\limits_{k=1}^nk^j\\text{C}_n^kk=1∑n​kjCnk​ 的值 111 kCnk=nCn−1k−1k\\text{C}_n^k=n\\text{C}_{n-1}^{k-1}kCnk​=nCn−1k−1​ n2n−1n2^{n-1}n2n−1 222 k(k−1)Cnk=n(n−1)Cn−2k−2k(k-1)\\text{C}_n^k=n(n-1)\\text{C}_{n-2}^{k-2}k(k−1)Cnk​=n(n−1)Cn−2k−2​ (#) n(n+1)2n−2n(n+1)2^{n-2}n(n+1)2n−2 333 k(k−1)(k−2)Cnk=n(n−1)(n−2)Cn−3k−3k(k-1)(k-2)\\text{C}_n^k=n(n-1)(n-2)\\text{C}_{n-3}^{k-3}k(k−1)(k−2)Cnk​=n(n−1)(n−2)Cn−3k−3​ (#) n2(n+3)2n−3n^2(n+3)2^{n-3}n2(n+3)2n−3 组合解释: nnn 个球中选 mmm 个球, mmm 个球中再选 kkk 个球 ⟺ \\iff⟺ nnn 个球中选 kkk 个球, 剩下 (n−k)(n-k)(n−k) 个球中选 (m−k)(m-k)(m−k) 个球. Cn0+Cn1+Cn2+⋯+Cnn=2n\\text{C}_n^0+\\text{C}_n^1+\\text{C}_n^2+\\cdots+\\text{C}_n^n=2^nCn0​+Cn1​+Cn2​+⋯+Cnn​=2n; Cn0−Cn1+Cn2−⋯+(−1)nCnn=0\\text{C}_n^0-\\text{C}_n^1+\\text{C}_n^2-\\cdots+(-1)^n\\text{C}_n^n=0Cn0​−Cn1​+Cn2​−⋯+(−1)nCnn​=0. 推论: Cn0+Cn2+Cn4+⋯=Cn1+Cn3+Cn5+⋯=2n−1\\text{C}_n^0+\\text{C}_n^2+\\text{C}_n^4+\\cdots=\\text{C}_n^1+\\text{C}_n^3+\\text{C}_n^5+\\cdots=2^{n-1}Cn0​+Cn2​+Cn4​+⋯=Cn1​+Cn3​+Cn5​+⋯=2n−1. 范德蒙恒等式(设下标 kkk 均使组合数有意义): ∑k=0nCakCbn−k=Ca+bn\\sum\\limits_{k=0}^n\\text{C}_a^k\\text{C}_b^{n-k}=\\text{C}_{a+b}^{n}k=0∑n​Cak​Cbn−k​=Ca+bn​. (可用于证明超几何分布概率和为 111) 组合解释: aaa 个正品, bbb 个次品, 取 nnn 个 ⟺ \\iff⟺ 取 kkk 个正品和 (n−k)(n-k)(n−k) 个次品, 对 kkk 求和. (#) ∑k=0nCkaCn−kb=Cn+1a+b+1\\sum\\limits_{k=0}^n\\text{C}_k^a\\text{C}_{n-k}^b=\\text{C}_{n+1}^{a+b+1}k=0∑n​Cka​Cn−kb​=Cn+1a+b+1​. 注: 规定当 m&gt;nm&gt;nm&gt;n 或 m&lt;0m&lt;0m&lt;0 时 Anm=Cnm=0\\text{A}^m_n=\\text{C}^m_n=0Anm​=Cnm​=0, 但高中规定其无意义. 因此可列出 n≥mn\\ge mn≥m 且 n,m∈Nn,m\\in\\Nn,m∈N 的条件，该条件可能有助于解题. 二项式定理 二项式定理: ∀n∈N∗(x+y)n=T\\displaystyle \\forall n\\in\\N^*\\quad{(x+y)}^{n}=T∀n∈N∗(x+y)n=T, 二项展开式 TTT=∑k=0nTk+1=\\sum\\limits_{k=0}^{n}{T_{k+1}}=k=0∑n​Tk+1​; 通项Tk+1T_{k+1}Tk+1​=Cnkxn−kyk=\\text{C}_n^kx^{n-k}y^k=Cnk​xn−kyk(注意上标); 二项式系数: Cnk(k=0,⋯ ,n)\\text{C}_n^k(k=0,\\cdots,n)Cnk​(k=0,⋯,n). 特别地, 若 y=1y=1y=1 则有 (1+x)n=Cn0+Cn1x+⋯+Cnnxn(1+x)^n=\\text{C}_n^0+\\text{C}_n^1x+\\cdots+\\text{C}_n^nx^n(1+x)n=Cn0​+Cn1​x+⋯+Cnn​xn. 推论: {(a+b)n+(a−b)n=2(an+Cn2an−2b2+Cn4an−4b4+⋯ )(a+b)n−(a−b)n=2(Cn1an−1b+Cn3an−3b3+Cn5an−5b5+⋯ )\\left\\{\\begin{aligned} (a+b)^n+(a-b)^n&amp;=2(a^n+\\text{C}_n^2a^{n-2}b^2+\\text{C}_n^4a^{n-4}b^4+\\cdots)\\\\ (a+b)^n-(a-b)^n&amp;=2(\\text{C}_n^1a^{n-1}b+\\text{C}_n^3a^{n-3}b^3+\\text{C}_n^5a^{n-5}b^5+\\cdots)\\\\ \\end{aligned}\\right.{(a+b)n+(a−b)n(a+b)n−(a−b)n​=2(an+Cn2​an−2b2+Cn4​an−4b4+⋯)=2(Cn1​an−1b+Cn3​an−3b3+Cn5​an−5b5+⋯)​. (#) 牛顿二项式定理: ∀α∈R(x+y)α=∑k=0∞(αk)xα−kyk\\displaystyle\\forall \\alpha\\in\\R\\quad{(x+y)}^{\\alpha}=\\sum\\limits_{k=0}^{\\infty}{\\dbinom{\\alpha}{k}x^{\\alpha-k}y^k}∀α∈R(x+y)α=k=0∑∞​(kα​)xα−kyk, 其中 (αk)=α(α−1)⋯(α−k+1)k!\\dbinom{\\alpha}{k}=\\dfrac{\\alpha(\\alpha-1)\\cdots(\\alpha-k+1)}{k!}(kα​)=k!α(α−1)⋯(α−k+1)​, 规定 (α0)=1\\dbinom{\\alpha}{0}=1(0α​)=1. (#) 多项式定理: 定义 (nn1 n2 ⋯ nk)=n!n1!n2!⋯nk!\\displaystyle\\binom{n}{n_1\\ n_2\\ \\cdots\\ n_k}=\\frac{n!}{n_1!n_2!\\cdots n_k!}(n1​ n2​ ⋯ nk​n​)=n1​!n2​!⋯nk​!n!​ , 则 ∀n∈N∗(∑t=1kxt)n=∑n1+⋯+nk=n((nn1 ⋯ nk)∏t=1kxtnt)=n!∑n1+⋯+nk=n∏t=1kxtntnt!\\displaystyle\\forall n\\in\\N^*\\quad\\left(\\sum\\limits_{t=1}^kx_t\\right)^n=\\sum\\limits_{n_1+\\cdots+n_k=n}\\left(\\binom{n}{n_1\\ \\cdots\\ n_k}\\prod\\limits_{t=1}^kx_t^{n_t}\\right)=n!\\sum\\limits_{n_1+\\cdots+n_k=n}\\prod\\limits_{t=1}^k\\dfrac{x_t^{n_t}}{n_t!}∀n∈N∗(t=1∑k​xt​)n=n1​+⋯+nk​=n∑​((n1​ ⋯ nk​n​)t=1∏k​xtnt​​)=n!n1​+⋯+nk​=n∑​t=1∏k​nt​!xtnt​​​. 注: x,y\\textit{x,y}x,y 中还可以取复数或多项式. 杨辉三角 第 nnn 行第 mmm 个数字为 Cn−1m−1\\text{C}_{n-1}^{m-1}Cn−1m−1​; 第 nnn 行数字之和为 2n−12^{n-1}2n−1. 一些组合数性质可以应用到杨辉三角中. 课本知识挖掘 单循环赛: 每两个队伍之间进行一场比赛. 双循环赛: 每两个队伍之间进行两场比赛, 主客场各一次. 若有 nnn 个队伍, 则一共进行 n(n−1)2\\dfrac{n(n-1)}{2}2n(n−1)​ 场单循环赛, n(n−1)n(n-1)n(n−1) 场双循环赛. nnn 元集合的不同子集有 2n2^n2n 个. (2n)!=(1)(3)(5)⋯(2n−1)⋅2n⋅n!(2n)!=(1)(3)(5)\\cdots(2n-1)\\cdot 2^n\\cdot n!(2n)!=(1)(3)(5)⋯(2n−1)⋅2n⋅n!. 若第 k1k_1k1​ 项和第 k2k_2k2​ 项的二项式系数相等, 那么有Cnk1−1=Cnk2−1\\text{C}_n^{k_1-1}=\\text{C}_n^{k_2-1}Cnk1​−1​=Cnk2​−1​, 即 n=k1+k2−2n=k_1+k_2-2n=k1​+k2​−2. 若 (a+b)n(a+b)^n(a+b)n 的第 (k−1),k,(k+1)(k-1),k,(k+1)(k−1),k,(k+1) 项的二项式系数成等差数列, 只需找到两个连续整数 p,qp,qp,q 满足 pq=2kpq=2kpq=2k, 则 n=p2−2n=p^2-2n=p2−2 或 q2−2q^2-2q2−2. (#) ∑k=0nAnk=[n!e]\\sum\\limits_{k=0}^n\\text{A}^k_n=[n!e]k=0∑n​Ank​=[n!e]. 应试技巧 等比二项式求和可考虑先用等比数列求和公式求和后再考虑系数. 解含组合数的方程时勿忘 Cnm=Cnn−m\\text C^m_n=\\text C^{n-m}_nCnm​=Cnn−m​ 会导致多解. 排列组合计数: 数字排列注意不能有前导 000. 特殊位置优先确定. 善用分类讨论, 如果不太好算可以分多几类. 分组是组合问题, 分配是排列问题. 要求相邻考虑捆绑法; 要求隔离考虑插入法(插入需要被隔离的物体). 缩倍法: 地位均等时根据对称性将结果乘上倍数; 规定顺序时根据对称性将结果除以系数. 正难则反: 多个条件互相约束时考虑利用容斥原理转换问题. A∩B=S−A‾−B‾+A‾∪B‾A\\cap B=S-\\overline A-\\overline B+\\overline A\\cup\\overline B A∩B=S−A−B+A∪B 要求固定顺序可以使用缩倍法或插入法. 同元素分配考虑插板法. 遇到单圈先剪成链状后建立递推式, 即利用马尔科夫链处理, 再求解通项. 一些模型: 可重复排列: nnn 个元素中取 mmm 个元素(允许重复取出)按顺序排成一列, 方案数 nmn^mnm. 不全相异元素全排列 (Mississippi\\text{Mississippi}Mississippi 公式): n=∑k=1nnkn=\\sum\\limits_{k=1}^nn_kn=k=1∑n​nk​ 个元素中分别有 n1,n2,⋯ ,nkn_1,n_2,\\cdots,n_kn1​,n2​,⋯,nk​ 个元素相同, 则这 nnn 个元素的全排列数为 Cn1+⋯+nkn1Cn2+⋯+nkn2⋯Cnknk=(nn1 n2 ⋯ nk)\\text{C}_{n_1+\\cdots+n_k}^{n_1}\\text{C}_{n_2+\\cdots+n_k}^{n_2}\\cdots \\text{C}_{n_k}^{n_k}=\\displaystyle\\binom{n}{n_1\\ n_2\\ \\cdots\\ n_k}Cn1​+⋯+nk​n1​​Cn2​+⋯+nk​n2​​⋯Cnk​nk​​=(n1​ n2​ ⋯ nk​n​). 插板法: nnn 个相同的球装入 mmm 个盒中, 每个盒中至少有 kkk 个球, 方案数 Cn−mk+m−1m−1\\text{C}_{n-mk+m-1}^{m-1}Cn−mk+m−1m−1​. 圆排列: nnn 个不同的元素不分首尾排成一圈, 方案数 (n−1)!(n-1)!(n−1)!. 项链数: n(n≥3)n(n\\ge3)n(n≥3) 粒不同的珠子串成项链, 方案数 12(n−1)!\\dfrac12(n-1)!21​(n−1)!. 环染色: n(n≥2)n(n\\ge2)n(n≥2) 元环染 kkk 种色, 相邻格子不同色, 方案数 (k−1)n+(−1)n(k−1){(k-1)}^n+{(-1)}^n(k-1)(k−1)n+(−1)n(k−1). 错排问题: nnn 个球打乱后每个球不在原位, 方案数 (#) Dn=n!∑k=0n(−1)kk!=[n!e]D_n=n!\\sum\\limits_{k=0}^n\\dfrac{{(-1)}^k}{k!}=\\left[\\dfrac{n!}{e}\\right]Dn​=n!k=0∑n​k!(−1)k​=[en!​]. nnn 0 1 2 3 4 5 6 DnD_nDn​ 1 0 1 2 9 44 265 若 (x+a)n=∑k=0nakxk{(x+a)}^{n}=\\sum\\limits_{k=0}^{n}{a_kx^k}(x+a)n=k=0∑n​ak​xk. 常见考法： 注意问某一项的系数还是二项式系数. 代入 x=px=px=p 可得 a0+a1p+⋯+anpna_0+a_1p+\\cdots+a_np^na0​+a1​p+⋯+an​pn. 代入 x=1x=1x=1 可得各项系数和 a0+a1+⋯+ana_0+a_1+\\cdots+a_na0​+a1​+⋯+an​. 代入 x=−1x=-1x=−1 可得 a0−a1+⋯+(−1)nana_0-a_1+\\cdots+{(-1)}^na_na0​−a1​+⋯+(−1)nan​. 将结果同除 pnp^npn 可得 a0pn+a1pn−1+⋯+an\\dfrac{a_0}{p^n}+\\dfrac{a_1}{p^{n-1}}+\\cdots+a_npna0​​+pn−1a1​​+⋯+an​. 在 (x+∣a∣)n{(x+|a|)}^n(x+∣a∣)n 中代入 x=1x=1x=1 可得 ∣a0∣+∣a1∣+⋯+∣an∣|a_0|+|a_1|+\\cdots+|a_n|∣a0​∣+∣a1​∣+⋯+∣an​∣. 奇偶项之和: 若 A=a0+a1+⋯+an,B=a0−a1+⋯+(−1)nanA=a_0+a_1+\\cdots+a_n,B=a_0-a_1+\\cdots+{(-1)}^na_nA=a0​+a1​+⋯+an​,B=a0​−a1​+⋯+(−1)nan​, 则 a1+a3+a5+⋯=12(A−B),a0+a2+a4+⋯=12(A+B)a_1+a_3+a_5+\\cdots=\\dfrac{1}{2}(A-B),a_0+a_2+a_4+\\cdots=\\dfrac{1}{2}(A+B)a1​+a3​+a5​+⋯=21​(A−B),a0​+a2​+a4​+⋯=21​(A+B). a1+2a2+⋯+nana_1+2a_2+\\cdots+na_na1​+2a2​+⋯+nan​: 式子两边分别求导后代入 x=1x=1x=1 即得. 所求式可能缺项, 如需要求 a1+a2+⋯+ana_1+a_2+\\cdots+a_na1​+a2​+⋯+an​ 时要将 a0a_0a0​ 减去. (#) 代入 nnn 次单位根再求和可得隔 nnn 项之和. ","link":"https://zihim.me/post/WzBM6v5Ch/"},{"title":"[笔记] 7-复数","content":"这是高中数学知识点汇总系列的第七篇. 定义 虚数单位 i\\mathrm ii: 满足 i2=−1{\\mathrm i}^2=-1i2=−1 的数. 几何上, 建立直角坐标系表示复数. 复平面 / 高斯平面: 复数所在该平面. 实轴: x 轴; 虚轴: y 轴. 复数 z=a+bi↔复平面上的点 Z(a,b)↔平面向量 OZ→复数\\ z=a+b\\text i\\leftrightarrow复平面上的点\\ Z(a,b)\\leftrightarrow平面向量\\ \\overrightarrow{OZ} 复数 z=a+bi↔复平面上的点 Z(a,b)↔平面向量 OZ 复数的表示形式: 代数表示式(代数形式): z=a+bi(a,b∈R)z=a+b\\text i\\quad(a,b\\in\\R)z=a+bi(a,b∈R). 三角表示式(三角形式): z=r(cos⁡θ+isin⁡θ)(r≥0,θ∈R)z=r(\\cos\\theta+\\text i\\sin\\theta)\\quad(r\\ge0,\\theta\\in\\R)z=r(cosθ+isinθ)(r≥0,θ∈R). (极坐标思想) 指数表示式(指数形式): z=reiθ(r≥0,θ∈R)z=re^{\\text i\\theta}\\quad(r\\ge0,\\theta\\in\\R)z=reiθ(r≥0,θ∈R). 其中实部 Re(z)\\mathrm{Re}(z)Re(z)=a=rcos⁡θ=a=r\\cos\\theta=a=rcosθ; 虚部 Im(z)\\mathrm{Im}(z)Im(z)=b=rsin⁡θ=b=r\\sin\\theta=b=rsinθ; 模 / 绝对值 ∣z∣|z|∣z∣=r=∣OZ→∣=∣a+bi∣=a2+b2=r=|\\overrightarrow{OZ}|=|a+b\\text i|=\\sqrt{a^2+b^2}=r=∣OZ∣=∣a+bi∣=a2+b2​; 辐角 θ=Argz\\theta=\\text{Arg}zθ=Argz: 以 x 轴的非负半轴为始边, OZ→\\overrightarrow{OZ}OZ 所在射线为终边的角, tan⁡θ=ba\\tan\\theta=\\dfrac{b}{a}tanθ=ab​; 辐角主值 argz\\text{arg}zargz: 满足 θ∈[0,2π)\\theta\\in[0,2\\pi)θ∈[0,2π) 的辐角. 注: z=0 ⟺ OZ→=0z=0\\iff\\overrightarrow{OZ}=\\bold{0}z=0⟺OZ=0, 即 000 的辐角是任意的. 基础知识 相等判断: a+bi=c+di ⟺ a=c,b=d ⟺ ∣a+bi∣=∣c+di∣,arg(a+bi)=arg(c+di)a+b\\text i=c+d\\text i\\iff a=c,b=d\\iff |a+b\\text i|=|c+d\\text i|,\\text{arg}(a+b\\text i)=\\text{arg}(c+d\\text i) a+bi=c+di⟺a=c,b=d⟺∣a+bi∣=∣c+di∣,arg(a+bi)=arg(c+di) 数集分类: 复数C={a+bi∣a,b∈R}{实数R(b=0){{有理数Q{整数Z{{奇数偶数{自然数N{正整数N+或N∗0负整数分数无理数{正数R+0负数R−虚数I(b=0){纯虚数(a=0,b=0)⋯复数\\mathbb C=\\{a+b\\text i|a,b\\in\\R\\} \\left\\{\\begin{aligned} &amp;实数\\R(b=0) \\left\\{\\begin{aligned} &amp; \\left\\{\\begin{aligned} &amp;有理数\\mathbb Q \\left\\{\\begin{aligned} &amp;整数\\Z \\left\\{\\begin{aligned} &amp; \\left\\{\\begin{aligned} &amp;奇数\\\\ &amp;偶数\\\\ \\end{aligned}\\right.\\\\ &amp; \\left\\{\\begin{aligned} &amp;自然数\\N \\left\\{\\begin{aligned} &amp;正整数\\N_+ 或 \\N^*\\\\ &amp;0\\\\ \\end{aligned}\\right.\\\\ &amp;负整数\\\\ \\end{aligned}\\right.\\\\ \\end{aligned}\\right.\\\\ &amp;分数\\\\ \\end{aligned}\\right.\\\\ &amp;无理数\\\\ \\end{aligned}\\right.\\\\ &amp; \\left\\{\\begin{aligned} &amp;正数\\R_+\\\\ &amp;0\\\\ &amp;负数\\R_-\\\\ \\end{aligned}\\right.\\\\ \\end{aligned}\\right.\\\\ &amp;虚数\\mathbb I(b\\not=0) \\left\\{\\begin{aligned} &amp;纯虚数(a=0,b\\not=0)\\\\ &amp;\\cdots\\\\ \\end{aligned}\\right.\\\\ \\end{aligned}\\right. 复数C={a+bi∣a,b∈R}⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​​实数R(b=0)⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​​⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​​有理数Q⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​​整数Z⎩⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎧​​{​奇数偶数​⎩⎪⎪⎨⎪⎪⎧​​自然数N{​正整数N+​或N∗0​负整数​​分数​无理数​⎩⎪⎨⎪⎧​​正数R+​0负数R−​​​虚数I(b​=0){​纯虚数(a=0,b​=0)⋯​​ 注: 实数又称小数; 有理数由有限小数和无限循环小数组成; 无理数又称无限不循环小数. 注: 单数是大于零的奇数; 双数是大于零的偶数. {in}\\{\\text i^n\\}{in} 的最小正周期为 4. 四则运算与运算律 加减法 (a+bi)±(c+di)=(a±c)+(b±d)i(a+b\\text i)\\pm(c+d\\text i)=(a\\pm c)+(b\\pm d)\\text i(a+bi)±(c+di)=(a±c)+(b±d)i. (几何意义: 平面向量加减法) 加法交换律 z1+z2=z2+z1z_1+z_2=z_2+z_1z1​+z2​=z2​+z1​, 加法结合律 (z1+z2)+z3=z1+(z2+z3)(z_1+z_2)+z_3=z_1+(z_2+z_3)(z1​+z2​)+z3​=z1​+(z2​+z3​). 乘法 (a+bi)(c+di)=(ac−bd)+(ad+bc)i(a+b\\text i)(c+d\\text i)=(ac-bd)+(ad+bc)\\text i(a+bi)(c+di)=(ac−bd)+(ad+bc)i; (r1eiθ1)(r2eiθ2)=(r1r2)ei(θ1+θ2)\\left(r_1e^{\\text i\\theta_1}\\right)\\left(r_2e^{\\text i\\theta_2}\\right)=(r_1r_2)e^{\\text i(\\theta_1+\\theta_2)}(r1​eiθ1​)(r2​eiθ2​)=(r1​r2​)ei(θ1​+θ2​). 交换律 z1z2=z2z1z_1z_2=z_2z_1z1​z2​=z2​z1​; 结合律 (z1z2)z3=z1(z2z3)(z_1z_2)z_3=z_1(z_2z_3)(z1​z2​)z3​=z1​(z2​z3​); 分配律 z1(z2+z3)=z1z2+z1z3z_1(z_2+z_3)=z_1z_2+z_1z_3z1​(z2​+z3​)=z1​z2​+z1​z3​. 除法 a+bic+di=(a+bi)(c−di)(c+di)(c−di)=ac+bdc2+d2+bc−adc2+d2i(c+di=0)\\dfrac{a+b\\text i}{c+d\\text i}=\\dfrac{(a+b\\text i)(c-d\\text i)}{(c+d\\text i)(c-d\\text i)}=\\dfrac{ac+bd}{c^2+d^2}+\\dfrac{bc-ad}{c^2+d^2}\\text i\\quad(c+d\\text i\\not=0)c+dia+bi​=(c+di)(c−di)(a+bi)(c−di)​=c2+d2ac+bd​+c2+d2bc−ad​i(c+di​=0); r1eiθ1r2eiθ2=r1r2ei(θ1−θ2)(r2eiθ2=0)\\dfrac{r_1e^{\\text i\\theta_1}}{r_2e^{\\text i\\theta_2}}=\\dfrac{r_1}{r_2}e^{\\text i(\\theta_1-\\theta_2)}\\quad(r_2e^{\\text i\\theta_2}\\not=0)r2​eiθ2​r1​eiθ1​​=r2​r1​​ei(θ1​−θ2​)(r2​eiθ2​​=0). 乘除法口诀: 模相乘除, 辐角相加减; 乘除法几何意义: 复平面中构造相似三角形. 共轭复数及其性质 共轭复数 z‾\\overline zz: 实部相等, 虚部互为相反数. (几何意义: 关于实轴对称) 若 z=a+bi=r(cos⁡θ+isin⁡θ)=reiθz=a+b\\text i=r(\\cos\\theta+\\text i\\sin\\theta)=re^{\\text i\\theta}z=a+bi=r(cosθ+isinθ)=reiθ 则 z‾=a−bi=r(cos⁡θ−isin⁡θ)=re−iθ\\overline z=a-b\\text i=r(\\cos\\theta-\\text i\\sin\\theta)=re^{-\\text i\\theta}z=a−bi=r(cosθ−isinθ)=re−iθ. 性质: z1±z2‾=z1‾±z2‾\\overline{z_1\\pm z_2}=\\overline{z_1}\\pm\\overline{z_2}z1​±z2​​=z1​​±z2​​. z1z2‾=z1‾⋅z2‾⇒zn‾=z‾n\\overline{z_1z_2}=\\overline{z_1}\\cdot\\overline{z_2}\\Rightarrow \\overline{z^n}={\\overline z}^nz1​z2​​=z1​​⋅z2​​⇒zn=zn; (z1z2)‾=z1‾z2‾(z2=0)\\overline{\\left(\\dfrac{z_1}{z_2}\\right)}=\\dfrac{\\overline{z_1}}{\\overline{z_2}}\\quad(z_2\\not=0)(z2​z1​​)​=z2​​z1​​​(z2​​=0). z‾‾=z\\overline{\\overline z}=zz=z. z为实数 ⟺ z‾=zz为实数\\iff\\overline z=zz为实数⟺z=z; z为纯虚数 ⟺ z‾=−z且z=0z为纯虚数\\iff\\overline z=-z且z\\not=0z为纯虚数⟺z=−z且z​=0. 模的性质 ∣z1z2∣=∣z1∣∣z2∣⇒∣zn∣=∣z∣n|z_1z_2|=|z_1||z_2|\\Rightarrow|z^n|={|z|}^n∣z1​z2​∣=∣z1​∣∣z2​∣⇒∣zn∣=∣z∣n(本质: 拉格朗日恒等式); ∣z1z2∣=∣z1∣∣z2∣(z2=0)\\left|\\dfrac{z_1}{z_2}\\right|=\\dfrac{|z_1|}{|z_2|}\\quad(z_2\\not=0)∣∣∣∣​z2​z1​​∣∣∣∣​=∣z2​∣∣z1​∣​(z2​​=0). ∣z∣=∣z‾∣|z|=|\\overline z|∣z∣=∣z∣. zz‾=∣z∣2z\\overline z=|z|^2zz=∣z∣2(本质: 平方差公式; 几何意义: 子母型相似), 推论: 1z=z‾∣z∣2\\dfrac{1}{z}=\\dfrac{\\overline z}{|z|^2}z1​=∣z∣2z​. (分母实数化) 斜边大于直角边: ∣z∣≥∣Re(z)∣|z|\\ge|\\text{Re}(z)|∣z∣≥∣Re(z)∣, ∣z∣≥∣Im(z)∣|z|\\ge|\\text{Im}(z)|∣z∣≥∣Im(z)∣. 三角形不等式: ∣∣z1∣−∣z2∣∣≤∣z1+z2∣≤∣z1∣+∣z2∣||z_1|-|z_2||\\le|z_1+z_2|\\le|z_1|+|z_2|∣∣z1​∣−∣z2​∣∣≤∣z1​+z2​∣≤∣z1​∣+∣z2​∣. 辐角的性质 Arg(z1z2)=Argz1+Argz2⇒Argzn=nArgz\\text{Arg}(z_1z_2)=\\text{Arg}z_1+\\text{Arg}z_2\\Rightarrow\\text{Arg}z^n=n\\text{Arg}zArg(z1​z2​)=Argz1​+Argz2​⇒Argzn=nArgz. Argz1z2=Argz1−Argz2\\text{Arg}\\dfrac{z_1}{z_2}=\\text{Arg}z_1-\\text{Arg}z_2Argz2​z1​​=Argz1​−Argz2​. Argz‾=−Argz\\text{Arg}\\overline z=-\\text{Arg}zArgz=−Argz. 欧拉公式 欧拉公式: eiθ=cos⁡θ+isin⁡θe^{\\text i\\theta}=\\cos\\theta+\\text i\\sin\\thetaeiθ=cosθ+isinθ. 棣莫弗公式: (cos⁡θ+isin⁡θ)n=cos⁡(nθ)+isin⁡(nθ){\\left(\\cos\\theta+\\text i\\sin\\theta\\right)}^n=\\cos{(n\\theta)}+\\text i\\sin{(n\\theta)}(cosθ+isinθ)n=cos(nθ)+isin(nθ). (配合二项式定理可推导 nnn 倍角公式) 1 的 nnn 次方根 1n\\sqrt[n]{1}n1​ 为 ωk=cos⁡2kπn+isin⁡2kπn(k∈{0,1,⋯ ,n−1})\\omega_k=\\cos\\dfrac{2k\\pi}{n}+\\text i\\sin\\dfrac{2k\\pi}{n}\\quad(k\\in\\{0,1,\\cdots,n-1\\})ωk​=cosn2kπ​+isinn2kπ​(k∈{0,1,⋯,n−1}) 共 nnn 个. n=3n=3n=3 时 ω0=1,ω1=−1+3i2,ω2=−1−3i2\\omega_0=1,\\omega_1=\\dfrac{-1+\\sqrt{3}\\text i}{2},\\omega_2=\\dfrac{-1-\\sqrt{3}\\text i}{2}ω0​=1,ω1​=2−1+3​i​,ω2​=2−1−3​i​. 几何意义: 单位圆的 nnn 等分点, 且其中必有 (1,0)(1,0)(1,0). 性质 ∀k∈{0,1,⋯ ,n−1}\\forall k\\in\\{0,1,\\cdots,n-1\\}∀k∈{0,1,⋯,n−1}: ωkn=1,∣ωk∣=1\\omega_k^n=1,|\\omega_k|=1ωkn​=1,∣ωk​∣=1. ∑t=0n−1ωkt=0\\sum\\limits_{t=0}^{n-1}\\omega_k^t=0t=0∑n−1​ωkt​=0. ωk\\omega_kωk​ 与 ωn−k\\omega_{n-k}ωn−k​ 互为共轭复数. 应试技巧 复数问题通法：实数化，设未知数为 a+bi (a,b∈R)a+b\\text i\\ (a,b\\in\\R)a+bi (a,b∈R) 或 r(cos⁡θ+isin⁡θ) (r≥0,θ∈R)r(\\cos\\theta+\\text i\\sin\\theta)\\ (r\\ge0,\\theta\\in\\R)r(cosθ+isinθ) (r≥0,θ∈R). 常用速算(可用复数的三角形式辅助记忆): 式子 1±i\\dfrac{1}{\\pm\\text i}±i1​ 1±i1∓i\\dfrac{1\\pm\\text i}{1\\mp\\text i}1∓i1±i​ 2i1±i\\dfrac{2\\text i}{1\\pm\\text i}1±i2i​ 21±i\\dfrac{2}{1\\pm\\text i}1±i2​ 结果 ∓i\\mp\\text i∓i ±i\\pm\\text i±i 1±i1\\pm\\text i1±i 1∓i1\\mp\\text i1∓i 不要求结果为代数形式时, 也可用三角形式表示, 但注意三角形式的条件. 一些公式: (a+bi)(a−bi)=a2+b2(a+b\\text i)(a-b\\text i)=a^2+b^2(a+bi)(a−bi)=a2+b2. (a+bi)(b+ai)=(a2+b2)i(a+b\\text i)(b+a\\text i)=(a^2+b^2)\\text i(a+bi)(b+ai)=(a2+b2)i. (a±bi)2=(a2−b2)±2abi(a\\pm b\\text i)^2=(a^2-b^2)\\pm 2ab\\text i(a±bi)2=(a2−b2)±2abi. 1cos⁡θ+isin⁡θ=cos⁡θ−isin⁡θ\\dfrac{1}{\\cos\\theta+\\text i\\sin\\theta}=\\cos\\theta-\\text i\\sin\\thetacosθ+isinθ1​=cosθ−isinθ. ","link":"https://zihim.me/post/8oTiqY7sf/"},{"title":"[随笔] 《吟游诗人的重生》游戏体验","content":"前几天逛 matrix67 的博客，发现居然有几个小游戏可以玩，里面有一个现代汉语文字解谜游戏《吟游诗人的重生》非常好玩，玩了一整天终于通关了。（欲体验请点击游戏名） 本以为是个探险游戏，但其实只是有八个关卡： 前往神殿的东厅，获取娄子之书。 前往神殿的西厅，获取士周之书。 前往神殿的前廊，获取毛田之书。 前往神殿的后院，获取告司之书。 前往神殿的配房，获取口双之书。 前往神殿的内室，获取沽月之书。 前往神殿的阁楼，获取甲仁之书。 前往神殿的地窖，获取申且之书。 解谜者可以随意选择关卡，每个关卡的通过需要正确回答十道两个选项的题，但其中没有题目只有选项，解谜者需要通过多次尝试找到答案的规律从而通关。 作者设置两个选项估计是因为比较方便，十道题是为了减少全部蒙对的概率（也就是 11024=0.09765625%\\dfrac{1}{1024}=0.09765625\\%10241​=0.09765625%）。 注意：接下来的部分具有剧透游戏内容的成分（包括但不限于游戏攻略），请谨慎观看！ 游戏中说到书的名字残缺，在完成关卡后会显示原书名。 事实上，残缺书名就是原书名抹掉部分笔画得到的（说来可笑，这一点在我通关了六个关卡后才意识到）： 前往神殿的东厅，获取数字之书。 前往神殿的西厅，获取声调之书。 前往神殿的前廊，获取笔画之书。 前往神殿的后院，获取造词之书。 前往神殿的配房，获取后缀之书。 前往神殿的内室，获取活用之书。 前往神殿的阁楼，获取单位之书。 前往神殿的地窖，获取重复之书。 原书名实际上是对该关卡的一个描述，因此会对关卡的解决有一定的帮助。游戏中有这么一段话： 「获得六本文辞之书后，便能得到断字金睛。 集齐所有的文辞之书后，便能得到遣词造句之力。」 实际上就是说：通关六个关卡后，会显示剩下两个关卡的原书名。全部通关后，游戏就结束了。 以下是各个关卡的谜底以及我在解谜时的一些历程（我是按着顺序解谜的）： 数字之书：不断追逐含有数字的词，方可得到本书。 这个还是比较简单的，尝试了几遍之后就会发现每次总会有一个选项带有数字（这个还是可以比较容易注意到的，因为含数字的词语似乎并不是很多），然后一直选带数字的词语就可以了。 声调之书：不断追逐四声齐全的词，方可得到本书。 解谜时发现，每个选项都是一个四字词，由于是要寻找有一定性质的词语，稍加思索可以知道一个词语的性质有声调、笔画、词性以及字形上的一些共性。再加上我解谜时会在心里将这个词念出来。想到声调后解决这个关卡就很容易了。 笔画之书：不断追逐总笔画数为六的词，方可得到本书。 想了有相当一段时间，后来尝试了笔画就解出来了。我在完成关卡之前还以为是选笔画总数为偶数的词，没想到谜底要更苛刻一些，实属是误打误撞了（笑）。 造词之书：不断追逐两字呈并列关系的词，方可得到本书。 这是我花了最久的一个关卡，在我打算写这篇文章时忘记了我这关是怎么通过的，我甚至记录了快有 20 个符合和不符合的选项后被「矛盾」一词点醒，但是我以为是选反义词（比如说矛和盾是相反的），后面又包含了近义词，总算是通关了，整个过程非常的不容易。 后缀之书：不断追逐可以儿化的词，方可得到本书。 这个也非常的难，我也记录了许多选项为了找出规律。但是完全没思路，因为上面的思路（词语的特性）已经用完了，以至于我去网上找攻略，根本找不到（这也促就了这篇文章的诞生），但是我找到游戏下的评论说根据这个游戏可以推测作者肯定是北京人，那就很容易可以推测到北京人特有的文化特点就是“儿化音”，尝试了一下果然就搞出来了（虽然中间有几次栽坑里了）。 活用之书：不断追逐能活用为动词的词，方可得到本书。 这个不是很艰难，根据词性可以知道选动词（因为我认为肯定会有一道关卡会考词性，前几关也在尝试这个方向，试到这关终于成了）。 单位之书：不断追逐量词为「条」的词，方可得到本书。 到了这里，剩下两本书的书名就还原了，因此难度减少了不少。这里的单位我想大概是指量词，尝试了一会就解出来了，但是我以为是选“不能用「个」作为量词”，结果整个过程还挺流畅的，没有感到一丝异样（可能是小时候量词没学好）。 重复之书：不断追逐能按「甲甲乙乙」的方式重叠使用的词，方可得到本书。 有了原名就太简单了，很显然根据书名就是选择能改造成叠词的词语。 游戏还是非常有意思的，就是描述得有一点点中二，我有几个 idea 也没有出现在关卡中（比如说“哪个选项含有「口」”，甚至说更难一点，采取“哪个选项含有的「口」比较多”可以避免记录每个答案的暴力解法，因为正确答依照选项而定），但是作为一个小游戏来说是真的很有意思，可以在不断的探索中得到乐趣，非常推荐大家来玩！ 一股由形形色色的符号会聚而成的无形力量涌进你的全身。 你重新拾起了遣词造句之力。 古老的砖石在耀眼的阳光下反射出并不夺目的光泽。 四周是一片荒漠，零星的杂草展现出极强的生命力。 你感到文思泉涌。 三年前和恶魔的交易， 酒浆也无法掩盖的孤独， 以及惊心动魄的神殿之旅， 将会被你的追随者们不断传诵。 ","link":"https://zihim.me/post/EA1Q8gJJ9/"},{"title":"[研究] 泳裤、信封和出人意料的 e","content":"六年级时，我曾在《数字——破解万物的钥匙》中看到了这么一个有趣的事实： 一群小伙子去游泳池游泳，他们的泳裤在同一个箱子里。当他们进入更衣室时，房间停电了。于是他们每个人随手抓了一件泳裤穿在身上，那么他们全部穿错自己的泳裤的概率是 1e\\dfrac1ee1​，即 36.79%36.79\\%36.79% 左右。 当时年少无知，并不知道其中的原理。而且最神奇也是最令人不解的是这里面居然出现了一个 eee！ 如今高二学习了排列组合，便研究了一番，却发现这里面大有其奥妙，并且这么一个概率问题竟涉及到排列组合、数列和导数，甚至跟集合有关！ 本文假设读者理解大部分高中数学知识，那就让我们开始吧！ 从错排开始讲起 事实上，我们要从一个高中常见的组合问题讲起： 四个信封和四封信一一对应，现在将信随便装入信封内，四封信全部装错一共有几种装法？ 很显然，经过简单的分类讨论可以知道有 999 种方法。事实上，这类问题叫做「错排问题」，下面给出一般定义。 定义 错排（错位全排列）问题，又称为伯努利欧拉装错信封问题，是指如下问题： nnn 个信封和信，将信随便装入信封内，所有信全部装错信封的方案数有多少种？ 找出递推式 我们设 nnn 封信的方案数为 DnD_nDn​，那么显然 D1=0,D2=1D_1=0,D_2=1D1​=0,D2​=1。 上面我们已经知道 D4=9D_4=9D4​=9。但是，如果有更多的信封，问题的难度会大幅上升，单靠分类讨论难以解决，因此我们需要一些更高级的做法，而建立递推式便是一个好方法，在这里我们就用这个方法。 那我们如何找到 DnD_nDn​ 的递推式呢，我们可以这样想： 先考虑第一封信，它不放在自己的信封里显然有 (n−1)(n-1)(n−1) 种放法。 如果上一步第一封信放在了第 kkk 封信的信封里了，那么我们考虑第 kkk 封信的位置，又有两种情况： 它在第一封信的信封里，那么此时剩下的 (n−2)(n-2)(n−2) 封信要满足错排的性质，方案数就是 Dn−2D_{n-2}Dn−2​ 种。 它不在第一封信的信封里，此时我们假装将第一封信装进第 kkk 封信的信封并将信封扔掉，由于第 kkk 封信不在第一封信的信封里，那么此时如果我们将第一封信的信封重命名为新的第 kkk 封信的信封，事实上就是 (n−1)(n-1)(n−1) 封信的错排，有 Dn−1D_{n-1}Dn−1​ 种方案。 根据加法原理和乘法原理，我们便得到了 DnD_nDn​ 的递推式： Dn=(n−1)(Dn−1+Dn−2)(n≥2)D_n=(n-1)(D_{n-1}+D_{n-2})\\quad (n\\ge2) Dn​=(n−1)(Dn−1​+Dn−2​)(n≥2) 向通项式出发 在这里我给出百度百科找到的由递推式变形得到通项式的方法，其中涉及到了一些“天眼”（即难以想到的步骤）和常用的数列处理方法。首先，第一步，要把递推式变形成这个样子： n!Dnn!=(n−1)(n−1)!Dn−1(n−1)!+(n−1)(n−2)!Dn−2(n−2)!n!\\dfrac{D_n}{n!}=(n-1)(n-1)!\\dfrac{D_{n-1}}{(n-1)!}+(n-1)(n-2)!\\dfrac{D_{n-2}}{(n-2)!} n!n!Dn​​=(n−1)(n−1)!(n−1)!Dn−1​​+(n−1)(n−2)!(n−2)!Dn−2​​ 为什么这么变？因为这样能做出来。 实际上我也不知道为什么要这么变，这一步是最难的，我自己也没想到。实际上，我在解通项式是用的是生成函数的方法（详见下一节），期间还碰了壁。 两边可以同时约去一个 (n−1)!(n-1)!(n−1)!，并且作一些变形： nDnn!=(n−1)Dn−1(n−1)!+Dn−2(n−2)!n(Dnn!−Dn−1(n−1)!)=−Dn−1(n−1)!+Dn−2(n−2)!Dnn!−Dn−1(n−1)!=−1n(Dn−1(n−1)!−Dn−2(n−2)!)\\begin{aligned} n\\dfrac{D_n}{n!}&amp;=(n-1)\\dfrac{D_{n-1}}{(n-1)!}+\\dfrac{D_{n-2}}{(n-2)!}\\\\ n\\left(\\dfrac{D_n}{n!}-\\dfrac{D_{n-1}}{(n-1)!}\\right)&amp;=-\\dfrac{D_{n-1}}{(n-1)!}+\\dfrac{D_{n-2}}{(n-2)!}\\\\ \\dfrac{D_n}{n!}-\\dfrac{D_{n-1}}{(n-1)!}&amp;=-\\dfrac{1}{n}\\left(\\dfrac{D_{n-1}}{(n-1)!}-\\dfrac{D_{n-2}}{(n-2)!}\\right)\\\\ \\end{aligned} nn!Dn​​n(n!Dn​​−(n−1)!Dn−1​​)n!Dn​​−(n−1)!Dn−1​​​=(n−1)(n−1)!Dn−1​​+(n−2)!Dn−2​​=−(n−1)!Dn−1​​+(n−2)!Dn−2​​=−n1​((n−1)!Dn−1​​−(n−2)!Dn−2​​)​ 这里使用累乘的方法，有： Dnn!−Dn−1(n−1)!=−1n(Dn−1(n−1)!−Dn−2(n−2)!)=(−1n)(−1n−1)(Dn−2(n−2)!−Dn−3(n−3)!)=(−1n)(−1n−1)⋯(−13)(D22!−D11!)=(−1n)(−1n−1)⋯(−13)(−12)(−11)=(−1)nn!\\begin{aligned} \\dfrac{D_n}{n!}-\\dfrac{D_{n-1}}{(n-1)!}&amp;=-\\dfrac{1}{n}\\left(\\dfrac{D_{n-1}}{(n-1)!}-\\dfrac{D_{n-2}}{(n-2)!}\\right)\\\\ &amp;=\\left(-\\dfrac{1}{n}\\right)\\left(-\\dfrac{1}{n-1}\\right)\\left(\\dfrac{D_{n-2}}{(n-2)!}-\\dfrac{D_{n-3}}{(n-3)!}\\right)\\\\ &amp;=\\left(-\\dfrac{1}{n}\\right)\\left(-\\dfrac{1}{n-1}\\right)\\cdots\\left(-\\dfrac{1}{3}\\right)\\left(\\dfrac{D_2}{2!}-\\dfrac{D_1}{1!}\\right)\\\\ &amp;=\\left(-\\dfrac{1}{n}\\right)\\left(-\\dfrac{1}{n-1}\\right)\\cdots\\left(-\\dfrac{1}{3}\\right)\\left(-\\dfrac{1}{2}\\right)\\left(-\\dfrac{1}{1}\\right)\\\\ &amp;=\\dfrac{(-1)^n}{n!} \\end{aligned} n!Dn​​−(n−1)!Dn−1​​​=−n1​((n−1)!Dn−1​​−(n−2)!Dn−2​​)=(−n1​)(−n−11​)((n−2)!Dn−2​​−(n−3)!Dn−3​​)=(−n1​)(−n−11​)⋯(−31​)(2!D2​​−1!D1​​)=(−n1​)(−n−11​)⋯(−31​)(−21​)(−11​)=n!(−1)n​​ 再使用累加的方法，于是： Dnn!−D11!=(Dnn!−Dn−1(n−1)!)+(Dn−1(n−1))!−Dn−2(n−2)!)+⋯+(D22!−D11!)=(−1)nn!+(−1)n−1(n−1)!+⋯+(−1)22!\\begin{aligned} &amp;\\dfrac{D_n}{n!}-\\dfrac{D_1}{1!}\\\\ =&amp;\\left(\\dfrac{D_n}{n!}-\\dfrac{D_{n-1}}{(n-1)!}\\right)+\\left(\\dfrac{D_{n-1}}{(n-1))!}-\\dfrac{D_{n-2}}{(n-2)!}\\right)+\\cdots+\\left(\\dfrac{D_2}{2!}-\\dfrac{D_1}{1!}\\right)\\\\ =&amp;\\dfrac{(-1)^n}{n!}+\\dfrac{(-1)^{n-1}}{(n-1)!}+\\cdots+\\dfrac{(-1)^2}{2!} \\end{aligned} ==​n!Dn​​−1!D1​​(n!Dn​​−(n−1)!Dn−1​​)+((n−1))!Dn−1​​−(n−2)!Dn−2​​)+⋯+(2!D2​​−1!D1​​)n!(−1)n​+(n−1)!(−1)n−1​+⋯+2!(−1)2​​ 移项后我们便能得到错排问题的通项式了： Dn=n!∑k=2n(−1)kk!D_n=n!\\sum\\limits_{k=2}^n\\dfrac{(-1)^k}{k!} Dn​=n!k=2∑n​k!(−1)k​ 可能这个式子看着比较别扭，但是后面的求和号我们无法再精确地化简了。 当然，下标从 222 开始可能有些许怪，由于 (−1)00!+(−1)11!=0\\dfrac{(-1)^0}{0!}+\\dfrac{(-1)^1}{1!}=00!(−1)0​+1!(−1)1​=0，因此我们也可以写成： Dn=n!∑k=0n(−1)kk!D_n=n!\\sum\\limits_{k=0}^n\\dfrac{(-1)^k}{k!} Dn​=n!k=0∑n​k!(−1)k​ 如何让错排更好算 如果你将 nnn 代入通项公式，你会发现 DnD_nDn​ 算起来比较麻烦，这主要是其通项式中求和号造成的。 事实上，根据通项公式也可以得到一条比较简单的递推公式： Dn=nDn−1+(−1)nD_n=nD_{n-1}+(-1)^n Dn​=nDn−1​+(−1)n 但递推式用起来还是没有通项式那么爽，因此接下来，我将带领你利用 exe^xex 的泰勒展开式，得到错排通项公式的一个近似公式。 泰勒展开 泰勒展开就是利用求导构建一个多项式来逼近一个函数，它的优点就在于可以将复杂的函数化为多项式。用泰勒展开进行估算也是一个不错的选择。 那么具体怎么展开呢？这里有一个公式（这里我就直接写无穷和而非多项式估计了）： f(x)=∑k=0∞f(k)(a)k!(x−a)kf(x)=\\sum\\limits_{k=0}^\\infty{\\dfrac{f^{(k)}(a)}{k!}(x-a)^k} f(x)=k=0∑∞​k!f(k)(a)​(x−a)k 其中 f(k)(x)f^{(k)}(x)f(k)(x) 为 f(x)f(x)f(x) 的 kkk 阶导数（前提是要存在，否则不能展开）。 等号右边的式子就被称为 f(x)f(x)f(x) 在 x=ax=ax=a 处的泰勒展开。这个展开式会在 x=ax=ax=a 处附近比较贴合原函数，估计的效果也越好。f(x)f(x)f(x) 在 x=0x=0x=0 处的泰勒展开也称为麦克劳林展开。 这里我给出一种比较直观的观点来证明它（但是并不严谨），假设展开式是长这样的： f(x)=∑k=0∞tk(x−a)kf(x)=\\sum\\limits_{k=0}^\\infty{t_k(x-a)^k} f(x)=k=0∑∞​tk​(x−a)k 其中 {tn}\\{t_n\\}{tn​} 是待定系数。那么我们接下来反复进行以下操作： 代入 x=ax=ax=a 得到 tkt_ktk​ 的值。 两边同时求导。 不难可以发现 tk=f(k)(a)k!t_k=\\dfrac{f^{(k)}(a)}{k!}tk​=k!f(k)(a)​，其中 k!k!k! 是多次求导累积形成的。 这里我们用到的是一个带有拉格朗日余项的泰勒展开，它的严格证明要用到拉格朗日中值定理，这里就不再补充了，感兴趣的读者可以自行查阅资料： f(x)=∑k=0nf(k)(a)k!(x−a)k+Rn(x)f(x)=\\sum\\limits_{k=0}^n{\\dfrac{f^{(k)}(a)}{k!}(x-a)^k}+R_n(x) f(x)=k=0∑n​k!f(k)(a)​(x−a)k+Rn​(x) 其中 Rn(x)=f(n+1)(ξ)(n+1)!(x−a)n+1R_n(x)=\\dfrac{f^{(n+1)}(\\xi)}{(n+1)!}(x-a)^{n+1}Rn​(x)=(n+1)!f(n+1)(ξ)​(x−a)n+1 为余项，并且 ξ\\xiξ 在 xxx 与 aaa 之间。 错排公式的近似公式 熟悉泰勒展开的同学当见到错排公式时一定有着一种熟悉的感觉，那便是 exe^xex 的泰勒展开。 我们对 exe^xex 进行展开，由于 (ex)(n)=ex{(e^x)}^{(n)}=e^x(ex)(n)=ex，因此： ex=∑k=0nxkk!+eξ(n+1)!xn+1e^x=\\sum\\limits_{k=0}^n{\\dfrac{x^k}{k!}}+\\dfrac{e^\\xi}{(n+1)!}x^{n+1} ex=k=0∑n​k!xk​+(n+1)!eξ​xn+1 接下来，我们让 x=−1x=-1x=−1，就有： 1e=∑k=0n(−1)kk!+eξ(n+1)!(−1)n+1ξ∈(−1,0)\\dfrac1e=\\sum\\limits_{k=0}^n{\\dfrac{{(-1)}^k}{k!}}+\\dfrac{e^\\xi}{(n+1)!}{(-1)}^{n+1}\\quad\\xi\\in(-1,0) e1​=k=0∑n​k!(−1)k​+(n+1)!eξ​(−1)n+1ξ∈(−1,0) 两边乘上 n!n!n! 并移项取绝对值，得到： ∣n!e−Dn∣=eξn+1&lt;1n+1≤12\\left|\\dfrac{n!}{e}-D_n\\right|=\\dfrac{e^\\xi}{n+1}&lt;\\dfrac{1}{n+1}\\le\\dfrac12 ∣∣∣∣​en!​−Dn​∣∣∣∣​=n+1eξ​&lt;n+11​≤21​ 因此 n!e\\dfrac{n!}{e}en!​ 与 DnD_nDn​ 的误差不会超过 12\\dfrac1221​，也就意味着 n!e\\dfrac{n!}{e}en!​ 四舍五入的结果便是 DnD_nDn​，即： Dn=⌊n!e+12⌋D_n=\\left\\lfloor\\dfrac{n!}{e}+\\dfrac12\\right\\rfloor Dn​=⌊en!​+21​⌋ 其中，⌊x+12⌋\\left\\lfloor x+\\dfrac12\\right\\rfloor⌊x+21​⌋ 表示 xxx 四舍五入得到的结果。 回到开头 那么接下来就可以回到开头，解决开头关于泳裤的疑问了。 由于 nnn 个人各取一条泳裤是全排列问题，一共有 n!n!n! 种取法。全部拿错自己泳裤的方案数又有 DnD_nDn​ 种，那么全部拿错的概率便是： Dnn!=⌊n!e+12⌋n!≈n!en!=1e≈36.7%\\dfrac{D_n}{n!}=\\dfrac{\\left\\lfloor\\dfrac{n!}{e}+\\dfrac12\\right\\rfloor}{n!}\\approx\\dfrac{\\dfrac{n!}{e}}{n!}=\\dfrac1e\\approx36.7\\% n!Dn​​=n!⌊en!​+21​⌋​≈n!en!​​=e1​≈36.7% 补充：错排通项式的一些其它解法 这些解法是非常自然能够想到的，比上面逆天的数列处理方法好很多。 生成函数 生成函数就是一列用来展示一串数字的挂衣架。——赫伯特·维尔夫 生成函数（又称母函数）是求无穷和以及求数列通项的一个利器，我打算在此挖个坑，科普一下生成函数，因为这玩意很神奇，很好玩，还非常有用，基本可以做到指哪打哪，多难的问题都可以解决。 在我之前的文章 [研究] “复杂”的相遇问题 的文末，我提到了这么一个式子： 1+x+x2+⋯=11−x1+x+x^2+\\cdots=\\dfrac{1}{1-x} 1+x+x2+⋯=1−x1​ 等号左边事实上就是常数列 an=1a_n=1an​=1 的生成函数。我们通常可以通过递推将这么一个无穷和化为像等号右边的这个浓缩的形式。 接下来，跟着我的思路一步一步得到通项。 我们现在有 S1=0,S2=1,Sn=(n−1)(Sn−1+Sn−2)S_1=0,S_2=1,S_n=(n-1)(S_{n-1}+S_{n-2})S1​=0,S2​=1,Sn​=(n−1)(Sn−1​+Sn−2​)，假设递推式对 n=2n=2n=2 成立，那么可以设 S0=1S_0=1S0​=1，这是为了方便计算。我们构建 SnS_nSn​ 的生成函数： f(x)=∑k=0∞Skxk=S0+S1x+S2x2+S3x3+⋯f(x)=\\sum\\limits_{k=0}^\\infty S_kx^k=S_0+S_1x+S_2x^2+S_3x^3+\\cdots f(x)=k=0∑∞​Sk​xk=S0​+S1​x+S2​x2+S3​x3+⋯ 那么： xf(x)=S0x+S1x2+S2x3+S3x4+⋯(x+1)f(x)=S0+(S1+S0)x+(S2+S1)x2+(S3+S2)x3+(S4+S3)x4+((x+1)f(x))′=(S1+S0)+2(S2+S1)x+3(S3+S2)x2+4(S4+S3)x3+⋯=S2+S3x+S4x2+⋯=f(x)−S0−S1xx2\\begin{aligned} xf(x)&amp;=S_0x+S_1x^2+S_2x^3+S_3x^4+\\cdots\\\\ (x+1)f(x)&amp;=S_0+(S_1+S_0)x+(S_2+S_1)x^2+(S_3+S_2)x^3+(S_4+S_3)x^4+\\\\ ((x+1)f(x))&#x27;&amp;=(S_1+S_0)+2(S_2+S_1)x+3(S_3+S_2)x^2+4(S_4+S_3)x^3+\\cdots\\\\ &amp;=S_2+S_3x+S_4x^2+\\cdots\\\\ &amp;=\\dfrac{f(x)-S_0-S_1x}{x^2}\\\\ \\end{aligned} xf(x)(x+1)f(x)((x+1)f(x))′​=S0​x+S1​x2+S2​x3+S3​x4+⋯=S0​+(S1​+S0​)x+(S2​+S1​)x2+(S3​+S2​)x3+(S4​+S3​)x4+=(S1​+S0​)+2(S2​+S1​)x+3(S3​+S2​)x2+4(S4​+S3​)x3+⋯=S2​+S3​x+S4​x2+⋯=x2f(x)−S0​−S1​x​​ 得到关系式后，我们再变下形： ((x+1)f(x))′=f(x)−S0−S1xx2x2(x+1)f′(x)+x2f(x)=f(x)−1f′(x)+x−1x2f(x)=−1x2(x+1)\\begin{aligned} ((x+1)f(x))&#x27;&amp;=\\dfrac{f(x)-S_0-S_1x}{x^2}\\\\ x^2(x+1)f&#x27;(x)+x^2f(x)&amp;=f(x)-1\\\\ f&#x27;(x)+\\dfrac{x-1}{x^2}f(x)&amp;=-\\dfrac{1}{x^2(x+1)}\\\\ \\end{aligned} ((x+1)f(x))′x2(x+1)f′(x)+x2f(x)f′(x)+x2x−1​f(x)​=x2f(x)−S0​−S1​x​=f(x)−1=−x2(x+1)1​​ 接下来便是求一个微分方程的事。式子两边乘上待定函数 β(x)\\beta(x)β(x)，其中满足 β′(x)=x−1x2β(x)\\beta&#x27;(x)=\\dfrac{x-1}{x^2}\\beta(x)β′(x)=x2x−1​β(x)。 那么很显然 β(x)=eI\\beta(x)=e^{I}β(x)=eI，其中 I=∫x−1x2dx=ln⁡x+1xI=\\displaystyle\\int\\dfrac{x-1}{x^2}dx=\\ln x+\\dfrac{1}{x}I=∫x2x−1​dx=lnx+x1​，即 β(x)=xe1x\\beta(x)=xe^\\frac1xβ(x)=xex1​。因此： (β(x)f(x))′=−β(x)x2(x+1)(xe1xf(x))′=−e1xx(x+1)\\begin{aligned} {\\left(\\beta(x)f(x)\\right)}&#x27;&amp;=-\\dfrac{\\beta(x)}{x^2(x+1)}\\\\ {\\left(xe^\\frac{1}{x}f(x)\\right)}&#x27;&amp;=-\\dfrac{e^\\frac{1}{x}}{x(x+1)} \\end{aligned} (β(x)f(x))′(xex1​f(x))′​=−x2(x+1)β(x)​=−x(x+1)ex1​​​ 当我做到这一步时，原本下一步应该是两边积分的，但是我发现右边这玩意积不出来啊！！没办法，这条路最终以失败告终。 但是我突然想起还有个很类似的东西叫做指数型母函数。我们上面用的是普通型母函数，这两种母函数形式非常相似，但是又有区别： 形式上说，普通型生成函数用于解决多重集的组合问题，而指数型母函数用于解决多重集的排列问题。 我们这种属于排列问题，因此指数型母函数也许能做出来。我们建立 DnD_nDn​ 的指数型母函数： g(x)=∑k=0∞Skxkk!=S0+S1x+S2x22+S3x33!+⋯g(x)=\\sum\\limits_{k=0}^\\infty S_k\\dfrac{x^k}{k!}=S_0+S_1x+S_2\\dfrac{x^2}{2}+S_3\\dfrac{x^3}{3!}+\\cdots g(x)=k=0∑∞​Sk​k!xk​=S0​+S1​x+S2​2x2​+S3​3!x3​+⋯ 那么： g′(x)=S1+S2x+S3x22+S4x33!+⋯g′(x)+g(x)=(S1+S0)+(S2+S1)x+(S3+S2)x22+(S4+S3)x33!+⋯=S2+S3x2+S4x23!+S5x34!=g′(x)−S1x=g′(x)x\\begin{aligned} g&#x27;(x)&amp;=S_1+S_2x+S_3\\dfrac{x^2}{2}+S_4\\dfrac{x^3}{3!}+\\cdots\\\\ g&#x27;(x)+g(x)&amp;=(S_1+S_0)+(S_2+S_1)x+(S_3+S_2)\\dfrac{x^2}{2}+(S_4+S_3)\\dfrac{x^3}{3!}+\\cdots\\\\ &amp;=S_2+S_3\\dfrac{x}{2}+S_4\\dfrac{x^2}{3!}+S_5\\dfrac{x^3}{4!}\\\\ &amp;=\\dfrac{g&#x27;(x)-S_1}{x}=\\dfrac{g&#x27;(x)}{x} \\end{aligned} g′(x)g′(x)+g(x)​=S1​+S2​x+S3​2x2​+S4​3!x3​+⋯=(S1​+S0​)+(S2​+S1​)x+(S3​+S2​)2x2​+(S4​+S3​)3!x3​+⋯=S2​+S3​2x​+S4​3!x2​+S5​4!x3​=xg′(x)−S1​​=xg′(x)​​ 因此： g′(x)+g(x)=g′(x)x(x−1)g′(x)+xg(x)=0\\begin{aligned} g&#x27;(x)+g(x)&amp;=\\dfrac{g&#x27;(x)}{x}\\\\ (x-1)g&#x27;(x)+xg(x)&amp;=0 \\end{aligned} g′(x)+g(x)(x−1)g′(x)+xg(x)​=xg′(x)​=0​ 这个式子可顺眼太多了，炮制之前解微分方程的方法（即凑导数），我们可以得到： ((x−1)exg(x))′=0g(x)=C(x−1)ex\\begin{aligned} ((x-1)e^xg(x))&#x27;&amp;=0\\\\ g(x)&amp;=\\dfrac{C}{(x-1)e^x}\\\\ \\end{aligned} ((x−1)exg(x))′g(x)​=0=(x−1)exC​​ 其中 CCC 为积分常量。根据 g(0)=S0=1g(0)=S_0=1g(0)=S0​=1 解得 C=−1C=-1C=−1。因此 g(x)=11−x⋅e−xg(x)=\\dfrac1{1-x}\\cdot e^{-x}g(x)=1−x1​⋅e−x 还记得上面讲到 exe^xex 的泰勒展开吗，代入 −x-x−x 得到： e−x=∑k=0∞(−1)kxkk!e^{-x}=\\sum\\limits_{k=0}^\\infty{(-1)^k\\dfrac{x^k}{k!}} e−x=k=0∑∞​(−1)kk!xk​ 以及再用上面提及到的 1+x+x2+⋯=11−x1+x+x^2+\\cdots=\\dfrac{1}{1-x}1+x+x2+⋯=1−x1​，可以展开 g(x)g(x)g(x)： g(x)=(1+x+x2+x3+⋯ )(1−x+x22−x33!+⋯ )=∑k=0∞(xk∑i=0k(−1)ii!)\\begin{aligned} g(x)&amp;=(1+x+x^2+x^3+\\cdots)(1-x+\\dfrac{x^2}{2}-\\dfrac{x^3}{3!}+\\cdots)\\\\ &amp;=\\sum\\limits_{k=0}^\\infty\\left(x^k\\sum_{i=0}^k\\dfrac{(-1)^i}{i!}\\right) \\end{aligned} g(x)​=(1+x+x2+x3+⋯)(1−x+2x2​−3!x3​+⋯)=k=0∑∞​(xki=0∑k​i!(−1)i​)​ 对比每一个 xnx^nxn 的系数，可以得到： Dnn!=∑k=0n(−1)kk!Dn=n!∑k=0n(−1)kk!\\begin{aligned} \\dfrac{D_n}{n!}&amp;=\\sum\\limits_{k=0}^n\\dfrac{(-1)^k}{k!}\\\\ D_n&amp;=n!\\sum\\limits_{k=0}^n\\dfrac{(-1)^k}{k!} \\end{aligned} n!Dn​​Dn​​=k=0∑n​k!(−1)k​=n!k=0∑n​k!(−1)k​​ 容斥原理 容斥原理在我们学集合时就已经学过： ∣A∪B∣=∣A∣+∣B∣−∣A∩B∣∣A∪B∪C∣=∣A∣+∣B∣+∣C∣−∣A∩B∣−∣A∩C∣−∣B∩C∣+∣A∩B∩C∣\\begin{aligned} |A\\cup B|&amp;=|A|+|B|-|A\\cap B|\\\\ |A\\cup B\\cup C|&amp;=|A|+|B|+|C|-|A\\cap B|-|A\\cap C|-|B\\cap C|+|A\\cap B\\cap C|\\\\ \\end{aligned} ∣A∪B∣∣A∪B∪C∣​=∣A∣+∣B∣−∣A∩B∣=∣A∣+∣B∣+∣C∣−∣A∩B∣−∣A∩C∣−∣B∩C∣+∣A∩B∩C∣​ 根据这两条式子很容易可以想到它拓展到 nnn 的形式： ∣∪k=1nSk∣=∑k=1n(−1)k−1∑1≤i1&lt;⋯&lt;ik≤n∣∩j=0kSij∣\\left|\\mathop{\\Large\\cup}\\limits_{k=1}^nS_k\\right|=\\sum\\limits_{k=1}^n{(-1)}^{k-1}\\sum\\limits_{1\\le i_1&lt;\\cdots&lt;i_k\\le n}\\left|\\mathop{\\Large\\cap}\\limits_{j=0}^kS_{i_j}\\right| ∣∣∣∣​k=1∪n​Sk​∣∣∣∣​=k=1∑n​(−1)k−11≤i1​&lt;⋯&lt;ik​≤n∑​∣∣∣∣​j=0∩k​Sij​​∣∣∣∣​ 其中 ∣∪k=1nSk∣=S1∪⋯∪Sn\\left|\\mathop{\\Large\\cup}\\limits_{k=1}^nS_k\\right|=S_1\\cup\\cdots\\cup S_n∣∣∣∣​k=1∪n​Sk​∣∣∣∣​=S1​∪⋯∪Sn​，∣∩k=1nSk∣=S1∩⋯∩Sn\\left|\\mathop{\\Large\\cap}\\limits_{k=1}^nS_k\\right|=S_1\\cap\\cdots\\cap S_n∣∣∣∣​k=1∩n​Sk​∣∣∣∣​=S1​∩⋯∩Sn​。 再搭配上德 · 摩根律： ∣∩k=1nSk‾∣=∣∪k=1nSk∣‾=∣S∣−∣∪k=1nSk∣\\begin{aligned} \\left|\\mathop{\\Large\\cap}\\limits_{k=1}^n\\overline{S_k}\\right|&amp;=\\overline{\\left|\\mathop{\\Large\\cup}\\limits_{k=1}^nS_k\\right|}\\\\ &amp;=|S|-\\left|\\mathop{\\Large\\cup}\\limits_{k=1}^nS_k\\right|\\\\ \\end{aligned} ∣∣∣∣​k=1∩n​Sk​​∣∣∣∣​​=∣∣∣∣​k=1∪n​Sk​∣∣∣∣​​=∣S∣−∣∣∣∣​k=1∪n​Sk​∣∣∣∣​​ 得到这个能秒杀错排问题的公式（逐步淘汰原理）： ∣∩k=1nSk‾∣=∣S∣−∑k=1n(−1)k−1∑1≤i1&lt;⋯&lt;ik≤n∣∩j=0kSij∣\\left|\\mathop{\\Large\\cap}\\limits_{k=1}^n\\overline{S_k}\\right|=|S|-\\sum\\limits_{k=1}^n{(-1)}^{k-1}\\sum\\limits_{1\\le i_1&lt;\\cdots&lt;i_k\\le n}\\left|\\mathop{\\Large\\cap}\\limits_{j=0}^kS_{i_j}\\right| ∣∣∣∣​k=1∩n​Sk​​∣∣∣∣​=∣S∣−k=1∑n​(−1)k−11≤i1​&lt;⋯&lt;ik​≤n∑​∣∣∣∣​j=0∩k​Sij​​∣∣∣∣​ 接下来，考虑这么 nnn 个集合 SnS_nSn​，其中 ∣Sk∣|S_k|∣Sk​∣ 表示第 kkk 封信在自己信封里时，其它信封排列的方案数。那么： Dn=∣∩k=1nSk‾∣=∣S∣−∑k=1n(−1)k−1∑1≤i1&lt;⋯&lt;ik≤n∣∩j=0kSij∣=n!−∑k=1n(−1)k−1∑1≤i1&lt;⋯&lt;ik≤n(n−k)!=n!−∑k=1n(−1)k−1Cnk(n−k)!=n!−∑k=1nn!(−1)k−1k!=n!∑k=0n(−1)kk!\\begin{aligned}D_n&amp;=\\left|\\mathop{\\Large\\cap}\\limits_{k=1}^n\\overline{S_k}\\right|\\\\ &amp;=|S|-\\sum\\limits_{k=1}^n{(-1)}^{k-1}\\sum\\limits_{1\\le i_1&lt;\\cdots&lt;i_k\\le n}\\left|\\mathop{\\Large\\cap}\\limits_{j=0}^kS_{i_j}\\right|\\\\ &amp;=n!-\\sum\\limits_{k=1}^n{(-1)}^{k-1}\\sum\\limits_{1\\le i_1&lt;\\cdots&lt;i_k\\le n}(n-k)!\\\\ &amp;=n!-\\sum\\limits_{k=1}^n{(-1)}^{k-1}C_n^k(n-k)!\\\\ &amp;=n!-\\sum\\limits_{k=1}^n\\dfrac{n!{(-1)}^{k-1}}{k!}\\\\ &amp;=n!\\sum\\limits_{k=0}^n\\dfrac{{(-1)}^{k}}{k!}\\\\ \\end{aligned} Dn​​=∣∣∣∣​k=1∩n​Sk​​∣∣∣∣​=∣S∣−k=1∑n​(−1)k−11≤i1​&lt;⋯&lt;ik​≤n∑​∣∣∣∣​j=0∩k​Sij​​∣∣∣∣​=n!−k=1∑n​(−1)k−11≤i1​&lt;⋯&lt;ik​≤n∑​(n−k)!=n!−k=1∑n​(−1)k−1Cnk​(n−k)!=n!−k=1∑n​k!n!(−1)k−1​=n!k=0∑n​k!(−1)k​​ 当然了，错排公式也可以用二项式反演推得，本质上与容斥原理一样，这里就不再赘述了。 ","link":"https://zihim.me/post/GGxp-GF4z/"},{"title":"[研究] 爱の方程式","content":"说到爱的方程式，大家一定不陌生。 其中最著名的是笛卡尔的心形线 r=a(1−cos⁡θ)r=a(1-\\cos\\theta)r=a(1−cosθ) 的故事，但这个是在极坐标系下的方程。在平面直角坐标系下，心形线的方程是 x2+y2+ax=ax2+y2x^2+y^2+ax=a\\sqrt{x^2+y^2}x2+y2+ax=ax2+y2​（下图是 a=1a=1a=1 的情况）。 关于这个故事，读者可以自行了解。而本文讨论的是平面直角坐标系内的方程。 从椭圆开始 我们熟知，（焦点在 x 轴上的）椭圆的标准方程为 x2a2+y2b2=1\\dfrac{x^2}{a^2}+\\dfrac{y^2}{b^2}=1 a2x2​+b2y2​=1 那么，如果焦点不在坐标轴上，椭圆方程又是什么样子的呢？ 显然，只需要将标准椭圆旋转一定角度，再进行平移，就可以得到一切椭圆的方程了。 将椭圆平移是简单的，这里我们将问题简化，先考虑标准椭圆的旋转。 复数立大功 关于旋转，连接角度与长度的一大桥梁便是三角函数。而复数又与三角函数密切相关，这里我们处理的原理是复数乘法的几何意义——模相乘，辐角相加。 假设复平面上的点 P=x+yiP=x+y\\mathrm iP=x+yi 满足 x2a2+y2b2=1\\dfrac{x^2}{a^2}+\\dfrac{y^2}{b^2}=1a2x2​+b2y2​=1，那么将 PPP 逆时针旋转 θ\\thetaθ 后得到的 P′P&#x27;P′ 满足 P′=P(cos⁡θ+isin⁡θ)=(xcos⁡θ−ysin⁡θ)+i(xsin⁡θ+ycos⁡θ)\\begin{aligned} P&#x27;&amp;=P(\\cos\\theta+\\mathrm i\\sin\\theta)\\\\ &amp;=(x\\cos\\theta-y\\sin\\theta)+\\mathrm i(x\\sin\\theta+y\\cos\\theta) \\end{aligned} P′​=P(cosθ+isinθ)=(xcosθ−ysinθ)+i(xsinθ+ycosθ)​ 假设 P′=x′+y′iP&#x27;=x&#x27;+y&#x27;\\mathrm iP′=x′+y′i，那么就有 {x′=xcos⁡θ−ysin⁡θy′=xsin⁡θ+ycos⁡θ\\left\\{ \\begin{aligned} x&#x27;&amp;=x\\cos\\theta-y\\sin\\theta\\\\ y&#x27;&amp;=x\\sin\\theta+y\\cos\\theta \\end{aligned} \\right. {x′y′​=xcosθ−ysinθ=xsinθ+ycosθ​ 于是解得 {x=x′cos⁡θ+y′sin⁡θy=y′cos⁡θ−x′sin⁡θ\\left\\{ \\begin{aligned} x&amp;=x&#x27;\\cos\\theta+y&#x27;\\sin\\theta\\\\ y&amp;=y&#x27;\\cos\\theta-x&#x27;\\sin\\theta \\end{aligned} \\right. {xy​=x′cosθ+y′sinθ=y′cosθ−x′sinθ​ 再将其代回标准方程化简： x2a2+y2b2=1b2x2+a2y2=a2b2b2(x′cos⁡θ+y′sin⁡θ)2+a2(y′cos⁡θ−x′sin⁡θ)2=a2b2(b2cos⁡2θ+a2sin⁡2θ)x′2+(b2−a2)x′y′sin⁡2θ+(a2cos⁡2θ+b2sin⁡2θ)y′2=a2b2\\begin{aligned} \\dfrac{x^2}{a^2}+\\dfrac{y^2}{b^2}&amp;=1\\\\ b^2x^2+a^2y^2&amp;=a^2b^2\\\\ b^2(x&#x27;\\cos\\theta+y&#x27;\\sin\\theta)^2+a^2(y&#x27;\\cos\\theta-x&#x27;\\sin\\theta)^2&amp;=a^2b^2\\\\ (b^2\\cos^2\\theta+a^2\\sin^2\\theta){x&#x27;}^2+(b^2-a^2)x&#x27;y&#x27;\\sin{2\\theta}+(a^2\\cos^2\\theta+b^2\\sin^2\\theta){y&#x27;}^2&amp;=a^2b^2 \\end{aligned} a2x2​+b2y2​b2x2+a2y2b2(x′cosθ+y′sinθ)2+a2(y′cosθ−x′sinθ)2(b2cos2θ+a2sin2θ)x′2+(b2−a2)x′y′sin2θ+(a2cos2θ+b2sin2θ)y′2​=1=a2b2=a2b2=a2b2​ 于是，我们就得到了椭圆 x2a2+y2b2=1\\dfrac{x^2}{a^2}+\\dfrac{y^2}{b^2}=1a2x2​+b2y2​=1 逆时针旋转 θ\\thetaθ 后的方程： (b2cos⁡2θ+a2sin⁡2θ)x2+(b2−a2)xysin⁡2θ+(a2cos⁡2θ+b2sin⁡2θ)y2=a2b2(b^2\\cos^2\\theta+a^2\\sin^2\\theta)x^2+(b^2-a^2)xy\\sin{2\\theta}+(a^2\\cos^2\\theta+b^2\\sin^2\\theta)y^2=a^2b^2 (b2cos2θ+a2sin2θ)x2+(b2−a2)xysin2θ+(a2cos2θ+b2sin2θ)y2=a2b2 椭圆变爱心 为了计算简便，我们取 a=4,b=2,θ=π4a=4,b=2,\\theta=\\dfrac{\\pi}{4}a=4,b=2,θ=4π​，那么旋转后的方程就是 5x2−6xy+5y2=165x^2-6xy+5y^2=16 5x2−6xy+5y2=16 方程所表示的曲线长这样子： 我们观察其在 y 轴右边的部分，它非常像爱心的一半，那么我们只需要让 y 轴左边的部分和右边的部分对称，就可以得到爱心方程。 既然爱心方程关于 y 轴对称，也就是说如果 (x,y)(x,y)(x,y) 满足方程，则 (−x,y)(-x,y)(−x,y) 也满足方程。 于是我们自然而然地想到——将方程中的 xxx 全部替换为 ∣x∣|x|∣x∣，那么方程就变成了： 5x2−6∣x∣y+5y2=165x^2-6|x|y+5y^2=16 5x2−6∣x∣y+5y2=16 那我们就做完了，这是它所表示的曲线： 事实上，你可以对椭圆旋转不同的角度以得到不同的爱心方程，我这里为了方便计算只旋转了 π4\\dfrac\\pi44π​。 填充颜色 如果我们要对爱心填充颜色，那么就需要将等号改成不等号。 先考虑椭圆的标准方程 x2a2+y2b2=1\\dfrac{x^2}{a^2}+\\dfrac{y^2}{b^2}=1a2x2​+b2y2​=1，如果 (x0,y0)(x_0,y_0)(x0​,y0​) 在椭圆内，设 (x0,y1)(x_0,y_1)(x0​,y1​) 在椭圆上，显然会有 ∣y0∣&lt;∣y1∣|y_0|&lt;|y_1|∣y0​∣&lt;∣y1​∣，那么 x02a2+y02b2&lt;x02a2+y12b2=1\\dfrac{x_0^2}{a^2}+\\dfrac{y_0^2}{b^2}&lt;\\dfrac{x_0^2}{a^2}+\\dfrac{y_1^2}{b^2}=1a2x02​​+b2y02​​&lt;a2x02​​+b2y12​​=1。 也就是说，在椭圆内的点组成的区域为 x2a2+y2b2&lt;1\\dfrac{x^2}{a^2}+\\dfrac{y^2}{b^2}&lt;1a2x2​+b2y2​&lt;1。 依法炮制进行旋转，就得到旋转后椭圆内区域满足不等式 (b2cos⁡2θ+a2sin⁡2θ)x2+(b2−a2)xysin⁡2θ+(a2cos⁡2θ+b2sin⁡2θ)y2&lt;a2b2(b^2\\cos^2\\theta+a^2\\sin^2\\theta)x^2+(b^2-a^2)xy\\sin{2\\theta}+(a^2\\cos^2\\theta+b^2\\sin^2\\theta)y^2&lt;a^2b^2 (b2cos2θ+a2sin2θ)x2+(b2−a2)xysin2θ+(a2cos2θ+b2sin2θ)y2&lt;a2b2 于是我们的爱心区域满足不等式 5x2−6∣x∣y+5y2&lt;165x^2-6|x|y+5y^2&lt;16 5x2−6∣x∣y+5y2&lt;16 我心碎了 这部分原创于 Matrix67 的博客。 如果我们想要这颗心碎掉，那又该如何处理呢？ 心碎的裂缝非常像是在 y 轴上的正弦曲线 x=sin⁡yx=\\sin yx=siny。于是我们很自然地想到，只需要在不等号左边加上一个东西，这个东西在函数 x=sin⁡yx=\\sin yx=siny 附近非常大，大到可以使不等式不成立，而在爱心的其他地方的值非常小，小到几乎不影响不等式，那么就达到了我们的目的。 很显然，函数 y=k∣x∣y=\\dfrac{k}{|x|}y=∣x∣k​ 可以满足我们的需求（其中 kkk 是常数，取决于我们从哪里开始函数值发生大幅度的变化）。 当然，你也可以使用 y=kxny=\\dfrac{k}{x^n}y=xnk​，其中 nnn 为偶数，nnn 越大突变效果会更好。 哦对了，这个正弦曲线对于我们的爱心来说有点太大了，完全不像是裂缝： 我们可以减小其振幅，增大其频率，使其真正像个裂缝。为了做到这件事，我们把 yyy 改成 5y5y5y，把 xxx 改成 5x5x5x。 另外，我们在等号的一边加上一个负号，以便后续处理。由恒等式 −sin⁡θ=sin⁡(−θ)-\\sin\\theta=\\sin(-\\theta)−sinθ=sin(−θ) 可以知道，这实际上只会将曲线对称一下，形状并没有改变。将所有项移到一边以后，我们可以得到 5x+sin⁡5y=05x+\\sin5y=0 5x+sin5y=0 注意，当 ∣x∣|x|∣x∣ 越远离大时， ∣5x+sin⁡5y∣|5x+\\sin5y|∣5x+sin5y∣ 就会越大，套入我们刚刚的 k∣x∣\\dfrac{k}{|x|}∣x∣k​，再加到我们爱心方程的左边，这里我取 k=5k=5k=5，便可以得到 5x2−6∣x∣y+5y2+5∣5x+sin⁡5y∣&lt;165x^2-6|x|y+5y^2+\\dfrac{5}{|5x+\\sin5y|}&lt;16 5x2−6∣x∣y+5y2+∣5x+sin5y∣5​&lt;16 这个式子有点丑，我们移项乘分母变下形 (16+6∣x∣y−5x2−5y2)∣5x+sin⁡5y∣&gt;5(16+6|x|y-5x^2-5y^2)|5x+\\sin5y|&gt;5 (16+6∣x∣y−5x2−5y2)∣5x+sin5y∣&gt;5 这便是我们想要的。 上文提到，可以使用 y=kxny=\\dfrac{k}{x^n}y=xnk​ 作为突变的函数，这里给出一个构造的方程，个人认为更加好看，读者可以自行探究（对了，当 n&gt;4n&gt;4n&gt;4 后改变 kkk 和 nnn 的值对图像没有太大影响，因为取倒数之后实在是太大了）： (16+6∣x∣y−5x2−5y2)(5x+sin⁡5y)4&gt;1(16+6|x|y-5x^2-5y^2)(5x+\\sin5y)^4&gt;1 (16+6∣x∣y−5x2−5y2)(5x+sin5y)4&gt;1 画图软件支持：GrafEq ","link":"https://zihim.me/post/90mZ9_Rg2/"},{"title":"[随笔] 上了高中之后","content":"很显然，我失踪了很久，大概快有两年了吧。 这两年里，第一年是初三，第二年是高一。第一年是备战中考，第二年是投身竞赛。 事实上，我建立博客几乎纯粹是因为初二疫情，在家里闲着没事做。回校后，基本只有周末能回家，很少写博客，最多在学校搞搞研究（其实也很少），然后发出来（请见 用初中知识推导婆罗摩笈多公式 一文）。一上高中，我去了数学竞赛组。学业繁重，一个月回家一天，对于我这种迫切回家放松自我的人来说，不可能花时间写博客。 但是，塞翁失马焉知非福。当我上了高中，却有实实在在地感受到了自己在数学方面的进步，以下是我挤时间写的一些感悟。 回首过去 当我回看自己之前写的文章时，很多之前不能解决的问题都能迎刃而解，这大概是高中数学学习和竞赛学习带给我的吧。 高中之前，我对三角函数的认知只停留在对边比斜边 、正余弦定理和反三角函数。学了三角恒等变换后，利用公式 cos⁡(α+β)=cos⁡αcos⁡β−sin⁡αsin⁡β\\cos{(\\alpha+\\beta)}=\\cos\\alpha\\cos\\beta-\\sin\\alpha\\sin\\betacos(α+β)=cosαcosβ−sinαsinβ 和 sin⁡2α+cos⁡2α=1\\sin^2\\alpha+\\cos^2\\alpha=1sin2α+cos2α=1 很容易可以把 你能求出正方形的边长吗？ 一文中的余弦套反余弦式子化简。 进了数学竞赛组后，我对数学有了更加深刻的理解和学习。如果将 “复杂”的相遇问题 一文中最后的幂级数公式中的 ggg 换成关于 xxx 的函数 g(x)g(x)g(x)，那么 g(x)=11−xg(x)=\\dfrac{1}{1-x}g(x)=1−x1​ 就是数列 [1,1,1,1,⋯ ][1,1,1,1,\\cdots][1,1,1,1,⋯] 的母函数（生成函数）。这是一个非常强大的数列处理工具，可以用于推导数列通项或无穷级数求和。 在竞赛组里，我也学习了高斯函数（取整函数） ⌊x⌋\\lfloor x\\rfloor⌊x⌋，因此 魔术背后的 1.618 一文中我曾经不会解的奇怪方程利用高斯函数的定义可以轻松解决。那时，我趁热打铁，又研究了一下这个问题，收获颇丰，晚些再将成果补上（挖坑挖坑）。 在文章 xa+yb=z^c 的求解 中，通解也可以用中国剩余定理（孙子定理）得出，这也是我去了数学竞赛后不定方程的学习成果。有趣的是，我们教练甚至在课上出了一模一样的题目，于是我上去潇洒地在黑板写下了答案。事后，教练又抛出一个问题：方程的所有解都符合通解吗？当然教练本身也不知道答案。我回家利用 python 枚举，发现还有其他的解： 93753+6254=2505{9375}^3+{625}^4={250}^5 93753+6254=2505 还记得初中时有一次做有关燕尾定理的题目时发现了这个结论： 若AD,BF,CE三线共点，则三个红色三角形面积之积等于三个蓝色三角形面积之积。 证明是简单的，利用三角形面积公式 S=12absin⁡CS=\\dfrac{1}{2}ab\\sin{C}S=21​absinC 可以知道三个红色三角形面积之积和三个蓝色三角形面积之积均等于 18GA⋅GB⋅GC⋅GD⋅GE⋅GF⋅sin⁡αsin⁡βsin⁡γ\\dfrac18GA\\cdot GB\\cdot GC\\cdot GD\\cdot GE\\cdot GF\\cdot\\sin\\alpha\\sin\\beta\\sin\\gamma81​GA⋅GB⋅GC⋅GD⋅GE⋅GF⋅sinαsinβsinγ。事实上，将其变形令等号一边为 1，再利用面积比等于底的比就可以得到竞赛平面几何中常用的塞瓦(Ceva)定理： AEEB⋅BDDC⋅CFFA=1\\dfrac{AE}{EB}\\cdot\\dfrac{BD}{DC}\\cdot\\dfrac{CF}{FA}=1 EBAE​⋅DCBD​⋅FACF​=1 展望将来 大概是要等到大学才能发表大量博客文章了，高中的话我可能最多写一些数学竞赛的学习笔记或者一些随笔发表到博客上。高中主要有这么几个计划： 挤时间学完高等数学和离散数学的内容，入门一些线性代数的内容，虽然这些对数学竞赛没有多大帮助但是就当课外阅读了。 硬肝初等数论。 先把文化课搞好，然后再专心致志搞数学竞赛！ 祝我成功 😃 ","link":"https://zihim.me/post/DV5VJbzV-/"},{"title":"[研究] 用初中知识推导婆罗摩笈多公式","content":"前几天刚学圆，想到之前见过一个公式，叫做「婆罗摩笈多公式」，昨天花了点时间推导了一下，今天来讲讲吧。 海伦公式 海伦公式相信大家一定不陌生，如果你还不知道，那么请看： 三角形三边分别为 a,b,ca,b,ca,b,c，则它的面积为 p(p−a)(p−b)(p−c)\\sqrt{p(p-a)(p-b)(p-c)}p(p−a)(p−b)(p−c)​。其中，ppp 为三角形的半周长，即 p=a+b+c2p=\\dfrac{a+b+c}{2}p=2a+b+c​。 那么大家肯定想过，对于一个四边形，只知道它四条边的长度，会不会也有长得像这样的公式呢？ 你错了！ 实际上，三角形具有稳定性，但四边形并没有。因此只知道四边形的四条边是无法算出它的面积的。 例如说，你有四根一样长的棍子首尾相连拼成一个正方形，接着，你捏着它两头拉开，变成一个菱形，它的四条边没有变，但是面积却变小了。 但是，我们也不是没有办法只知道四条边求四边形面积，但是这种四边形比较特殊。接下来隆重介绍——婆罗摩笈多公式！ 婆罗摩笈多公式 圆内接四边形四边分别为 a,b,c,da,b,c,da,b,c,d，则该四边形面积为 (p−a)(p−b)(p−c)(p−d)\\sqrt{(p-a)(p-b)(p-c)(p-d)}(p−a)(p−b)(p−c)(p−d)​。其中，ppp 为四边形的半周长，即 p=a+b+c+d2p=\\dfrac{a+b+c+d}{2}p=2a+b+c+d​。 推导过程 我们先随便作一个外角，因为圆内接四边形对角互补，因此 ∠A=∠DCE\\angle{A}=\\angle{DCE}∠A=∠DCE，然后我们连接对角线 BDBDBD，过 DDD 分别作 DF⊥ABDF\\perp ABDF⊥AB，DG⊥BCDG\\perp BCDG⊥BC。设对角线 BD=gBD=gBD=g。 我们将焦点关注在 △ADB\\triangle{ADB}△ADB 中，设 AF=xAF=xAF=x，则由勾股定理可得： d2−x2=g2−(a−x)2d2−x2=g2−a2+2ax−x2x=a2+d2−g22a\\begin{aligned} d^2-x^2&amp;=g^2-{(a-x)}^2\\\\ d^2-x^2&amp;=g^2-a^2+2ax-x^2\\\\ x&amp;=\\dfrac{a^2+d^2-g^2}{2a}\\\\ \\end{aligned} d2−x2d2−x2x​=g2−(a−x)2=g2−a2+2ax−x2=2aa2+d2−g2​​ 因此，sin⁡A=FDd=1dd2−(a2+d2−g22a)2\\sin{A}=\\dfrac{FD}{d}=\\dfrac{1}{d}\\sqrt{d^2-{\\left(\\dfrac{a^2+d^2-g^2}{2a}\\right)}^2}sinA=dFD​=d1​d2−(2aa2+d2−g2​)2​。 同样地，关注 △DCB\\triangle{DCB}△DCB，设 CG=yCG=yCG=y，则： c2−y2=g2−(b+y)2c2−y2=g2−b2−2by−y2y=g2−b2−c22b\\begin{aligned} c^2-y^2&amp;=g^2-{(b+y)^2}\\\\ c^2-y^2&amp;=g^2-b^2-2by-y^2\\\\ y&amp;=\\dfrac{g^2-b^2-c^2}{2b}\\\\ \\end{aligned} c2−y2c2−y2y​=g2−(b+y)2=g2−b2−2by−y2=2bg2−b2−c2​​ 因此，sin⁡∠DCG=DGc=1cc2−(g2−b2−c22b)2\\sin{\\angle{DCG}}=\\dfrac{DG}{c}=\\dfrac{1}{c}\\sqrt{c^2-{\\left(\\dfrac{g^2-b^2-c^2}{2b}\\right)}^2}sin∠DCG=cDG​=c1​c2−(2bg2−b2−c2​)2​。 结合两个式子可以得到： 1dd2−(a2+d2−g22a)2=1cc2−(g2−b2−c22b)21−(a2+d2−g22ad)2=1−(g2−b2−c22bc)2a2+d2−g22ad=g2−b2−c22bca2+d22ad−g22ad=g22bc−b2+c22bcg22ad+g22bc=a2+d22ad+b2+c22bcbcg2+adg2=bc(a2+d2)+ad(b2+c2)g2=ad(b2+c2)+bc(a2+d2)ad+bc\\begin{aligned} \\dfrac{1}{d}\\sqrt{d^2-{\\left(\\dfrac{a^2+d^2-g^2}{2a}\\right)}^2}&amp;=\\dfrac{1}{c}\\sqrt{c^2-{\\left(\\dfrac{g^2-b^2-c^2}{2b}\\right)}^2}\\\\ \\sqrt{1-{\\left(\\dfrac{a^2+d^2-g^2}{2ad}\\right)}^2}&amp;=\\sqrt{1-{\\left(\\dfrac{g^2-b^2-c^2}{2bc}\\right)}^2}\\\\ \\dfrac{a^2+d^2-g^2}{2ad}&amp;=\\dfrac{g^2-b^2-c^2}{2bc}\\\\ \\dfrac{a^2+d^2}{2ad}-\\dfrac{g^2}{2ad}&amp;=\\dfrac{g^2}{2bc}-\\dfrac{b^2+c^2}{2bc}\\\\ \\dfrac{g^2}{2ad}+\\dfrac{g^2}{2bc}&amp;=\\dfrac{a^2+d^2}{2ad}+\\dfrac{b^2+c^2}{2bc}\\\\ bcg^2+adg^2&amp;=bc(a^2+d^2)+ad(b^2+c^2)\\\\ g^2&amp;=\\dfrac{ad(b^2+c^2)+bc(a^2+d^2)}{ad+bc} \\end{aligned} d1​d2−(2aa2+d2−g2​)2​1−(2ada2+d2−g2​)2​2ada2+d2−g2​2ada2+d2​−2adg2​2adg2​+2bcg2​bcg2+adg2g2​=c1​c2−(2bg2−b2−c2​)2​=1−(2bcg2−b2−c2​)2​=2bcg2−b2−c2​=2bcg2​−2bcb2+c2​=2ada2+d2​+2bcb2+c2​=bc(a2+d2)+ad(b2+c2)=ad+bcad(b2+c2)+bc(a2+d2)​​ 当然，g2g^2g2 可以继续化简为 (ab+cd)(ac+bd)ad+bc\\dfrac{(ab+cd)(ac+bd)}{ad+bc}ad+bc(ab+cd)(ac+bd)​，虽然长得挺好看，但是这不方便我们接下来的化简。 将其代回 sin⁡A=1dd2−(a2+d2−g22a)2\\sin{A}=\\dfrac{1}{d}\\sqrt{d^2-{\\left(\\dfrac{a^2+d^2-g^2}{2a}\\right)}^2}sinA=d1​d2−(2aa2+d2−g2​)2​ 中： sin⁡A=1dd2−(a2+d2−g22a)2=1−(a2+d2−g22ad)2=1−(a2+d2−ad(b2+c2)+bc(a2+d2)ad+bc2ad)2=1−(a2(ad+bc)+d2(ad+bc)−ad(b2+c2)−bc(a2+d2)2ad(ad+bc))2=1−(ad(a2+d2)+bc(a2+d2)−ad(b2+c2)−bc(a2+d2)2ad(ad+bc))2=1−((a2+d2−b2−c2)2(ad+bc))2=(1+a2+d2−b2−c22(ad+bc))(1−a2+d2−b2−c22(ad+bc))=2ad+2bc+a2+d2−b2−c22(ad+bc)⋅2ad+2bc−a2−d2+b2+c22(ad+bc)=(a+d)2−(b−c)22(ad+bc)⋅(b+c)2−(a−d)22(ad+bc)=(a+d+b−c)(a+d−b+c)(b+c+a−d)(b+c−a+d)4(ad+bc)2\\begin{aligned} \\sin{A}&amp;=\\dfrac{1}{d}\\sqrt{d^2-{\\left(\\dfrac{a^2+d^2-g^2}{2a}\\right)}^2}\\\\ &amp;=\\sqrt{1-{\\left(\\dfrac{a^2+d^2-g^2}{2ad}\\right)}^2}\\\\ &amp;=\\sqrt{1-{\\left(\\dfrac{a^2+d^2-\\dfrac{ad(b^2+c^2)+bc(a^2+d^2)}{ad+bc}}{2ad}\\right)}^2}\\\\ &amp;=\\sqrt{1-{\\left(\\dfrac{a^2(ad+bc)+d^2(ad+bc)-ad(b^2+c^2)-bc(a^2+d^2)}{2ad(ad+bc)}\\right)}^2}\\\\ &amp;=\\sqrt{1-{\\left(\\dfrac{ad(a^2+d^2)+bc(a^2+d^2)-ad(b^2+c^2)-bc(a^2+d^2)}{2ad(ad+bc)}\\right)}^2}\\\\ &amp;=\\sqrt{1-{\\left(\\dfrac{(a^2+d^2-b^2-c^2)}{2(ad+bc)}\\right)}^2}\\\\ &amp;=\\sqrt{\\left(1+\\dfrac{a^2+d^2-b^2-c^2}{2(ad+bc)}\\right)\\left(1-\\dfrac{a^2+d^2-b^2-c^2}{2(ad+bc)}\\right)}\\\\ &amp;=\\sqrt{\\dfrac{2ad+2bc+a^2+d^2-b^2-c^2}{2(ad+bc)}\\cdot\\dfrac{2ad+2bc-a^2-d^2+b^2+c^2}{2(ad+bc)}}\\\\ &amp;=\\sqrt{\\dfrac{{(a+d)}^2-{(b-c)}^2}{2(ad+bc)}\\cdot\\dfrac{{(b+c)}^2-{(a-d)}^2}{2(ad+bc)}}\\\\ &amp;=\\sqrt{\\dfrac{(a+d+b-c)(a+d-b+c)(b+c+a-d)(b+c-a+d)}{4{(ad+bc)}^2}}\\\\ \\end{aligned} sinA​=d1​d2−(2aa2+d2−g2​)2​=1−(2ada2+d2−g2​)2​=1−⎝⎜⎜⎛​2ada2+d2−ad+bcad(b2+c2)+bc(a2+d2)​​⎠⎟⎟⎞​2​=1−(2ad(ad+bc)a2(ad+bc)+d2(ad+bc)−ad(b2+c2)−bc(a2+d2)​)2​=1−(2ad(ad+bc)ad(a2+d2)+bc(a2+d2)−ad(b2+c2)−bc(a2+d2)​)2​=1−(2(ad+bc)(a2+d2−b2−c2)​)2​=(1+2(ad+bc)a2+d2−b2−c2​)(1−2(ad+bc)a2+d2−b2−c2​)​=2(ad+bc)2ad+2bc+a2+d2−b2−c2​⋅2(ad+bc)2ad+2bc−a2−d2+b2+c2​​=2(ad+bc)(a+d)2−(b−c)2​⋅2(ad+bc)(b+c)2−(a−d)2​​=4(ad+bc)2(a+d+b−c)(a+d−b+c)(b+c+a−d)(b+c−a+d)​​​ 因此，我们可以知道四边形的面积为： S=a⋅DF2+b⋅DG2=a⋅sin⁡A⋅d+b⋅sin⁡∠DCG⋅c2=ad+bc2⋅sin⁡A=ad+bc2⋅(a+d+b−c)(a+d−b+c)(b+c+a−d)(b+c−a+d)4(ad+bc)2=(a+d+b−c)2(a+d−b+c)2(b+c+a−d)2(b+c−a+d)2=(p−a)(p−b)(p−c)(p−d)\\begin{aligned} S&amp;=\\dfrac{a\\cdot DF}{2}+\\dfrac{b\\cdot DG}{2}\\\\ &amp;=\\dfrac{a\\cdot\\sin{A}\\cdot d+b\\cdot\\sin{\\angle{DCG}}\\cdot c}{2}\\\\ &amp;=\\dfrac{ad+bc}{2}\\cdot\\sin{A}\\\\ &amp;=\\dfrac{ad+bc}{2}\\cdot\\sqrt{\\dfrac{(a+d+b-c)(a+d-b+c)(b+c+a-d)(b+c-a+d)}{4{(ad+bc)}^2}}\\\\ &amp;=\\sqrt{\\dfrac{(a+d+b-c)}{2}\\dfrac{(a+d-b+c)}{2}\\dfrac{(b+c+a-d)}{2}\\dfrac{(b+c-a+d)}{2}}\\\\ &amp;=\\sqrt{(p-a)(p-b)(p-c)(p-d)} \\end{aligned} S​=2a⋅DF​+2b⋅DG​=2a⋅sinA⋅d+b⋅sin∠DCG⋅c​=2ad+bc​⋅sinA=2ad+bc​⋅4(ad+bc)2(a+d+b−c)(a+d−b+c)(b+c+a−d)(b+c−a+d)​​=2(a+d+b−c)​2(a+d−b+c)​2(b+c+a−d)​2(b+c−a+d)​​=(p−a)(p−b)(p−c)(p−d)​​ 即 S=(p−a)(p−b)(p−c)(p−d)S=\\sqrt{(p-a)(p-b)(p-c)(p-d)} S=(p−a)(p−b)(p−c)(p−d)​ 拓展：圆的半径是多少？ 这个也不复杂，我们连接 OCOCOC 和 ODODOD，过 OOO 作 OH⊥CDOH\\perp CDOH⊥CD。 那么我们便有了一个「三线合一」，可以得到 DH=c2DH=\\dfrac{c}{2}DH=2c​，∠DOH=12∠DOC=∠DBG\\angle{DOH}=\\dfrac12\\angle{DOC}=\\angle{DBG}∠DOH=21​∠DOC=∠DBG。 抓住这两个角的相等关系，列出式子（RRR 为圆的半径，SSS 为四边形面积）： sin⁡∠DOH=sin⁡∠DBGDHDO=DGDBc2R=sin⁡A⋅cgR=g2sin⁡AR=g22Sad+bcR=(ad+bc)g4SR=(ad+bc)(ab+cd)(ac+bd)ad+bc4SR=(ad+bc)(ab+cd)(ac+bd)4SR=(ad+bc)(ab+cd)(ac+bd)4(p−a)(p−b)(p−c)(p−d)R=14(ad+bc)(ab+cd)(ac+bd)(p−a)(p−b)(p−c)(p−d)\\begin{aligned} \\sin{\\angle{DOH}}&amp;=\\sin{\\angle{DBG}}\\\\ \\dfrac{DH}{DO}&amp;=\\dfrac{DG}{DB}\\\\ \\dfrac{c}{2R}&amp;=\\dfrac{\\sin{A}\\cdot c}{g}\\\\ R&amp;=\\dfrac{g}{2\\sin{A}}\\\\ R&amp;=\\dfrac{g}{2\\frac{2S}{ad+bc}}\\\\ R&amp;=\\dfrac{(ad+bc)g}{4S}\\\\ R&amp;=\\dfrac{(ad+bc)\\sqrt{\\dfrac{(ab+cd)(ac+bd)}{ad+bc}}}{4S}\\\\ R&amp;=\\dfrac{\\sqrt{(ad+bc)(ab+cd)(ac+bd)}}{4S}\\\\ R&amp;=\\dfrac{\\sqrt{(ad+bc)(ab+cd)(ac+bd)}}{4\\sqrt{(p-a)(p-b)(p-c)(p-d)}}\\\\ R&amp;=\\dfrac14\\sqrt{\\dfrac{(ad+bc)(ab+cd)(ac+bd)}{(p-a)(p-b)(p-c)(p-d)}}\\\\ \\end{aligned} sin∠DOHDODH​2Rc​RRRRRRR​=sin∠DBG=DBDG​=gsinA⋅c​=2sinAg​=2ad+bc2S​g​=4S(ad+bc)g​=4S(ad+bc)ad+bc(ab+cd)(ac+bd)​​​=4S(ad+bc)(ab+cd)(ac+bd)​​=4(p−a)(p−b)(p−c)(p−d)​(ad+bc)(ab+cd)(ac+bd)​​=41​(p−a)(p−b)(p−c)(p−d)(ad+bc)(ab+cd)(ac+bd)​​​ 小结 若圆内接四边形四条边长分别为 a,b,c,da,b,c,da,b,c,d，则有以下结论（p=a+b+c+d2p=\\dfrac{a+b+c+d}{2}p=2a+b+c+d​）： 四边形面积 S=(p−a)(p−b)(p−c)(p−d)S=\\sqrt{(p-a)(p-b)(p-c)(p-d)}S=(p−a)(p−b)(p−c)(p−d)​ 圆半径 R=14(ad+bc)(ab+cd)(ac+bd)(p−a)(p−b)(p−c)(p−d)R=\\dfrac14\\sqrt{\\dfrac{(ad+bc)(ab+cd)(ac+bd)}{(p-a)(p-b)(p-c)(p-d)}}R=41​(p−a)(p−b)(p−c)(p−d)(ad+bc)(ab+cd)(ac+bd)​​ 本文中婆罗摩笈多公式的推导仅用了初中知识（三角函数，圆周角定理等），另外，配合正弦定理和余弦定理也可以推导出这几个公式。 ","link":"https://zihim.me/post/2Z81JeNqX/"},{"title":"[随笔] 2020夏：记一次期末考试","content":"由于没有写日记的习惯，所以好像都忘得差不多了。 柒月玖日 ​ 明天就是生物地理考试，上头安排晚修居然才各留了 303030 分钟给生物地理（好吧其实生物地理课也有空出来复习的），但是要复习的东西还是像山一样高。地理复习时间，随便翻了一下提纲，然后把整张提纲背了，花费刚好 303030 分钟，但是发现还有 101010 条铁路干线的名字和主要山脉名没有背，对的，我坚信他不会考！ ​ 生物复习记不太清楚了，就是跟上前几天的进度，勉勉强强把一整本提纲粗略的看了一遍。 柒月拾日 ​ 早上仍旧是 5:305:305:30 醒来，照常的刷牙洗脸，把 +c 叫醒后让他给我讲题，然后还背了一小会生物提纲。 ​ 上午第一场是生物考试，有几个不太确定的，考完对答案发现啊哈原来你们也不确定，心也就踏实了一点。后来发现中华白海豚是哺乳动物，血友病是遗传病；艾滋病不是遗传病，直接送了两道选择题。 ​ 第二场是地理考试，巨难，前几年考的今年好像都没有考。昨晚好不容易花半个小时背的提纲，就考了个三江源是黄河长江澜沧江？？我花了半个小时就换来两分？？？考完试后班里上下都充斥着谩骂与叹气。心中又暗喜原来大家都考差了。 ​ 生物地理考试告一段落，开始为 14−1614-1614−16 号的中考科目做准备。总体来说，两个考试，时间都很充足，试卷做完第一遍，盖住答案，又用蓝笔做了一遍。然后发现，会的还是会，不会的还是不会。 柒月拾壹日 ​ 最后的一个周末，不得加把劲冲一冲哪？根据考试时间制定了一份每科的学习计划，但是不在状态，背了一会书就开始犯困，所以整个周末也没有背多少书。果然还是比较喜欢在学校的日子，起码学习比较有效率。 柒月拾叁日 ​ 今天是中考科目考试的前一天，很平常，很平常，就这样过去了。空余时间照着上面的学习计划，一项一项的完成，首先是选择明天先考的语文和数学进行复习。 ​ 晚上的晚修，就是照着老师的计划安排。数学晚修一直在研究一道选择题，还是今天数学课的模拟卷，没错，搞了整整一个晚修，最后还把整个证明过程写了一遍在纸条上给 iYAbs。 柒月拾肆日 ​ 上午是语文考试，考前还有差不多三个小时的时间复习，赶紧把答题模式和名著阅读过了。 ​ 语文考试生字词第一个就不会，zhòu zhě，是皱褶吗，但是我记得我只在书上见过褶皱，没办法写不出来所以最后还是写的皱褶。选择题词语运用 C 选项和 D 选项不懂，最后好像选了 C，病句修改有两个选项也不能排除，感觉都没有主语，最后随便选了一个。因为我慢条斯理地写，导致我很完美地最后只剩下半个小时写作文，随便套用了一下之前作文课的模板，草草结束作文，刚好收卷。 ​ 下午起床眼睛蒙蒙的，洗了把脸准备考数学，一直在跟坐右边的物理满分大佬 lsx 押题。考试还挺难的，不过所庆幸的是还好都会。最后一题还挺简单，网课期间老师讲过，就是勾股定理。倒数第二题反而还要难一点，是一道找规律的题目，考查的是平方差和因式分解（吧）： ( 2 )(\\ 2\\ )( 2 ) 根据下面四个算式： 52−32=(5+3)×(5－3)=8×2112−52=(11+5)×(11−5)=16×6=8×12152−32=(15+3)×(15−3)=18×12=8×27192−72=(19+7)×(19−7)=26×12=8×39\\begin{aligned} 5^2-3^2&amp;=(5+3)\\times(5－3)&amp;=8\\times2\\\\ 11^2-5^2&amp;=(11+5)\\times(11-5)&amp;=16\\times6=8\\times12\\\\ 15^2-3^2&amp;=(15+3)\\times(15-3)&amp;=18\\times12=8\\times27\\\\ 19^2-7^2&amp;=(19+7)\\times(19-7)&amp;=26\\times12=8\\times39\\\\ \\end{aligned} 52−32112−52152−32192−72​=(5+3)×(5－3)=(11+5)×(11−5)=(15+3)×(15−3)=(19+7)×(19−7)​=8×2=16×6=8×12=18×12=8×27=26×12=8×39​ 请你再写出两个（不同于上面算式）具有上述规律的算式。 ( 3 )(\\ 3\\ )( 3 ) 用文字写出反映 ( 2 )(\\ 2\\ )( 2 ) 中算式的规律，并证明这个规律的正确性。 ​ 说实在的第一感觉那些数字没有什么规律，思索了差不多五分钟才发现原来都是奇数，规律就是：两个奇数的平方差能被 888 整除。下面是证明方法（当然这是我在考场上写的，我不能保证它是对的）： 设第一个数为 (2a+1)(2a+1)(2a+1)，第二个数为 (2b+1)(2b+1)(2b+1)，则： (2a+1)2−(2b−1)2=(2a+1+2b−1)(2a+1−2b+1)=4(a+b)(a−b+1)\\begin{aligned} &amp;(2a+1)^2-(2b-1)^2\\\\ =&amp;(2a+1+2b-1)(2a+1-2b+1)\\\\ =&amp;4(a+b)(a-b+1) \\end{aligned} ==​(2a+1)2−(2b−1)2(2a+1+2b−1)(2a+1−2b+1)4(a+b)(a−b+1)​ 当 aaa，bbb 的奇偶性相同时（这里解释一下是指都为奇数时或都为偶数时），(a+b)(a+b)(a+b) 能被 222 整除，4(a−b+1)4(a-b+1)4(a−b+1) 能被 444 整除，所以 4(a+b)(a−b+1)4(a+b)(a-b+1)4(a+b)(a−b+1) 能被 888 整除。 当 aaa，bbb 的奇偶性不同时（一个是奇数一个是偶数时），(a−b+1)(a-b+1)(a−b+1) 能被 222 整除，4(a+b)4(a+b)4(a+b) 能被 444 整除，所以 4(a+b)(a−b+1)4(a+b)(a-b+1)4(a+b)(a−b+1) 能被 888 整除。 综上所述，(2a+1)2−(2b+1)2(2a+1)^2-(2b+1)^2(2a+1)2−(2b+1)2 能被 888 整除，即两个奇数的平方差能被 888 整除。 ​ （我怀疑你在炫耀你会这一题） ​ 做完试卷后，又全卷检查了一遍，最后留个 303030 分钟填涂答题卡，哇真的要吓死了，时间不够，那个手震震震的，然后疯狂出汗疯狂擦汗。想克制住但是做不到，毕竟你要是都会没写完就很冤。所以那个手，一直在抖抖抖（写出来的字也是真的难看），特别是那个广播还剩下 151515 分钟的时候，我才刚开始写倒数第二题。不是照抄试卷，是有那个想法，但是具体写下来还要时间去构思和排版，所以我就特别怕我时间不够。所幸的是，最后我还是写完了，不过可惜的是没有检查倒数第二题，有点怕偏偏就在这里出了问题（至少我往届多年数学考试都是这样子，哪里没检查就刚好错哪里）。 ​ 考完数学就是调查问卷，给了 303030 分钟填问卷，用了大概 101010 分钟就写完了，做完之后也不知道干什么，又不能复习，于是在试卷最后一页空的地方推导数学公式。还差一点点的时候他把我卷子收走了，所以为什么这个也要收卷子啊啊啊啊啊啊！！！！！！ ​ 晚上的英语复习，发了一小会呆，然后是拼命背政治（虽然到考试开始前一刻我还是没有背完所有的问题，这种东西就根本背不完的好吗）和历史复习，总体来说效率没有很高。 柒月拾伍日 ​ 早上先是政治考试，选择题还检查了一遍，大题永远是我所讨厌的，就想到什么就写什么，问题就是你想不到但是它分值就是很高啊，这时只能叹叹气，说一句“这该死的政治真难”（鬼知道我在考场上说了几十次这句话）。有点难受，第四单元没考（吧），考前我还疯狂在背（当然没有背完），但是大题硬扯扯了一点写了上去。考完试回家后刷动态发现让座那一题饱受争议，我也忘了选了什么，害不管了不管了，反正也改不了了。 ​ 考完政治后紧接着的就是历史考试，哇真的政治历史就是我的大敌，选择题好多不确定的，做完后又回头再做了一遍，填了答题卡后规划好时间，疯狂写大题，大题也和政治差不多，想到什么就写什么，还不忘抄一点材料哈哈哈。 ​ 下午英语考试，脑子傻傻的把头洗了一遍。走在路上就感觉自己是一个憨批。进考场前接收到了来自英语老师的鼓励，于是带着湿漉漉的头，信心满满的走进了考场。可能刚起床的原因，听力没听好（所以你洗头洗脸有什么用嘛），也不能说是没有听好吧，就，听完了之后感觉自己的答案不对劲。笔试部分还是很有信心的，检查了一遍，我甚至觉得我短文填空可以拿到满分（口胡）。 ​ 晚上就是物理复习，整个晚修，222 个小时的物理复习。把每个单元的思维导图过了一遍，然后看之前试卷的错题，发现自己错题还挺多的，而且还挺难的。整个晚修就在解决错题中迷迷糊糊的过去了。 柒月拾陆日 ​ 早上起床发现左衣袖有一摊红色的东西（猜是鼻血） ，发现洗不掉就干脆不管它了，另外一出阳台看到对面宿舍一堆人在开 Party。 ​ 早上还有时间解决错题，右后方的 ljl 大佬提出了一个问题，这道题，直到考试结束，也没有解决。考前还有两道错题解决不了，物理老师也不在，硬背了答案（来自班主任的提醒：不会的题不要问别人了，搞不懂的题目你要相信它不会考）。 ​ 终于迎来了这几天的最后一场考试——物理考试。 ​ 前面有几道关于力的题目不是很确定。而且很不幸，刚写完第十小题，流鼻血了，不好意思去找老师，也不能在考场上直接借纸巾，干脆直接让血小板完成这伟大的使命吧！所以耽误了亿些时间，后面差点没做完，以及最后的综合题和计算题没来得及检查。这次的综合题还可以，不是很难（其实我觉得我综合题挺悬，物理题特别怕算错数），但是计算题最后一题的最后一小问没时间变换公式，就写了个类似于方程的东西直接写因为所以加答案。而且求大气压的那题写的是 75cmHg（如果没记错应该是 75cm75cm75cm 吧），对了答案发现每个人的答案都不一样，所以感觉这次物理要凉凉了。 ​ 考完物理，从此解放。 Update 科目 分数 满分 语文 91 120 数学 119 120 英语 112 120 政治 94 100 历史 85 100 物理 93 100 生物 86 100 地理 97 100 ​ 最终，全班四个人并列第一，年级排十四。 ","link":"https://zihim.me/post/UBt3oeWKW/"},{"title":"[趣题] 你能求出正方形的边长吗？","content":"wow，仔细一看，自己五个月没更新了呢！ 这个问题的灵感来源于学校的数学卷中的某道数学题。 题目 如图，已知正方形内有一点，连接其左下、左上、右下顶点，长度分别为 a,b,ca,b,ca,b,c，求正方形的边长。 俩个余弦~ 我们标好字母，借鉴原卷解法的思想，将左边的三角形顺时针旋转 90∘90^\\circ90∘（严谨点说，就是作 △CE′D\\triangle CE&#x27;D△CE′D 使其与 △CEA\\triangle CEA△CEA 全等）。 根据旋转不改变图形大小和形状的性质，我们可以知道下面几点，它对我们解题非常有帮助。 △CEE′\\triangle CEE&#x27;△CEE′ 为等腰直角三角形。 DE′=AE=bDE&#x27;=AE=bDE′=AE=b。 AE⊥DE′AE\\perp DE&#x27;AE⊥DE′（这个很重要！我看了很久才发现有这条规律！）。 所以 EE′,BE,BE′EE&#x27;,BE,BE&#x27;EE′,BE,BE′ 分别等于 2a,c,b\\sqrt2a,c,b2​a,c,b。 利用两次余弦定理，得到答案： cos⁡∠EE′D=2a2+b2−c222ab∠EE′D=cos⁡−1(2a2+b2−c222ab)⇓∠CE′D=∠EE′D+45∘=cos⁡−1(2a2+b2−c222ab)+45∘⇓再次使用余弦定理CD=a2+b2−2abcos⁡∠CE′D=a2+b2−2abcos⁡(cos⁡−1(2a2+b2−c222ab)+45∘)\\begin{aligned} &amp;\\boxed{ \\begin{aligned} \\cos{\\angle EE&#x27;D}&amp;=\\frac{2a^2+b^2-c^2}{2\\sqrt2ab}\\\\ \\angle EE&#x27;D&amp;=\\cos^{-1}\\left(\\frac{2a^2+b^2-c^2}{2\\sqrt2ab}\\right)\\\\ \\end{aligned} }\\\\ &amp;\\qquad\\qquad\\qquad\\qquad\\Downarrow\\\\ &amp;\\boxed{ \\begin{aligned} \\angle CE&#x27;D&amp;=\\angle EE&#x27;D+45^\\circ\\\\ &amp;=\\cos^{-1}\\left(\\frac{2a^2+b^2-c^2}{2\\sqrt2ab}\\right)+45^\\circ\\\\ \\end{aligned} }\\\\ &amp;\\qquad\\qquad\\qquad\\qquad\\Downarrow再次使用余弦定理\\\\ &amp;\\boxed{ \\begin{aligned} CD&amp;=\\sqrt{a^2+b^2-2ab\\cos\\angle CE&#x27;D}\\\\ &amp;=\\sqrt{a^2+b^2-2ab\\cos\\left(\\cos^{-1}\\left(\\frac{2a^2+b^2-c^2}{2\\sqrt2ab}\\right)+45^\\circ\\right)} \\end{aligned} }\\\\ \\end{aligned} ​cos∠EE′D∠EE′D​=22​ab2a2+b2−c2​=cos−1(22​ab2a2+b2−c2​)​​⇓∠CE′D​=∠EE′D+45∘=cos−1(22​ab2a2+b2−c2​)+45∘​​⇓再次使用余弦定理CD​=a2+b2−2abcos∠CE′D​=a2+b2−2abcos(cos−1(22​ab2a2+b2−c2​)+45∘)​​​​ 疯狂的勾股定理 ​ 我没学过三角函数，所以这个表达式我不会化简，很丑陋（其实下面的那个公式似乎更加丑陋），而且日常使用比较难计算。所以我在想有没有其他的方法。我在宿舍床上想了很久，突然灵感就出来了，那时候直接跑出阳台借着灯光记了下来，然后心满意足的睡觉。如图，我们延长 AEAEAE 交 DE′DE&#x27;DE′ 于 FFF： 我们先来看 △EE′D\\triangle EE&#x27;D△EE′D，我们已经知道其三条边，并且我们知道AF⊥DE′AF\\perp DE&#x27;AF⊥DE′，设 FD=xFD=xFD=x，利用勾股定理我们可以得到： c2−x2=2a2−(b−x)2x=b2+c2−2a22b\\begin{aligned} c^2-x^2&amp;=2a^2-(b-x)^2\\\\ x&amp;=\\frac{b^2+c^2-2a^2}{2b} \\end{aligned} c2−x2x​=2a2−(b−x)2=2bb2+c2−2a2​​ 因此： AD=AF2+x2=(b+c2−x2)2+x2=b2+c2+(2bc−b2−c2+2a2)(2bc+b2+c2−2a2)\\begin{aligned} AD&amp;=\\sqrt{{AF}^2+x^2}\\\\ &amp;=\\sqrt{\\left(b+\\sqrt{c^2-x^2}\\right)^2+x^2}\\\\ &amp;=\\sqrt{b^2+c^2+\\sqrt{\\left(2bc-b^2-c^2+2a^2\\right)\\left(2bc+b^2+c^2-2a^2\\right)}} \\end{aligned} AD​=AF2+x2​=(b+c2−x2​)2+x2​=b2+c2+(2bc−b2−c2+2a2)(2bc+b2+c2−2a2)​​​ 对角线来了，边长还会远吗？ AB=AD2AB=\\frac{AD}{\\sqrt2}AB=2​AD​，所以边长就等于： b2+c22+14(2bc−b2−c2+2a2)(2bc+b2+c2−2a2)\\sqrt{\\frac{b^2+c^2}{2}+\\sqrt{\\frac14(2bc-b^2-c^2+2a^2)(2bc+b^2+c^2-2a^2)}} 2b2+c2​+41​(2bc−b2−c2+2a2)(2bc+b2+c2−2a2)​​ 如果你愿意，可以再变得美观一些（就是那个 2\\sqrt22​ 有点丑了）： b2+c22+14(2a+b+c)(2a+b−c)(2a+c−b)(b+c−2a)\\sqrt{\\frac{b^2+c^2}{2}+\\sqrt{\\frac14(\\sqrt2a+b+c)(\\sqrt2a+b-c)(\\sqrt2a+c-b)(b+c-\\sqrt2a)}} 2b2+c2​+41​(2​a+b+c)(2​a+b−c)(2​a+c−b)(b+c−2​a)​​ 再一种做法——解析几何 （为了方便阅读，我将常数 a,b,c\\rm a,b,ca,b,c 标为正体，变量 g,x,yg,x,yg,x,y 标为斜体） 如图，我们可以得到一个三元二次方程组： {CE:x2+y2=a2…(1)AE:x2+(g−y)2=b2…(2)DE:(g−x)2+yx=c2…(3)\\left\\{ \\begin{aligned} CE:&amp;&amp;x^2+y^2=\\rm a^2\\dots(1)\\\\ AE:&amp;&amp;x^2+{(g-y)}^2=\\rm b^2\\dots(2)\\\\ DE:&amp;&amp;{(g-x)}^2+y^x=\\rm c^2\\dots(3)\\\\ \\end{aligned} \\right. ⎩⎪⎪⎨⎪⎪⎧​CE:AE:DE:​​x2+y2=a2…(1)x2+(g−y)2=b2…(2)(g−x)2+yx=c2…(3)​ (2)−(1)(2)-(1)(2)−(1) 得到 y=g2+a2−b22gy=\\dfrac{g^2+{\\rm a^2-b^2}}{2g}y=2gg2+a2−b2​；(3)−(1)(3)-(1)(3)−(1) 得到 x=g2+a2−c22gx=\\dfrac{g^2+{\\rm a^2-c^2}}{2g}x=2gg2+a2−c2​。 将 xxx 和 yyy 代入 (1)(1)(1)，得到： (g2+a2−c22g)2+(g2+a2−b22g)2=a2{\\left(\\dfrac{g^2+{\\rm a^2-c^2}}{2g}\\right)}^2+{\\left(\\dfrac{g^2+{\\rm a^2-b^2}}{2g}\\right)}^2=\\rm a^2 (2gg2+a2−c2​)2+(2gg2+a2−b2​)2=a2 解得： g=±b2+c22±14(2a+b+c)(2a+b−c)(2a+c−b)(b+c−2a)g=\\rm\\pm\\sqrt{\\frac{b^2+c^2}{2}\\pm\\sqrt{\\frac14(\\sqrt2a+b+c)(\\sqrt2a+b-c)(\\sqrt2a+c-b)(b+c-\\sqrt2a)}} g=±2b2+c2​±41​(2​a+b+c)(2​a+b−c)(2​a+c−b)(b+c−2​a)​​ 去掉多余的根，得到： g=b2+c22+14(2a+b+c)(2a+b−c)(2a+c−b)(b+c−2a)g=\\rm\\sqrt{\\frac{b^2+c^2}{2}+\\sqrt{\\frac14(\\sqrt2a+b+c)(\\sqrt2a+b-c)(\\sqrt2a+c-b)(b+c-\\sqrt2a)}} g=2b2+c2​+41​(2​a+b+c)(2​a+b−c)(2​a+c−b)(b+c−2​a)​​ 由海伦公式引出的推论 根据海伦公式，其实可以变换成一个更简洁的公式： b2+c22+2S△EE′D\\sqrt{\\frac{b^2+c^2}{2}+2S_{\\triangle EE&#x27;D}} 2b2+c2​+2S△EE′D​​ 因为 b2+c22\\frac{b^2+c^2}{2}2b2+c2​ 实质上是以 bbb 和 ccc 为直角边的等腰直角三角形的面积和，所以我们就可以得到： SABCD=S△AEF+S△DEG+2S△DEE′S_{ABCD}=S_{\\triangle AEF}+S_{\\triangle DEG}+2S_{\\triangle DEE&#x27;} SABCD​=S△AEF​+S△DEG​+2S△DEE′​ 这可能是这个图形中有关结论中最简洁的一个了吧。 从正四边形到正三边形 同样地，如果把正方形换成等边三角形，通过类似的方法，也可以求出边长。 如图，方法还是旋转，突破点还是旋转角度 ∠BGC=60∘\\angle BGC=60^\\circ∠BGC=60∘。 再作几条垂线，用勾股定理就可以求出 BCBCBC 的长度。 方法不再赘述，这里放上公式，推出来的朋友可以对一下答案： a2+b2+c22+34(a+b+c)(a+b−c)(a+c−b)(b+c−a)\\sqrt{\\frac{a^2+b^2+c^2}{2}+\\sqrt{\\frac{3}{4}(a+b+c)(a+b-c)(a+c-b)(b+c-a)}} 2a2+b2+c2​+43​(a+b+c)(a+b−c)(a+c−b)(b+c−a)​​ ","link":"https://zihim.me/post/x8zECUlU9/"},{"title":"[研究] “复杂”的相遇问题","content":"昨天突然想起一道小学时曾经做过的题目。 题目 有一条长为 sss 的路 ABABAB，甲和乙在 AAA 点上，甲的速度为 vav_ava​，乙的速度为 vbv_bvb​（va&gt;vbv_a&gt;v_bva​&gt;vb​）。甲乙同时向右运动。甲不断在乙和 BBB 点之间运动（折返跑），直到乙到达 BBB 点为止。求甲走的距离。 小学那时候一看这题，束手无策。可能那时也对数学不够重视吧，反正也不知道怎么做的。后来上了初中，第一次考试卷子就考这个，我人都傻了。好在觉悟够高，认真听了老师讲评，回忆了一下当时的做法，可谓是贻笑千载。 我的解法 如上图，每次算出红线的总长度，剩下的蓝线又可以表示成原图图中的形式（原问题的相同子问题）。 我们用 f⁡(x)\\operatorname{f}(x)f(x) 来表示乙走一段长度为 xxx 的路的总路程（即假如上图中黑色加上蓝色的线为总长度，那么乙走的路程就是红色的线），用 g⁡(x)\\operatorname{g}(x)g(x) 来表示甲走一段长度为 xxx 的路的总路程。 那么根据上图，我们可以使用相遇问题的公式，将红线加上绿线作为总路程，可以算出相遇时间为 2xva+vb\\frac{2x}{v_a+v_b}va​+vb​2x​。那么红线的长度就是 f⁡(x)=2xvbva+vb\\operatorname{f}(x)=\\frac{2xv_b}{v_a+v_b}f(x)=va​+vb​2xvb​​，同理可得 g⁡(x)=2xvava+vb\\operatorname{g}(x)=\\frac{2xv_a}{v_a+v_b}g(x)=va​+vb​2xva​​。 从 g⁡(x)\\operatorname{g}(x)g(x) 中可以看出每次 xxx 会缩小到原来的 vb−vavb+va\\frac{v_b-v_a}{v_b+v_a}vb​+va​vb​−va​​ ，那么答案就是： ∑i=0∞f⁡(s(vb−vavb+va)i)=2svbva+vb(1+(vb−vavb+va)+(vb−vavb+va)2+(vb−vavb+va)3+⋯ )\\begin{aligned} &amp;\\sum\\limits_{i=0}^\\infty \\operatorname{f}(s(\\frac{v_b-v_a}{v_b+v_a})^i)\\\\ =&amp;\\frac{2sv_b}{v_a+v_b}(1+(\\frac{v_b-v_a}{v_b+v_a})+(\\frac{v_b-v_a}{v_b+v_a})^2+(\\frac{v_b-v_a}{v_b+v_a})^3+\\cdots) \\end{aligned} =​i=0∑∞​f(s(vb​+va​vb​−va​​)i)va​+vb​2svb​​(1+(vb​+va​vb​−va​​)+(vb​+va​vb​−va​​)2+(vb​+va​vb​−va​​)3+⋯)​ 然后我们可以利用一个有名的幂级数公式： 1+x+x2+x3+⋯=11−x(∣x∣&lt;1)1+x+x^2+x^3+\\cdots=\\frac{1}{1-x}\\quad(|x|&lt;1) 1+x+x2+x3+⋯=1−x1​(∣x∣&lt;1) 注意只有当 ∣x∣&lt;1|x|&lt;1∣x∣&lt;1 才能套入公式。因为 va&gt;vb≥0v_a&gt;v_b\\ge0va​&gt;vb​≥0，因此 vb−vavb+va∈[0,1)\\frac{v_b-v_a}{v_b+v_a}\\in[0,1)vb​+va​vb​−va​​∈[0,1)。因此我们可以套用上面的公式，于是： ∑i=0∞f⁡(s(vb−vavb+va)i)=2svbva+vb(1+(vb−vavb+va)+(vb−vavb+va)2+(vb−vavb+va)3+⋯ )=2svbva+vb(11−vb−vavb+va)=svbva\\begin{aligned} &amp;\\sum\\limits_{i=0}^\\infty \\operatorname{f}(s(\\frac{v_b-v_a}{v_b+v_a})^i)\\\\ =&amp;\\frac{2sv_b}{v_a+v_b}(1+(\\frac{v_b-v_a}{v_b+v_a})+(\\frac{v_b-v_a}{v_b+v_a})^2+(\\frac{v_b-v_a}{v_b+v_a})^3+\\cdots)\\\\ =&amp;\\frac{2sv_b}{v_a+v_b}(\\frac{1}{1-\\frac{v_b-v_a}{v_b+v_a}})\\\\ =&amp;\\boxed{\\frac{sv_b}{v_a}} \\end{aligned} ===​i=0∑∞​f(s(vb​+va​vb​−va​​)i)va​+vb​2svb​​(1+(vb​+va​vb​−va​​)+(vb​+va​vb​−va​​)2+(vb​+va​vb​−va​​)3+⋯)va​+vb​2svb​​(1−vb​+va​vb​−va​​1​)va​svb​​​​ 正解 因为甲和乙同时开始，同时停止，因此甲的运动时间等于乙的运动时间，通过题目易得运动时间为 svb\\frac{s}{v_b}vb​s​，再代入公式 s=vts=vts=vt 得出甲的运动路程为 svbva\\frac{sv_b}{v_a}va​svb​​。 真的要贻笑千载了。 彩蛋：幂级数公式是怎么来的？ 1+x+x2+x3+…=gx+x2+x3+x4+…=gx(1+x+x2+x3+… )−(x+x2+x3+x4+… )=g−gx1=g(1−x)g=11−x\\begin{aligned} 1+x+x^2+x^3+\\dots&amp;=g\\\\ x+x^2+x^3+x^4+\\dots&amp;=gx\\\\ (1+x+x^2+x^3+\\dots)-(x+x^2+x^3+x^4+\\dots)&amp;=g-gx\\\\ 1&amp;=g(1-x)\\\\ g&amp;=\\frac{1}{1-x} \\end{aligned} 1+x+x2+x3+…x+x2+x3+x4+…(1+x+x2+x3+…)−(x+x2+x3+x4+…)1g​=g=gx=g−gx=g(1−x)=1−x1​​ ∴1+x+x2+x3+⋯=11−x(∣x∣&lt;1)\\therefore1+x+x^2+x^3+\\cdots=\\frac{1}{1-x}\\quad(|x|&lt;1) ∴1+x+x2+x3+⋯=1−x1​(∣x∣&lt;1) ","link":"https://zihim.me/post/jp4_8MyUP/"},{"title":"[研究] 直尺作图","content":" 一切尺规作图能够完成的操作，直尺作图都能做到。 当然，直尺是画不了圆的，你只需要知道这个圆的圆心和半径即可。 什么是直尺作图 顾名思义，就是只使用直尺作图，直尺要满足这四个特点： 没有刻度 无限长度 带有单位宽度 直尺的两边都是直线且平行 另外，它只能进行如下操作： 过两点作一条直线 把线段向两端无限延伸 过一条线作距离为单位长度的平行线（即用尺子的一条边与一条直线对齐，在另一边作平行线） 给定距离不小于单位长度的两点，作距离为111的两条平行线，且这两条平行线经过这两点（即把尺子卡在两个点上并作平行线） 有限次执行上述操作 我们称上面这五条为规则。 知道这些基础知识后，我们就可以开始了。 怎么证明 如何证明一个作图法与可以完成尺规作图的操作？ 首先，你为什么要用尺规？ 因为直尺可以作直线，圆规可以作圆，而我们不断找着这些图形的交点，然后再作图。 那么理由无非只有三个： 找出直线与直线的交点 找出直线与圆的交点 找出圆与圆的交点 所以，假如你要证明尺规作图的操作，仅用直尺也能作出来，就需要我们证明仅使用直尺及其规则完成上面三点内容即可。 那么，让我们拿起这块基石，一点一点地搭建起几何的大厦吧！ 开始证明 中点 如图所示，已知线段ABABAB，求作ABABAB中点。 过程： 在ABABAB单位长度上方作平行线lll 在lll上方任意取一点CCC 连接ACACAC交lll于DDD，连接BCBCBC交lll于EEE 连接DB,AEDB,AEDB,AE交于FFF 连接CFCFCF并延长到GGG，那么GGG为ABABAB中点 证明： 由塞瓦定理得CDDA×AGGB×BEEC=1\\frac{CD}{DA}\\times\\frac{AG}{GB}\\times\\frac{BE}{EC}=1DACD​×GBAG​×ECBE​=1 ∵l∥AB\\because l\\parallel AB∵l∥AB ∴DACD=BEEC\\therefore\\frac{DA}{CD}=\\frac{BE}{EC}∴CDDA​=ECBE​ ∴AG=GB\\therefore AG=GB∴AG=GB 中垂线 如图所示，已知线段ABABAB，求作ABABAB中垂线。 过程： 过A,BA,BA,B两点作一对单位平行线AD,BCAD,BCAD,BC和AC,BDAC,BDAC,BD，相交于C,DC,DC,D。 连接CDCDCD，交ABABAB与EEE，则直线CDCDCD为ABABAB中垂线。 证明： ∵AC=BC=BD=AD\\because AC=BC=BD=AD∵AC=BC=BD=AD ∴ABCD\\therefore ABCD∴ABCD为菱形 又∵\\because∵菱形两条对角线互相垂直平分 ∴CD\\therefore CD∴CD为ABABAB中垂线 但是！你有没有发现什么？ 如果ABABAB小于单位长度呢？ 没有问题！看图： 过程： 作ABABAB中点CCC 过CCC任意一条直线，向左和向右作单位平行线交ABABAB于DDD与EEE 作DEDEDE的中垂线，则DEDEDE的中垂线为ABABAB的中垂线 可以知道，DEDEDE是必定大于单位长度的，所以可以仿照上面的方法作DEDEDE中垂线，又因为AC=BC,DC=CEAC=BC,DC=CEAC=BC,DC=CE，所以DA=BEDA=BEDA=BE，DEDEDE的中垂线即为ABABAB的中垂线。 平行线 如图，已知直线lll和lll外一点AAA，求作过AAA的lll的平行线。 过程： 在lll上任意取一点BBB，连接ABABAB，向左和向右作单位平行线分别交lll于C,DC,DC,D 作ABABAB中点EEE，连接DEDEDE并交于FFF 连接AFAFAF，则AFAFAF为lll的平行线 证明： ∵BC=BD\\because BC=BD∵BC=BD ∴FE=ED\\therefore FE=ED∴FE=ED 又∵AE=EB\\because AE=EB∵AE=EB ∴△AEF≅△BED\\therefore \\triangle AEF\\cong\\triangle BED∴△AEF≅△BED ∴FA∥l\\therefore FA\\parallel l∴FA∥l 垂线 如图，已知lll与lll外一点AAA，求作过AAA的lll的垂线。 过程： 在lll上任取两点B,CB,CB,C，作BCBCBC中垂线。 若中垂线在AAA上已完成，若不在，过AAA作BCBCBC中垂线的平行线交于EEE，则AEAEAE为过AAA的lll的垂线。 证明不用写了吧，两直线平行，同位角相等。 角平分线 如图，已知∠BAC\\angle BAC∠BAC，求作∠BAC\\angle BAC∠BAC的角平分线。 过程： 过ACACAC在BBB一侧作单位平行线交ABABAB于EEE，过ABABAB在CCC一侧作单位平行线交ACACAC于DDD。 两条平行线交于FFF，连接AFAFAF，则AFAFAF为∠BAC\\angle BAC∠BAC的角平分线。 证明： ∵EF∥AC,FD∥AB\\because EF\\parallel AC,FD\\parallel AB∵EF∥AC,FD∥AB ∴AEDF\\therefore AEDF∴AEDF为平行四边形 又∵\\because∵平行四边形对角线平分内角 ∴∠EAF=∠FAD\\therefore \\angle EAF=\\angle FAD∴∠EAF=∠FAD Tip:当∠BAC\\angle BAC∠BAC为一些特殊角度时（如180∘180^\\circ180∘或360∘360^\\circ360∘时），这个方法就不管用了，不过这没什么影响，这种特殊角更容易作出角平分线。 线段的加减 如图，求作以CCC为圆心，ABABAB为半径所作的圆与直线的交点。 这题其实就是想让你把ABABAB挪到CCC所在这条直线上。 我们可以用类似于作平行线的方法将ABABAB平移到CCC处 那么，ABABAB就被平移到CDCDCD了。为了能让它在直线上，我们要把它旋转下来。 为了让它旋转下来，我们可以利用等腰三角形三线合一的性质。 CDCDCD与直线产生了两个角（下面那两个不算），我们分别平分他，再分别过DDD作这两条角平分线的垂线交于GGG和FFF。 因为CECECE平分∠DCF,DF⊥CE\\angle DCF,DF\\perp CE∠DCF,DF⊥CE，那么△DCF\\triangle DCF△DCF等腰，因此CD=CFCD=CFCD=CF，另一边同理。 那么现在我们可以任意对两条线段进行加减操作了。 线段的乘除 因为你已经可以将一条线段移动到另一条线段上了，那么线段的乘除就会比较简单。 如图，已知线段aaa和bbb，求作ababab长的线段和ab\\frac{a}{b}ba​长的线段。 过程： aaa的两端点为A,BA,BA,B，过AAA作ABABAB垂线 在ABABAB上方作单位平行线交垂线于DDD，在垂线上截取AC=bAC=bAC=b 连接DBDBDB，过CCC作BDBDBD平行线交于ABABAB延长线上的EEE，则AE=abAE=abAE=ab 证明： ∵BD∥CE\\because BD\\parallel CE∵BD∥CE ∴∠ADB=∠ACE\\therefore \\angle ADB=\\angle ACE∴∠ADB=∠ACE 又∵∠DAB=∠CAE\\because\\angle DAB=\\angle CAE∵∠DAB=∠CAE ∴△DAB∼△CAE\\therefore \\triangle DAB\\sim \\triangle CAE∴△DAB∼△CAE ∴DA:CA=BA:EA\\therefore DA:CA=BA:EA∴DA:CA=BA:EA 1:b=a:EA1:b=a:EA1:b=a:EA EA=abEA=abEA=ab 同理可作出ab\\frac{a}{b}ba​的长度。如下图AE=abAE=\\frac{a}{b}AE=ba​。 平方根 如图，已知线段ABABAB，求作线段AB\\sqrt{AB}AB​。 过程： 作出线段ACACAC，使其长度为AB+1AB−1\\frac{AB+1}{AB-1}AB−1AB+1​ 过A,CA,CA,C两点作一对单位平行线，并过AAA作他们的垂线交于CCC所在的平行线的DDD 在ABABAB上方作单位平行线，作∠DAC\\angle DAC∠DAC平分线交于平行线于EEE 过EEE作ABABAB垂线交ABABAB于FFF，则AF=ABAF=\\sqrt{AB}AF=AB​ 证明： 可以算出∠DAC=cos⁡−1ADAC=cos⁡−1AB−1AB+1\\angle DAC=\\cos^{-1}\\frac{AD}{AC}=\\cos^{-1}\\frac{AB-1}{AB+1}∠DAC=cos−1ACAD​=cos−1AB+1AB−1​，以及∠EAF=tan⁡−1EFAF=tan⁡−11AF\\angle EAF=\\tan^{-1}\\frac{EF}{AF}=\\tan^{-1}\\frac{1}{AF}∠EAF=tan−1AFEF​=tan−1AF1​。 又因为2∠DAC=∠EAF2\\angle DAC=\\angle EAF2∠DAC=∠EAF，所以AF=1tan⁡(cos⁡−1AB−1AB+12)\\large AF=\\frac{1}{\\tan(\\frac{\\cos^{-1}\\frac{AB-1}{AB+1}}{2})}AF=tan(2cos−1AB+1AB−1​​)1​。 利用半角公式，可以得出AF=ABAF=\\sqrt{AB}AF=AB​。 找出圆与直线的交点 既然我们可以只用直尺进行加减乘除开方运算了，那么... 如图，已知C,AB,DEC,AB,DEC,AB,DE，求以CCC为圆心，DEDEDE为半径的圆与ABABAB的交点。 你的勾股定理可不是白学的。我们先过CCC作ABABAB垂线，很明显，GF=FHGF=FHGF=FH，因为GHGHGH是圆的一根弦，弦的中垂线必定经过圆心。 所以FHFHFH的长度就是CH2−CF2\\sqrt{CH^2-CF^2}CH2−CF2​，即DE2−CF2\\sqrt{DE^2-CF^2}DE2−CF2​。这是一个只包含减法乘法开方运算的式子，因此我们可以把它作出来，从而得出FHFHFH的长度，自然也可以找出圆和直线的交点了。 找出圆与圆的交点 这是证明的最后一步了！ 已知A,B,CD,EFA,B,CD,EFA,B,CD,EF。求作以AAA为圆心，CDCDCD为半径的圆与以BBB为圆心，EFEFEF为半径的圆的交点。 连接ABABAB。我们可以得知GIGIGI垂直于ABABAB（上面已经证过了）。 由图可知，我们已知AG,BGAG,BGAG,BG和ABABAB的长度。设AH=xAH=xAH=x，由题意得： AG2−AH2=BG2−BH2AG^2-AH^2=BG^2-BH^2AG2−AH2=BG2−BH2 AG2−x2=BG2−(AB−x)2AG^2-x^2=BG^2-(AB-x)^2AG2−x2=BG2−(AB−x)2 x=AB2+AG2−BG22ABx=\\frac{AB^2+AG^2-BG^2}{2AB}x=2ABAB2+AG2−BG2​ 很明显，我们可以把这个xxx作出来。 在ABABAB上截取AHAHAH后，过HHH作ABABAB垂线，那么只需要找出圆AAA与直线的交点即可。 参考资料 趣题：只用一把带有两条平行边的直尺作图 | Matrix67: The Aha Moments ","link":"https://zihim.me/post/LHkNZLFmtH/"},{"title":"[研究] 神秘的魔板","content":"前几天看《可怕的科学——特别要命的数学》看到一章《吉帕特的大轮回》十分有意思，简直是表白神器！！ 先来玩个小游戏 这是一块「魔板」，我们按下面操作： 选一个白色格子，把它涂成蓝色，并把这个格子同行列的格子涂成红色。 在剩下的白色格子里重复执行上面的操作，直到你涂了 5 个格子为止。 把蓝色格子里的数加起来，你会发现答案总是 666！ 例如如下： 通过上图我们可以得出 114+127+125+113+187=666114+127+125+113+187=666114+127+125+113+187=666！ 如何打造一个爆款魔板 先画好一个 5×55\\times 55×5 的表格。 选择一个你想要的结果 xxx（就如上面的 666）。这里我使用 x=520x=520x=520。 选择九个正整数使它们的和等于 xxx。我这里随便选了 1+2+3+4+50+99+112+119+130=5201+2+3+4+50+99+112+119+130=5201+2+3+4+50+99+112+119+130=520。 在这九个数之间选择其中五个数填在表格的某一列，并将它亲切地称为「固定列」。 在剩下的四列中，在每一列顶端随机写下剩下的四个正整数（不是填进格子里，写在表格的上面），这个数字称为这一列的「幸运数字」。 对于剩下的 20 个格子：等于这个格子所在的一列的「幸运数字」加上这个格子所在一行的与「固定列」相交的格子里的数。 例如左上角的格子所在的一列的「幸运数字」是 2 ，所在一行的与「固定列」相交的格子里的数是 99，那么左上角这个格子就是 2+99=1012+99=1012+99=101。 以此类推，我们可以得到下面这个表格： 别忘了把你的「幸运数字」擦掉避免被人发现。 这样，表格就完成了。 这是什么原理？ ​ 首先，你有没有发现关键的一点： 涂蓝色的五个格子一定互不同行不同列。 ​ 因为我们每选完一个格子，我们就把它同行同列的格子涂成红色了，因此我们就不能选与它同行同列的格子了，因此这五个格子一定互不同行不同列。回到这张图： 因为只有五列五列，因此被选中的格子也有五个，他们还不同行同列，那么每行每列有且仅有一个被选中的格子。又因为每个格子是同行同列的「幸运数字」和「固定列」上的数字的和（「固定列」上的「幸运数字」可以看做是 0）。那么你能否想到，每个「固定列」上的数字有且仅有一次被加到结果里，而且「幸运数字」也是有且仅有一次被加到结果里？ 如果你不能想到，那也别急，我们可以这样想： 对于每个「幸运数字」来说，如果有一个蓝色格子被选到在它的这一列，那么就给答案加上这个「幸运数字」。 同样的，对于每个「固定列」上的数字来说，如果有一个蓝色格子被选到在它的这一行，那么就给答案加上这个数字。 因为我们刚刚说那么每行每列有且仅有一个涂蓝色的格子，那么每个「幸运数字」和「固定列」上的数有且仅有一次被加到结果里。 那么答案就是每个「幸运数字」和「固定列」上的数的总和，也就是你想要的数字。 而为什么要选择九个正整数的原因也昭然若揭了： 因为能让每行每列都能都能只被选中一次。 更 多 玩 法 如果你已经掌握了原理，你就能制作出无数个这样的表格。如果你比较聪明，你就还找到更多玩法： 表格不一定是5×55\\times 55×5的正方形，可以是n×nn\\times nn×n的正方形，只不过记住制作时是选择 (2n−1)(2n-1)(2n−1) 个数的总和成为你的结果。 你所选择的那九个数也不一定是正整数，可以是任何实数！ 做好后可以把魔板里的数字旋转、翻转或者扔进油锅里炸一炸。 ","link":"https://zihim.me/post/yXBbh94Bv/"},{"title":"[研究] 魔术背后的 1.618","content":"周三上奥数课，惨遭滑铁卢。 注意：本文为方便阅读，定义 ϕ=1+52\\phi=\\dfrac{1+\\sqrt{5}}{2}ϕ=21+5​​。 发现问题 奥数课数学老师不在，让我和 RioBlu 来讲题，最后剩一段空余时间，我心血来潮要表演一个魔术： “在这十个格子中，在前两个格子各填上一个正整数。当然，不要告诉我。让从第三个格子开始填，每个格子里的数是前两个格子的和，填到第九个格子为止。把第九个格子的数告诉我，我就可以告诉你第十个格子里的数。” 一通操作猛如虎，我将第十个格子算出了 223922392239，正确答案却是… 了解问题 秘诀 假设第九个格子的数字为 nnn，那么第十个格子的数字就是 ⌊ϕn+12⌋\\left\\lfloor\\phi n+\\dfrac{1}{2}\\right\\rfloor⌊ϕn+21​⌋（其中 ⌊x⌋\\lfloor x\\rfloor⌊x⌋ 代表将 xxx 向下取整）。 通俗点说，把第九个格子的数乘上 ϕ\\phiϕ，再四舍五入，就是第十个格子里的数了。 例如我填了 222 和 444，那么前九个格子应该是这样的： 然后你把第九个格子的数字，也就是 110110110 告诉我，我可以立马得出第十个格子的数是 110×ϕ≈178110\\times\\phi\\approx178110×ϕ≈178，而事实真的是这样，68+110=17868+110=17868+110=178： 原理 如果我们假设第一个格子为 aaa，第二个格子是 bbb，那么第九个格子和第十个格子的值我们就已经确定了： 如果将第九个格子乘上 ϕ\\phiϕ，那么可以算出 (13a+21b)×ϕ≈21a+34b(13a+21b)\\times\\phi\\approx21a+34b(13a+21b)×ϕ≈21a+34b，这正好是第十个格子的值。 分析问题 事实上，这种方法只能得到一个近似的值，如果这个估算值与真实值不相等，那么就会失误。因此，要保证万无一失，估算值与真实值必须相等： ⌊ϕ(13a+21b)+12⌋=21a+34b\\left\\lfloor\\phi(13a+21b)+\\dfrac{1}{2}\\right\\rfloor=21a+34b ⌊ϕ(13a+21b)+21​⌋=21a+34b 拿到这个方程的时候，我人都傻了，这种方程怎么解啊？ 最后，我将它的函数图像画了出来，并花了两天时间找出了规律： ϕa−k&lt;b&lt;ϕa+k(k=∣121(5−1)−13×2∣)\\phi a-k&lt;b&lt;\\phi a+k\\quad\\left(k=\\left|\\dfrac{1}{21(\\sqrt{5}-1)-13\\times2}\\right|\\right) ϕa−k&lt;b&lt;ϕa+k(k=∣∣∣∣​21(5​−1)−13×21​∣∣∣∣​) 因此，在课上的例子中 a=100,b=4a=100,b=4a=100,b=4，将 aaa 代入上面的规律中可以算出 138.3&lt;b&lt;185.2138.3&lt;b&lt;185.2138.3&lt;b&lt;185.2，然而 444 并不在这个范围内，所以估算值与真实值不相等。 解决问题 那么，我们要怎么避免出现这种尴尬情况呢？ 一方面，我们可以算更多的格子。 事实上，相邻两个格子之间的比值会趋近于 ϕ\\phiϕ。通过观察上面的图我们发现，如果让对方填入前 n(n≤3)n(n\\le3)n(n≤3) 个格子，并将第 nnn 个格子的值告诉你，那么这个值为 Fn−2⋅a+Fn−1⋅bF_{n-2}\\cdot a+F_{n-1}\\cdot bFn−2​⋅a+Fn−1​⋅b。其中 FnF_nFn​ 为斐波那契数列的第 nnn 项。斐波那契数列就是前两个数为 111，从第三项开始每一项是前两项的和的数列，它长这样：{1,1,2,3,5,8,13,21,… }\\{1,1,2,3,5,8,13,21,\\dots\\}{1,1,2,3,5,8,13,21,…}。 因此方程变成： ⌊ϕ(Fn−2⋅a+Fn−1⋅b)+12⌋=Fn−1⋅a+Fn⋅b\\left\\lfloor\\phi(F_{n-2}\\cdot a+F_{n-1}\\cdot b)+\\dfrac{1}{2}\\right\\rfloor=F_{n-1}\\cdot a+F_{n}\\cdot b ⌊ϕ(Fn−2​⋅a+Fn−1​⋅b)+21​⌋=Fn−1​⋅a+Fn​⋅b 那么模仿上面的规律，你可以先给对方规定 aaa 和 bbb 的范围： ϕa−k&lt;b&lt;ϕa+k(k=∣1Fn−1(5−1)−Fn−2×2∣)\\phi a-k&lt;b&lt;\\phi a+k\\quad\\left(k=\\left|\\dfrac{1}{F_{n-1}(\\sqrt{5}-1)-F_{n-2}\\times2}\\right|\\right)\\\\ ϕa−k&lt;b&lt;ϕa+k(k=∣∣∣∣​Fn−1​(5​−1)−Fn−2​×21​∣∣∣∣​) 由于计算斐波那契数非常繁琐，因此利用斐波那契数列通项公式将 kkk 化简一下得到： ϕa−k&lt;b&lt;ϕa+k(k=ϕn−12)\\phi a-k&lt;b&lt;\\phi a+k\\quad\\left(k=\\dfrac{\\phi^{n-1}}{2}\\right)\\\\ ϕa−k&lt;b&lt;ϕa+k(k=2ϕn−1​) 然而，这还需要对方通过复杂计算自己的数字是否符合要求，魔术的气息瞬间就没了。因此另一方面，我们可以同时给 aaa 和 bbb 找一个范围，保证这个范围内的数绝对不会出错。 我结合函数图像的规律，舍大取小，得到 nnn 对应的最大范围： 0&lt;a,b&lt;ϕn−220&lt;a,b&lt;\\frac{\\phi^{n-2}}{2} 0&lt;a,b&lt;2ϕn−2​ 这样，你就可以在表演之前先计算好这个数字，然后在表演时让对方保证两个数字不超过这个范围。这样，既避免了失误，又保证了魔术的说服力。 你能表演一下吗？ （首先约定填到第九个格子，计算 ϕ9−22≈14.52\\dfrac{\\phi^{9-2}}{2}\\approx14.522ϕ9−2​≈14.52，因此范围为 0&lt;a,b&lt;14.520&lt;a,b&lt;14.520&lt;a,b&lt;14.52） “来，你随便想两个不超过 141414 的正整数，填在前两个格子，不要给我看到。” （ta 填入141414 和 666。当然，你看不到 ta 填了什么） “填好了吗？然后从第三个格子到第九个格子，每个格子都是前两个格子的和，把它们也填进去。” （如上） “你的第九个格子是多少？” “308。” （计算 308⋅ϕ≈498308\\cdot\\phi\\approx498308⋅ϕ≈498） “第十个格子是 498。” “哇好厉害，你怎么知道的？！” ","link":"https://zihim.me/post/cDaTnNV6x/"},{"title":"[研究] x^a+y^b=z^c 的求解","content":"前几天看《思考的乐趣》，发现这么一道有趣的题： 证明或推翻：x3+y4=z5x^3+y^4=z^5x3+y4=z5 没有正整数解。 然而答案只有一句话： 原命题是错误的。由于 224+224=2252^{24}+2^{24}=2^{25}224+224=225，因此 (28)3+(26)4=(25)5(2^8)^3+(2^6)^4=(2^5)^5(28)3+(26)4=(25)5。 我于是想到，可以用类似的方法找到 xa+yb=zc (a,b,c为常数且为正整数)x^a+y^b=z^c\\ \\ (a,b,c为常数且为正整数)xa+yb=zc (a,b,c为常数且为正整数) 的正整数解。经过不懈努力，我得出了一条结论： 若 [a,b][a,b][a,b] 与 ccc 互质，则 xa+yb=zcx^a+y^b=z^cxa+yb=zc 必定有正整数解。 注：[a,b][a,b][a,b] 指 aaa 和 bbb 的最小公倍数。 思考过程 （为了方便阅读，除引用原书中的句子，我将常数 a,b,c\\rm a,b,ca,b,c 标为正体，变量标为斜体） 根据原题，题目可以化为： (2A)a+(2B)b=(2C)c\\begin{aligned} {(2^A)}^{\\rm a}+(2^B)^{\\rm b}&amp;=(2^C)^{\\rm c} \\end{aligned} (2A)a+(2B)b​=(2C)c​ 并且满足 Aa=BbA{\\rm a}=B{\\rm b}Aa=Bb。它有无数组解，只需要使 A=[a,b]ag,B=[a,b]bgA=\\dfrac{\\rm[a,b]}{\\rm a}g,B=\\dfrac{\\rm [a,b]}{\\rm b}gA=a[a,b]​g,B=b[a,b]​g 即可（ggg 为任意整数）。 将 AAA 和 BBB 代回原方程，我们可以得到一个不定方程： [a,b]g+1=CccC+(−[a,b])g=1\\begin{aligned} {\\rm[a,b]}g+1&amp;=C{\\rm c}\\\\ {\\rm c}C+{\\rm(-[a,b])}g&amp;=1\\\\ \\end{aligned} [a,b]g+1cC+(−[a,b])g​=Cc=1​ 因为没有系统学习过不定方程的知识，不过最后还是在单樽教授的《奥数教程》七年级第七版的第 26 讲中找到了答案。里面介绍了一个定理： 整系数方程 ax+by=cax+by=cax+by=c 有整数解的充分并且必要条件是 aaa 与 bbb 的最大公约数 ddd 能整除 ccc。 因此，在上面的方程中，只要 (−[a,b])\\rm(-[a,b])(−[a,b]) 和 c\\rm cc 的最大公约数能整除 111 时，方程有解。而什么数字能整除 111 呢？答案是：只有 111 能整除 111。那么只要 (−[a,b])\\rm(-[a,b])(−[a,b]) 和 c\\rm cc 的最大公约数为 111 时，方程有解。另外注意，求最大公约数时，将数字取绝对值并不会影响结果，因此：当 [a,b]\\rm [a,b][a,b] 和 c\\rm cc 互质时，方程一定有解。 但是，有解并不代表着有正整数解。于是我又在书中找到第二个定理： 若 aaa 和 bbb 的最大公因数为 111（即 aaa 和 bbb 互质），x0,y0x_0,y_0x0​,y0​ 为二元一次整系数不定方程 ax+by=cax+by=cax+by=c 的一组整数解（也称为「特解」），则 ax+by=cax+by=cax+by=c 的所有整数解（也称「通解」）为： {x=x0+bky=y0−ak(k为任意整数)\\left \\{ \\begin{aligned} x&amp;=x_0+bk\\\\ y&amp;=y_0-ak\\\\ \\end{aligned} \\quad(k为任意整数) \\right . {xy​=x0​+bk=y0​−ak​(k为任意整数) 如果我们找到 g0g_0g0​ 和 C0C_0C0​，那么通解就是： {g=g0+ckC=C0−(−[a,b])k=C0+[a,b]k(k为任意整数)\\left \\{ \\begin{aligned} g&amp;=g_0+{\\rm c}k\\\\ C&amp;=C_0-{\\rm(-[a,b])}k=C_0+{\\rm[a,b]}k\\\\ \\end{aligned} \\quad(k为任意整数) \\right . {gC​=g0​+ck=C0​−(−[a,b])k=C0​+[a,b]k​(k为任意整数) 可以看到，只要 kkk 的值足够大， 就一定能找到一组正整数的解。 具体证明 ∵[a,b]\\because[a,b]∵[a,b] 与 ccc 互质 ∴cC+(−[a,b])g=1\\therefore{\\rm c}C+{\\rm(-[a,b])}g=1∴cC+(−[a,b])g=1 必有整数解 设 g0,C0g_0,C_0g0​,C0​ 为 cC+(−[a,b])g=1{\\rm c}C+{\\rm(-[a,b])}g=1cC+(−[a,b])g=1 的特解，则其通解为 {g=g0+ckC=C0+[a,b]k(k为任意整数)\\left \\{ \\begin{aligned} g&amp;=g_0+{\\rm c}k\\\\ C&amp;=C_0+{\\rm[a,b]}k\\\\ \\end{aligned} \\quad(k为任意整数) \\right . {gC​=g0​+ck=C0​+[a,b]k​(k为任意整数) 当 kkk 足够大时，必然存在 g,Cg,Cg,C 使得 g=g0+ck&gt;0g=g_0+{\\rm c}k&gt;0g=g0​+ck&gt;0 且 C=C0+[a,b]k&gt;0C=C_0+{\\rm[a,b]}k&gt;0C=C0​+[a,b]k&gt;0 ∴cC+(−[a,b])g=1\\therefore{\\rm c}C+{\\rm(-[a,b])}g=1∴cC+(−[a,b])g=1 必有正整数解 此时 (2[a,b]ag)a+(2[a,b]bg)b=(2C)c\\left({2}^{\\frac{[a,b]}{a}g}\\right)^a+\\left({2}^{\\frac{[a,b]}{b}g}\\right)^b=\\left({2}^C\\right)^c (2a[a,b]​g)a+(2b[a,b]​g)b=(2C)c 实战训练 题目 求不定方程 x7+y11=z13x^7+y^{11}=z^{13}x7+y11=z13 的一组正整数解。 答案 20487+12811=6413{2048}^{7}+{128}^{11}={64}^{13} 20487+12811=6413 过程 列出不定方程： cC+(−[a,b])g=113C−77g=1\\begin{aligned} {\\rm c}C+{\\rm(-[a,b])}g&amp;=1\\\\ 13C-77g&amp;=1 \\end{aligned} cC+(−[a,b])g13C−77g​=1=1​ 找到一组正整数解： {g=1C=6\\left \\{ \\begin{aligned} g&amp;=1\\\\ C&amp;=6 \\end{aligned} \\right . {gC​=1=6​ 因此： (2[a,b]ag)7+(2[a,b]bg)11=(2C)13(211×1)7+(27×1)11=(26)1320487+12811=6413\\begin{aligned} \\left({2}^{\\frac{[a,b]}{a}g}\\right)^{7}+\\left({2}^{\\frac{[a,b]}{b}g}\\right)^{11}&amp;=\\left({2}^C\\right)^{13}\\\\ \\left({2}^{11\\times1}\\right)^7+\\left({2}^{7\\times1}\\right)^{11}&amp;=\\left({2}^{6}\\right)^{13}\\\\ {2048}^{7}+{128}^{11}&amp;={64}^{13}\\\\ \\end{aligned} (2a[a,b]​g)7+(2b[a,b]​g)11(211×1)7+(27×1)1120487+12811​=(2C)13=(26)13=6413​ ","link":"https://zihim.me/post/SysPoHoUj/"},{"title":"[随笔] 2019秋：记一次研学活动","content":" ​ 这周三学校组织进行了一次研学活动。总的来说，可能是从出生以来是体验最好的一次吧。因为考虑到和男生一起走导致体验极差（走着走着突然说休息然后打游戏，而我本身是个不经常打游戏的人，浪费时间），于是找了 +c 和纬哥加入了女生的队伍。 前夕 ​ 晚修很长，作业很少。 ​ 第一节晚修把作业写完了，第二节课晚修没事干，于是准备专攻自己很讨厌的组合数学。有趣的是，被政治老师看到，然后她给我讲了一节课，听起来都是些高深的东西，反正没听懂。 ​ 可能是太兴奋了吧，也有可能我们都在熄灯后讨论明天的安排，晚上十点多才睡着。 今日 ​ 早上五点多，全宿舍都很早醒了。时间还早，就一起在讲鬼故事。 ​ 出了校门，登上大巴，找到位置，坐下。路途上没啥事情发生，只记得和 +c 一起刷「哔哩哔哩」，车内充满了快活的空气。 ​ 到了园区，在大门口，每人领一张卡，每次玩的时候都要刷一次，听说可以刷 100010001000 次。早上安排原本是解散的，然后下午集合去园区某处。但老师说先集合再解散，然后 15:30 集中在大门口。解散后直接被拉去鬼屋，感觉不是很可怕，但是我还是在里面高歌壮胆。 ​ 然后就到了吃饭时间，吃的是鸡腿白菜啥的，那个白菜挺好吃的。这是我人生中第一次感觉大白菜比鸡腿好吃。 ​ 吃完饭后玩过山车，我们三个男的太怂，不敢玩（另外 +c 的卡不见了），我们仨就坐在椅子上刷「哔哩哔哩」。也不知过了多久，yyx 先回来了，我才不会告诉你她是因为体重差 1kg 下来的。然后看到班主任和电脑老师也来排队，打了个招呼。后来我们仨和 yyx 一起玩换装游戏。另外 +c 在玩的时候遇见物理老师过来问在玩什么。 ​ 后来他们都下来了，然后又被拉去另一个鬼屋，遇到另一个组的人，他们还和门口的满脸是血的护士疯狂握手。进了鬼屋看了一个视频，全程闭眼听声音，似乎看到一个人把另一个人的心脏（好像是心脏）掏了出来。我怂得很，看完视频就和纬哥出来了，我们俩看着 +c 被女生拉进去。不过后来听说很假，那个尸体里面的棉花都漏出来了，RioBlu 去玩的时候还给地上的头盖骨踢了几米远，还对了上香台烧了香，有说有笑的。在出口等他们，很久没出来，于是和纬哥一起嗑瓜子。 ​ 等他们出来后就去玩大摆锤（因为我刚刚说宁愿去玩大摆锤也不去鬼屋），排队的时候嘴唇发白加腿抖。我还是比较勇敢的，最后还是硬着头皮就上去了。全程闭着眼，下来的时候脚都软了。 ​ 后来去玩碰碰车 还被 +c 带错三次路。途中还看见一只鸡在跑，很有农庄气息，还遇到了马户。先玩了两局，第一局坐副驾驶看着纬哥飙车，我仿佛可以听到我的脖子在说：“我已出舱，自我感觉良好！”第二局到我开，开始的时候方向盘不准，就一直和墙壁斗智斗勇，后来摸清方向了之后直接追着马户撞，后来我们几个把马户围在墙上撞。 ​ 后来又去了镜子迷宫，居然还要给一块钱买手套，做工极差，穿上去就烂了。纬哥的小学哥们说他们用了三十分钟才走出来。但是！凭着我们强烈的团队意识、敏锐的逻辑判断能力以及我们聪明绝顶的头脑，我们仅用了三分钟就走完了迷宫。 ​ 然后又去玩了飞椅，纬哥太怂，没敢玩。最后又玩了一次碰碰车，然后时间也差不多了，就跑去商店集合，途中发现有个工作人员拿着刚刚那只鸡往动物区走，在商店等了好久没有人，后来才发现是在大门口集合。 ​ 回来的时候和 +c 听歌，愉快的一天结束了。 ","link":"https://zihim.me/post/tLLsXq-JY/"},{"title":"[科普] 浅谈梯度下降法","content":"最近在搞手写数字的识别（好难啊QAQ）。 其中有个代码中重要的部分是梯度下降，这部分比较难理解，这里给大家介绍一下，顺便写一篇学习笔记吧。 Update 2025/02/18 阅前须知：作为鄙人刚上初二时写的一篇学习笔记（实际上从现在来看是一篇拙到不能再拙的拙文），这篇文章可能误导性极大且毫无专业性，并不适合用于学习来阅读，如果您坚持阅读，这可能浪费您人生中宝贵的十五分钟。 注意：本文所讲的梯度下降指的是批量梯度下降法（Batch gradient descent），简称BGD。 写在前面 为什么写这个 因为网上讲的过于深奥，对新手十分不友好（我用了差不多一个月才理解它，肯定是我太蒻了），目前我认为最好的文章就是这篇了。 另外，本文会用通俗简单的方式给大家呈现梯度下降法（因为要做到通俗，有时会把严谨忽略）。 梯度下降是什么，有什么用 度娘的解释： 梯度下降是迭代法的一种,可以用于求解最小二乘问题(线性和非线性都可以)。在求解机器学习算法的模型参数，即无约束优化问题时，梯度下降（Gradient Descent）是最常采用的方法之一，另一种常用的方法是最小二乘法。在求解损失函数的最小值时，可以通过梯度下降法来一步步的迭代求解，得到最小化的损失函数和模型参数值。反过来，如果我们需要求解损失函数的最大值，这时就需要用梯度上升法来迭代了。在机器学习中，基于基本的梯度下降法发展了两种梯度下降方法，分别为随机梯度下降法和批量梯度下降法。——百度百科 在3b1b3b1b3b1b中的解释： 它（梯度下降法）不仅是神经网络学习的基础，机器学习中很多其他的技术也是基于这种方法。——3Blue1Brown3Blue1Brown3Blue1Brown 别看这里有这么一堆东西，简单来说就是求一个多元函数的极值（最大值和最小值）。 这个算法在神经网络中是一个常用的算法。 什么是梯度下降 假如说，你在一座山上，需要尽快下山，但是此时浓雾很大，你看不到最低点，此时你的做法应该： A. 看脚下周围哪边陡，一直往陡的方向走 B. 一直往一个方向走 C. 看脚下周围哪边缓，一直往缓的方向走 如果你有亲身经历的话，那么是选A，但大多数人应该是没有的，我来解析一下： 首先你如果只往一个方向走的话，只有很少的概率能成功下山，有时还会走上一条上山的路。因此排除B。 其次，因为你往陡的地方走一步，很明显比往缓的地方走一步下降得快。所以选A。 而梯度下降法就是这个原理，走最陡的路~~，做不同的自己~~。 另外，如果是上山，也是类似的思路，往陡的地方上山，也可以以最快的速度到达最高点。 理解梯度下降 首先，你需要一些前置知识： 数学函数和计算机函数（想必大家应该都是懂的，这里直接放一个链接） 导数（如果你还是不懂，请看下面，如果你懂，可以选择跳过） 导数是什么 导数是函数的局部性质。一个函数在某一点的导数描述了这个函数在这一点附近的变化率。如果函数的自变量和取值都是实数的话，函数在某一点的导数就是该函数所代表的曲线在这一点上的切线斜率。导数的本质是通过极限的概念对函数进行局部的线性逼近。例如在运动学中，物体的位移对于时间的导数就是物体的瞬时速度。——百度百科 对于加粗字，我举一个例子： 例如f(x)=2f(x)=2f(x)=2，它的导数f′(x)=0f&#x27;(x)=0f′(x)=0，下面用一张图来解释一下： 你会发现，对于fff函数的yyy一直保持在222，既没有变大，也没有变小，那么对于f′f&#x27;f′就是一直保持在000（变大就会是正数，变小会是负数，如果不变就是000）。我们再看下面这个例子： f(x)=xf(x)=xf(x)=x，它的导数是f′(x)=1f&#x27;(x)=1f′(x)=1。 因为这条绿色的线是匀速增长的（每时每刻都以111的速度增长），因此它的导数一定是直的，又因为fff的增长率是111，因此它的导数都是111。 这两个例子告诉我们：某一点的导数是这一点的增长率（变化率）。 另外，对于其他复杂函数，你需要用到导数表，或者说下面会讲到一个万能公式（他抛弃了恶心的导数表）。 但是，假如你不知道原函数，要怎么求某一个点的导数呢？ 这时，我们需要用到函数的切线。 那，切线又是什么呢？ 切线就是正好碰到曲线某一点的直线。如果在某一点作了切线，那么这个点就叫作这条切线的切点。 刚开始，我一直不能理解，某个点的切线为什么一定要长那样子，而且为什么可以一个点确定一条直线，但后来，我去找了电脑老师（没错你没听错），他通俗的用几句话把它给描述清楚了： 把曲线无限放大 那么该点左右范围内，极小极小极小的一小段圆弧 就应该是一条直线 延长这条直线，就是该点的切线 当然，这里我放了一张gif，方便大家理解： 我这里虽然没有无限放大，但是在放大到一定时候，曲线就会近似于直线。 然后，我们知道切线是什么了，但是下一步要怎么做呢？ 我可以告诉你：某点的切线的斜率就是该点的导数！（上面百度百科也有提到） 那什么是斜率呢？ 某一条直线的斜率就是对于横坐标倾斜程度的量，我们通常用一条公式来表示以两个点（假设我们这里是AAA和BBB）构成的直线的斜率kkk： k=yB−yAxB−xAk=\\frac{y_B-y_A}{x_B-x_A} k=xB​−xA​yB​−yA​​ 或者说是直线与横轴相交所形成的夹角的正切值： k=tan⁡αk=\\tan\\alpha k=tanα 东西有点多啊，我们把这几个概念组合起来成为一句话吧： 函数的某个点的切线是一条直线，这条切线的斜率就是这个函数在这个点的导数。 如果说只给你一个点aaa，求函数f(x)f(x)f(x)在这个点的导数，而且你并不知道f(x)f(x)f(x)的表达式，用第二个公式会比较麻烦，相对来说第一个公式会比较简单。 但是，我们只有一个点啊！ 没事，我们只需要取两个点，使他们十分接近，然后再计算他们所构成的直线的斜率，就可以了。 假如说两个点的横坐标的差是ppp，那么套进式子： k=yB−yAxB−xAk=\\frac{y_B-y_A}{x_B-x_A} k=xB​−xA​yB​−yA​​ k≈f(a+p)−f(a)(a+p)−ak\\approx\\frac{f(a+p)-f(a)}{(a+p)-a} k≈(a+p)−af(a+p)−f(a)​ k≈f(a+p)−f(a)pk\\approx\\frac{f(a+p)-f(a)}{p} k≈pf(a+p)−f(a)​ 当ppp趋近于000，kkk的值就会越精确，即k=lim⁡p→0f(a+p)−f(a)pk=\\lim\\limits_{p\\to0}\\frac{f(a+p)-f(a)}{p}k=p→0lim​pf(a+p)−f(a)​。 记住这个公式！这个公式可以抛弃求导，因此我叫它万能公式。 Update 2019.12.31 感谢@锦依卫Lijilai 大佬和@EMT__Mashiro 大佬指出的错误，应为抛弃导数表。 记住这个公式！这个公式可以抛弃导数表，因此我叫它万能公式。 梯度是什么 梯度的本意是一个向量，表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向（此梯度的方向）变化最快，变化率最大（为该梯度的模）。——百度百科 向量又是个啥啊？ 向量代表着一个方向，它具有方向和大小，或者说你可以当它是具有方向的线段。（就类似于你在QQQQQQ截图里拉箭头那样） 梯度正好符合我们开头所讲的，使变化最快对应着下山要走最陡的地方变化才快。 记住，梯度是一个向量！（要考的） 开始理解梯度下降 这里是整个梯度下降的核心公式： new=old−α∇f(old)\\large new=old-\\alpha \\nabla f(old) new=old−α∇f(old) 主要意思是：新的坐标等于旧的坐标减去旧坐标的函数的梯度。 这就很符合上面我们所说的下山。你新的站立点是你旧的站立点减去你每步的长度乘上下山的方向。 这图画的什么意思啊？别急，继续往下看。 只要一直计算newnewnew的值，然后带进oldoldold再算出newnewnew的值，如此循环下去，newnewnew就会变成fff函数的最低点。 另外，在梯度下降刚开始时，我们可以随便找几个随机数作为初值，然后通过这些随机数去计算。 那里面的变量又代表什么意思呢？ newnewnew 这个newnewnew代表着一个新的坐标，但他不一定是一个平面上的坐标，也不一定是三维空间里的坐标，它是一个在nnn维空间里的坐标，其中，这个nnn的值是由fff函数的参数个数来决定的。 oldoldold 上面是新坐标，那么这就是一个旧坐标了。它也是一个在nnn维空间里的坐标，nnn的值也是由fff函数的参数个数确定的。 α\\alphaα 这是一个步长，或者说可以叫学习率，可以说是你下山的时候走一步的长度。它是控制下山的速度的，他必须不能太大，又不能太小，如果太大，你就会错过最低点（远离最优解），或者一直到达不了最低点；如果太小，你就会很久不能到达最低点（收敛慢）。 如果说α\\alphaα随下降次数而变小，那就更好了。 ∇f(old)\\nabla f(old)∇f(old) ∇\\nabla∇是梯度的意思，要记住这是一个向量，∇f(old)\\nabla f(old)∇f(old)代表fff的梯度，而−∇f(old)-\\nabla f(old)−∇f(old)是负梯度的意思，意味着我们需要下降。 如果我们要上升，就是+∇f(old)+\\nabla f(old)+∇f(old)。 然后，怎么求∇f(old)\\nabla f(old)∇f(old)呢？ 你需要先知道定义，∇f(a1,a2,…,an)=(∂f∂a1,∂f∂a2,…,∂f∂an)\\nabla f(a_1,a_2,\\dots,a_n)=(\\frac{\\partial f}{\\partial a_1},\\frac{\\partial f}{\\partial a_2},\\dots,\\frac{\\partial f}{\\partial a_n})∇f(a1​,a2​,…,an​)=(∂a1​∂f​,∂a2​∂f​,…,∂an​∂f​)。 然后，你肯定会说：这∂f∂a1\\frac{\\partial f}{\\partial a_1}∂a1​∂f​又是个啥啊？ ∂f∂a1\\frac{\\partial f}{\\partial a_1}∂a1​∂f​是函数fff对变量a1a_1a1​的偏导数。 偏导数又是啥？ 偏导数指把某个函数里非某个变量的其他变量当做常数，然后再对这个函数求导。 它表示为∂函数∂变量\\frac{\\partial \\text{函数}}{\\partial \\text{变量}}∂变量∂函数​。例如 ∂f∂a1\\frac{\\partial f}{\\partial a_1}∂a1​∂f​意味着，把函数fff里的其他变量（除a1a_1a1​外的变量）当做常数，然后再对函数求导。 如果你还不能明白，我再举一个例子： 假如有这么一个函数： f(x,y,z)=x2+5xy+z3f(x,y,z)=x^2+5xy+z^3 f(x,y,z)=x2+5xy+z3 所以： ∂f∂x=∂∂x(x2)+∂∂x(5xy)+∂∂x(z3)\\frac{\\partial f}{\\partial x}=\\frac{\\partial}{\\partial x}(x^2)+\\frac{\\partial}{\\partial x}(5xy)+\\frac{\\partial}{\\partial x}(z^3) ∂x∂f​=∂x∂​(x2)+∂x∂​(5xy)+∂x∂​(z3) 此时x2x^2x2的导数是2x2x2x；yyy是常数，通过公式f(x)=Cx,f′(x)=Cf(x)=Cx,f&#x27;(x)=Cf(x)=Cx,f′(x)=C可以得出∂∂x(5xy)=5y\\frac{\\partial}{\\partial x}(5xy)=5y∂x∂​(5xy)=5y；z3z^3z3是常数，常数的导数是000。 所以得出： ∂f∂x=∂∂x(x2)+∂∂x(5xy)+∂∂x(z3)=2x+5y+0=2x+5y\\frac{\\partial f}{\\partial x}=\\frac{\\partial}{\\partial x}(x^2)+\\frac{\\partial}{\\partial x}(5xy)+\\frac{\\partial}{\\partial x}(z^3)=2x+5y+0=2x+5y ∂x∂f​=∂x∂​(x2)+∂x∂​(5xy)+∂x∂​(z3)=2x+5y+0=2x+5y 同理可得： ∂f∂y=∂∂y(x2)+∂∂y(5xy)+∂∂y(z3)=0+5x+0=5x\\frac{\\partial f}{\\partial y}=\\frac{\\partial}{\\partial y}(x^2)+\\frac{\\partial}{\\partial y}(5xy)+\\frac{\\partial}{\\partial y}(z^3)=0+5x+0=5x ∂y∂f​=∂y∂​(x2)+∂y∂​(5xy)+∂y∂​(z3)=0+5x+0=5x ∂f∂z=∂∂z(x2)+∂∂z(5xy)+∂∂z(z3)=0+0+3z2=3z2\\frac{\\partial f}{\\partial z}=\\frac{\\partial}{\\partial z}(x^2)+\\frac{\\partial}{\\partial z}(5xy)+\\frac{\\partial}{\\partial z}(z^3)=0+0+3z^2=3z^2 ∂z∂f​=∂z∂​(x2)+∂z∂​(5xy)+∂z∂​(z3)=0+0+3z2=3z2 所以 ∇f(x,y,z)=(∂f∂x,∂f∂y,∂f∂z)=(2x+5y,5x,3z2)\\nabla f(x,y,z)=(\\frac{\\partial f}{\\partial x},\\frac{\\partial f}{\\partial y},\\frac{\\partial f}{\\partial z})=(2x+5y,5x,3z^2) ∇f(x,y,z)=(∂x∂f​,∂y∂f​,∂z∂f​)=(2x+5y,5x,3z2) 实战问题 让我们来做几道练习题： 入门难度 使用梯度下降法求x2x^2x2最小时的xxx值。 首先已知： f(x)=x2f(x)=x^2 f(x)=x2 所以： ∇f(x)=∂f∂x=2x\\nabla f(x)=\\frac{\\partial f}{\\partial x}=2x ∇f(x)=∂x∂f​=2x 假如我们这里α=0.4\\alpha=0.4α=0.4，那么公式new=old−α∇f(old)new=old-\\alpha \\nabla f(old)new=old−α∇f(old)变成xnew=xold−0.4×2xoldx_{new}=x_{old}-0.4\\times2x_{old}xnew​=xold​−0.4×2xold​。 初始值为x=10x=10x=10。（可以是其他） x0=10−0.8×10=2x_0=10-0.8\\times10=2 x0​=10−0.8×10=2 x1=x0−0.8×x0=0.4x_1=x_0-0.8\\times x_0=0.4 x1​=x0​−0.8×x0​=0.4 x2=x1−0.8×x1=0.08x_2=x_1-0.8\\times x_1=0.08 x2​=x1​−0.8×x1​=0.08 …\\dots … x20=x19−0.8×x19=2.1×10−14x_{20}=x_{19}-0.8\\times x_{19}=2.1\\times10^{-14} x20​=x19​−0.8×x19​=2.1×10−14 当迭代次数越多，xxx就会趋近于000。 因此我们得知，最小值是x=0x=0x=0。 但是这个很明显可以看出来，下面我们来试两个变量时的情况。 普及+/提高 使用梯度下降法求x2+(y−1)2+1x^2+(y-1)^2+1x2+(y−1)2+1最小时的x,yx,yx,y值。 已知： f(x,y)=x2+(y−1)2+1f(x,y)=x^2+(y-1)^2+1 f(x,y)=x2+(y−1)2+1 所以： ∂f∂x=2x\\frac{\\partial f}{\\partial x}=2x ∂x∂f​=2x ∂f∂y=2(y−1)\\frac{\\partial f}{\\partial y}=2(y-1) ∂y∂f​=2(y−1) 所以： ∇f(x,y)=(∂f∂x,∂f∂y)=(2x,2(y−1))\\nabla f(x,y)=(\\frac{\\partial f}{\\partial x},\\frac{\\partial f}{\\partial y})=(2x,2(y-1)) ∇f(x,y)=(∂x∂f​,∂y∂f​)=(2x,2(y−1)) 然后，要怎么相减呢？ 其实很简单，例如(1,2)−(1.2,0.5)(1,2)-(1.2,0.5)(1,2)−(1.2,0.5)就是分别相减，即(1−1.2,2−0.5)=(−0.2,1.5)(1-1.2,2-0.5)=(-0.2,1.5)(1−1.2,2−0.5)=(−0.2,1.5)。 那么，开始计算了。（α=0.2,(x,y)=(10,10)\\alpha=0.2,(x,y)=(10,10)α=0.2,(x,y)=(10,10)） 由于我太懒了，直接贴代码吧： C++代码： #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ double x=10,y=10,st=0.2;//初始化 for(int i=0;i&lt;51;i++){//随便迭代个51次 x=x-st*2*x;//核心 y=y-st*2*(y-1);//核心 printf(&quot;%.10lf %.10lf\\n&quot;,x,y); } } 最后(x,y)(x,y)(x,y)会趋近于(0,1)(0,1)(0,1)。 但是这并没有体现到梯度下降法的强大，因为只要你知道原函数，你一般都可以推导出最小值，来，我们来看一下终极之题。 NOI/NOI+/CTSC 已知f(x)f(x)f(x)，用梯度下降法求f(x)f(x)f(x)在最低点的xxx值。 你可能会说：它连原函数表达式都不给我，怎么做啊（翻盘）？ 还记得我们在上面讲导数的时候提到过： 假如你不知道原函数，要怎么求某一个点的导数呢？ 而我们用的方法是求切线斜率。 那时，我们推导出一个万能公式： f′(a)≈f(a+p)−f(a)pf&#x27;(a)\\approx\\frac{f(a+p)-f(a)}{p} f′(a)≈pf(a+p)−f(a)​ 其中ppp是一个常数，越趋近于000越好。 于是， ∇f(x)=∂f∂x=f′(x)≈f(x+p)−f(x)p\\nabla f(x)=\\frac{\\partial f}{\\partial x}=f&#x27;(x)\\approx\\frac{f(x+p)-f(x)}{p} ∇f(x)=∂x∂f​=f′(x)≈pf(x+p)−f(x)​ 所以我们计算xnew=xold−αf(xold+p)−f(xold)p\\large x_{new}=x_{old}-\\alpha\\frac{f(x_{old}+p)-f(x_{old})}{p}xnew​=xold​−αpf(xold​+p)−f(xold​)​即可。 伪代码（没有f(x)f(x)f(x)）： #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ double x=10,st=0.2,p=1e-5;//初始化 for(int i=0;i&lt;51;i++){ x=x-st*(f(x+p)-f(x))/p;//套入公式 printf(&quot;%.10lf\\n&quot;,x); } } 这样做的好处有什么？ 对所有函数通用，无需求导数，只要它能给你返回函数值，无论是返回n\\sqrt{n}n​还是地球在赤道和经度n∘n^\\circn∘的海平面高度（这个不能推导出函数表达式），它都可以解决。 但是也有一个不足的地方，可能会有误差。 另外，如果fff里的变量多起来，或者调用一次fff函数比较耗时的话，速度会降低。（神经网络就是这样，变量又多，调用又耗时） 同时，如果有多个变量，也是一样的，只要将代码中的： x=x-st*(f(x+p)-f(x))/p; 变成 x1=x1-st*(f(x1+p,x2,x3,...,xn)-f(x1,x2,x3,...,xn))/p; x2=x2-st*(f(x1,x2+p,x3,...,xn)-f(x1,x2,x3,...,xn))/p; x3=x3-st*(f(x1,x2,x3+p,...,xn)-f(x1,x2,x3,...,xn))/p; ... xn=xn-st*(f(x1,x2,x3,...,xn+p)-f(x1,x2,x3,...,xn))/p; 即可。 什么？你说你是PPP党？看不懂C++C++C++代码？ 那我就用数学符号表示吧（前方高能）： 例如有一个多个变量的函数f(x,y,z)f(x,y,z)f(x,y,z)，那么： ∇f(x,y,z)=(∂f∂x,∂f∂y,∂f∂z)\\nabla f(x,y,z)=(\\frac{\\partial f}{\\partial x},\\frac{\\partial f}{\\partial y},\\frac{\\partial f}{\\partial z}) ∇f(x,y,z)=(∂x∂f​,∂y∂f​,∂z∂f​) =lim⁡p→0(f(x+p,y,z)−f(x,y,z)p,f(x,y+p,z)−f(x,y,z)p,f(x,y,z+p)−f(x,y,z)p)=\\lim\\limits_{p\\to0}(\\frac{f(x+p,y,z)-f(x,y,z)}{p},\\frac{f(x,y+p,z)-f(x,y,z)}{p},\\frac{f(x,y,z+p)-f(x,y,z)}{p}) =p→0lim​(pf(x+p,y,z)−f(x,y,z)​,pf(x,y+p,z)−f(x,y,z)​,pf(x,y,z+p)−f(x,y,z)​) 有没有一种要晕了的感觉？ 总结 重温一下 梯度下降是求一个多元函数的极值（最大值和最小值）的算法。 它对于所有可求导函数都适用。 核心公式： new=old−α∇f(old)\\large new=old-\\alpha \\nabla f(old) new=old−α∇f(old) 主要步骤： 对原函数求导。 设定初值a1,a2…a_1,a_2\\dotsa1​,a2​…（以函数参数个数决定），学习率α\\alphaα（和切线斜率精度ppp，如果你能对函数求导，那就不需要设置这个了）。 设置迭代次数iii。 开始下降（套入核心公式）。 最后讲一下时间复杂度：O(nm)O(nm)O(nm)（nnn指函数的变量个数，mmm指的是迭代次数） 如果是上面的那个“万能方法”，则可能会更耗时一点，具体看函数调用一次的时间。 空间复杂度O(n)O(n)O(n)（nnn指函数的变量个数）。 优点： 迭代次数少。（因为走的方向很精准） 总能达到最优解，若为凸函数，保证得到最优解。 缺点： 计算量大。（每次下降的时间是O(n)O(n)O(n)） 有点耗内存。 不同的初值可能会得到不同的结果。（凸函数除外） 拓展 因为BGDBGDBGD需要计算所有变量的导数，因此速度会比较慢。 所以人们想出了一个想法： 每次只计算一个变量的导数，然后把迭代次数大大增加，至于是哪个变量可以用随机数或者循环。 那么时间复杂度就变成O(m)O(m)O(m)。 这个算法叫做随机梯度下降法（Stochastic Gradient Descent），简称SGDSGDSGD。 尽管SGDSGDSGD的迭代次数比BGDBGDBGD大很多，但一次迭代的时间非常快。 限于篇幅问题，这里不展开细说，原理与BGDBGDBGD是相似的。 它的优点有： 速度要比BGDBGDBGD快得多 好像没有了 缺点： 迭代次数多 容易卡bugbugbug，例如卡在函数的鞍点（即一个方向看这个点是最小值，另一个方向看是最大值，如下图，只看红色的线） （图源此处） ","link":"https://zihim.me/post/9hi-1e_JLX/"},{"title":"[研究] 开根号公式","content":"十分抱歉，上周发烧了，没有写博客。 今天来讲一下我发现的一个开根号公式 n=am+bn=a^m+b n=am+b nm≈a+bmam−1\\sqrt[m]{n}\\approx a+\\frac{b}{ma^{m-1}} mn​≈a+mam−1b​ 其中∣b∣|b|∣b∣越小越好 灵感来源 某一天做练习册的时候看到某道题估算某个数的平方根： n=a2+bn=a^2+bn=a2+b 假设n=a+x(0&lt;x&lt;1)\\sqrt{n}=a+x(0&lt;x&lt;1)n​=a+x(0&lt;x&lt;1) n=(a+x)2n=(a+x)^2n=(a+x)2 n=a2+2ax+x2n=a^2+2ax+x^2n=a2+2ax+x2 因为x2x^2x2太小我们直接扔掉，原式变成 x=b2ax=\\frac{b}{2a}x=2ab​ 所以n≈a+b2a\\sqrt{n}\\approx a+\\frac{b}{2a}n​≈a+2ab​ 所以就想用类似的方法求nm\\sqrt[m]{n}mn​。 举个栗子 例如说我们要算3\\sqrt{3}3​ 然后我们知道3=22+(−1)3=2^2+(-1)3=22+(−1) 所以3≈2+−12×2=1.75\\sqrt{3}\\approx 2+\\frac{-1}{2\\times2}=1.753​≈2+2×2−1​=1.75 但假如我们数字再大一点，会怎么样呢？ 10001=1002+1,10001≈100+12×100=100.00510001=100^2+1,\\sqrt{10001}\\approx100+\\frac{1}{2\\times100}=100.00510001=1002+1,10001​≈100+2×1001​=100.005 这已经很接近了！10001=100.004999875…\\sqrt{10001}=100.004999875\\dots10001​=100.004999875…，这个公式得到的值准确率有99.999999875%99.999999875\\%99.999999875% 假如我们试一下求2100\\sqrt[100]{2}1002​的值：2=1100+1,2100≈1+1100×199=1.012=1^{100}+1,\\sqrt[100]{2}\\approx1+\\frac{1}{100\\times1^{99}}=1.012=1100+1,1002​≈1+100×1991​=1.01，而2100=1.00695…\\sqrt[100]{2}=1.00695\\dots1002​=1.00695…，准确率有99.698%99.698\\%99.698% 所以我们可以总结出这个公式的优缺点： 开方数越大越精确 mmm越大会越不精确（除非开方数大） 推导 其实推导也不难，只是纯粹的杨辉三角罢了 假设n=am+bn=a^m+bn=am+b并且nm=a+x(x&lt;1)\\sqrt[m]{n}=a+x(x&lt;1)mn​=a+x(x&lt;1) ∴n=(a+x)m\\therefore n=(a+x)^m∴n=(a+x)m n=am+mam−1x+⋯+maxm−1+xmn=a^m+ma^{m-1}x+\\dots+max^{m-1}+x^mn=am+mam−1x+⋯+maxm−1+xm 此时，我们可以将省略号全部去掉（因为这部分比较难计算），并且把xmx^mxm去掉（因为这部分太小了） 所以原本的式子就变成了 n=am+max(am−2+xm−2)n=a^m+max(a^{m-2}+x^{m-2}) n=am+max(am−2+xm−2) b=max(am−2+xm−2)b=max(a^{m-2}+x^{m-2}) b=max(am−2+xm−2) bma=x(am−2+xm−2)\\frac{b}{ma}=x(a^{m-2}+x^{m-2}) mab​=x(am−2+xm−2) bma=xam−2+xm−1\\frac{b}{ma}=xa^{m-2}+x^{m-1} mab​=xam−2+xm−1 然后因为xm−1x^{m-1}xm−1也很小，那么也扔掉，最后 bma=xam−2\\frac{b}{ma}=xa^{m-2} mab​=xam−2 x=bmam−1x=\\frac{b}{ma^{m-1}} x=mam−1b​ 所以 nm=a+x\\sqrt[m]{n}=a+x mn​=a+x nm=a+bmam−1\\sqrt[m]{n}=a+\\frac{b}{ma^{m-1}} mn​=a+mam−1b​ Update Update 2019.10.4 十分感谢@jacky567 给出了一个改进后的方法。 当我们算出a+bmam−1a+\\frac{b}{ma^{m-1}}a+mam−1b​后，他已经接近nm\\sqrt[m]{n}mn​了。 因为我们说了，∣b∣|b|∣b∣越小越好，那么a+bmam−1a+\\frac{b}{ma^{m-1}}a+mam−1b​代入公式中的aaa，那么bbb就会更小，这时我们再迭代计算一遍，这个值就会更接近于nm\\sqrt[m]{n}mn​。 举个例子2\\sqrt{2}2​： 2=12+1,2≈1+12=1.52=1^2+1,\\sqrt{2}\\approx1+\\frac{1}{2}=1.5 2=12+1,2​≈1+21​=1.5 2=(1.5)2+(−0.25),2≈1.5+−0.253=1712=1.416˙2=(1.5)^2+(-0.25),\\sqrt{2}\\approx1.5+\\frac{-0.25}{3}=\\frac{17}{12}=1.41\\dot6 2=(1.5)2+(−0.25),2​≈1.5+3−0.25​=1217​=1.416˙ 2=(1712)2+(−1144),2≈1712−1408=577408=1.4142˙156862745098039˙2=(\\frac{17}{12})^2+(-\\frac{1}{144}),\\sqrt{2}\\approx\\frac{17}{12}-\\frac{1}{408}=\\frac{577}{408}=1.414\\dot215686274509803\\dot9 2=(1217​)2+(−1441​),2​≈1217​−4081​=408577​=1.4142˙156862745098039˙ …\\dots … 以此类推，你会发现他的精确度越来越高。（94.2809%→99.8268%→99.9998%94.2809\\%\\to99.8268\\%\\to99.9998\\%94.2809%→99.8268%→99.9998%） 那么只要你一直算下去，他就会更接近于2\\sqrt{2}2​。 其他开根号的方法 有牛顿迭代法、手算（夹逼法？）、无穷连分数近似法、以及一种神奇的开平方根的卡马克开方法，但是卡马克开方法只适用于计算机（如果是人算就算了吧）。 这些以后有时间再讲（又开了一个新坑） ","link":"https://zihim.me/post/S8bMkIxvto/"},{"title":"[研究] 勾股数面积","content":"前几天刚学勾股定理（说实在小学就会了），然后又见到了勾股树，于是研究了一下。 勾股树怎么画 方法比较简单： 画一个正方形。 在正方形上面紧贴画一个斜边为正方形边长的直角三角形（直角边自定），建议利用圆周角定理。 在直角三角形的两条直角边上各画一个正方形。 重复步骤2,32,32,3。记得每次画的直角三角形要与第一次画的三角形成比例。 如果你希望画出上面这种图，建议还是用几何画板迭代，百度上有很多的教程：戳我。 勾股树的性质 最基本的就是勾股定理了，上面两个正方形的面积和等于下面正方形的面积。 在一些题目中也会求树梢的面积和，例如下面： 已知AB=6AB=6AB=6，求S4+S5+S6+S7S4+S5+S6+S7S4+S5+S6+S7的和。 我们只需要记住一个公式，假如S4,S5,S6,S7S4,S5,S6,S7S4,S5,S6,S7属于第三层，S2,S3S2,S3S2,S3属于第二层，S1S1S1属于第一层，那么： 第nnn层正方形面积总和===第(n−1)(n-1)(n−1)层正方形面积总和=⋯==\\dots==⋯=第111层正方形面积总和。 也就是说，S4+S5+S6+S7=S2+S3=S1S4+S5+S6+S7=S2+S3=S1S4+S5+S6+S7=S2+S3=S1。 问题迎刃解决。但这是为什么呢？ 因为根据勾股定理，S4+S5=S2S4+S5=S2S4+S5=S2，S6+S7=S3S6+S7=S3S6+S7=S3，并且S2+S3=S1S2+S3=S1S2+S3=S1，那么S4+S5+S6+S7=S2+S3=S1S4+S5+S6+S7=S2+S3=S1S4+S5+S6+S7=S2+S3=S1。 这是我们便能推导出一个结论： 勾股树迭代无限次，面积会发散 很多人都会以为勾股树循环迭代，面积总是有限的，但是这只是表面上的，实际上，有许多面积被覆盖在一起。 因为刚刚说过，一层的面积他就等于最大的正方形的面积。 而我们每迭代一次，层数就会多一层。 也就是说每迭代一次总面积就加上最大的正方形的面积。 而如果迭代无限次，那么就相当于有无穷个正方形的面积相加，那么他就会发散。 求勾股树面积 三角形三边分别为a,b,ca,b,ca,b,c（ccc是直角边），迭代nnn层，那么如何求它的面积呢？ 我们在上面已经知道了，迭代nnn层，所有正方形的面积就等于(n+1)c2(n+1)c^2(n+1)c2。 但是，我们还需要求出三角形的面积，这要怎么求呢。 可以联想到，上面的两个三角形的面积和等于下面三角形的面积。 我们用比例来证明它。 ∵FE:BC=ED:AB\\because FE:BC=ED:AB∵FE:BC=ED:AB BC×ED=FE×ABBC\\times ED=FE\\times ABBC×ED=FE×AB ∴FE=BC×EDAB\\therefore FE=\\frac{BC\\times ED}{AB}∴FE=ABBC×ED​ 又∵FD:AC=ED:AB\\because FD:AC=ED:AB∵FD:AC=ED:AB AC×ED=FD×ABAC\\times ED=FD\\times ABAC×ED=FD×AB ∴FD=AC×EDAB\\therefore FD=\\frac{AC\\times ED}{AB}∴FD=ABAC×ED​ ∴S△FED=FE×FD2=BC×EDAB×AC×EDAB2=BC×AC×(EDAB)22=S△ABC×(EDAB)2=S△ABC×(BCAB)2\\therefore S_{\\triangle FED}=\\frac{FE\\times FD}2=\\frac{\\frac{BC\\times ED}{AB}\\times\\frac{AC\\times ED}{AB}}2=\\frac{BC\\times AC\\times(\\frac{ED}{AB})^2}2=S_{\\triangle ABC}\\times(\\frac{ED}{AB})^2=S_{\\triangle ABC}\\times(\\frac{BC}{AB})^2∴S△FED​=2FE×FD​=2ABBC×ED​×ABAC×ED​​=2BC×AC×(ABED​)2​=S△ABC​×(ABED​)2=S△ABC​×(ABBC​)2 同理可得S△HIG=S△ABC×(HGAB)2=S△ABC×(ACAB)2S_{\\triangle HIG}=S_{\\triangle ABC}\\times(\\frac{HG}{AB})^2=S_{\\triangle ABC}\\times(\\frac{AC}{AB})^2S△HIG​=S△ABC​×(ABHG​)2=S△ABC​×(ABAC​)2 ∴S△FED+S△HIG=S△ABC×(BCAB)2+S△ABC×(ACAB)2\\therefore S_{\\triangle FED}+S_{\\triangle HIG}=S_{\\triangle ABC}\\times(\\frac{BC}{AB})^2+S_{\\triangle ABC}\\times(\\frac{AC}{AB})^2∴S△FED​+S△HIG​=S△ABC​×(ABBC​)2+S△ABC​×(ABAC​)2 =S△ABC×(BC2AB2+AC2AB2)=S_{\\triangle ABC}\\times(\\frac{BC^2}{AB^2}+\\frac{AC^2}{AB^2})=S△ABC​×(AB2BC2​+AB2AC2​) =S△ABC×(BC2+AC2AB2)=S_{\\triangle ABC}\\times(\\frac{BC^2+AC^2}{AB^2})=S△ABC​×(AB2BC2+AC2​) =S△ABC×(AB2AB2)=S_{\\triangle ABC}\\times(\\frac{AB^2}{AB^2})=S△ABC​×(AB2AB2​) =S△ABC=S_{\\triangle ABC}=S△ABC​ 所以，我们的猜想是正确的！ 那么问题就简单了，每迭代一层，那层三角形的面积总和就是最大三角形的面积！ 也就是说，迭代nnn层，三角形的面积增多ab2×n\\frac{ab}{2}\\times n2ab​×n 综合起来，我们得到下面这么个公式： 三角形三边分别为a,b,ca,b,ca,b,c（ccc是直角边），迭代nnn层，它的面积是(n+1)c2+abn2(n+1)c^2+\\frac{abn}{2}(n+1)c2+2abn​ ","link":"https://zihim.me/post/78q2lY6Ho6/"},{"title":"[研究] 由无限连分数引发的悖论","content":"看 Mathologer 的一期视频有感，在此做研究。 1=23−1=23−23−1=23−23−23−…2=23−2=23−23−2=23−23−23−…}⇒1=2\\left. \\begin{aligned} 1=\\dfrac{2}{3-1}=\\dfrac{2}{3-\\dfrac{2}{3-1}}=\\dfrac{2}{3-\\dfrac{2}{3-\\dfrac{2}{3-\\dots}}}\\\\ 2=\\dfrac{2}{3-2}=\\dfrac{2}{3-\\dfrac{2}{3-2}}=\\dfrac{2}{3-\\dfrac{2}{3-\\dfrac{2}{3-\\dots}}}\\\\ \\end{aligned} \\right\\}\\Rightarrow\\boxed{1=2} 1=3−12​=3−3−12​2​=3−3−3−…2​2​2​2=3−22​=3−3−22​2​=3−3−3−…2​2​2​​⎭⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎬⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎫​⇒1=2​ 1=21=21=2？这怎么可能？然而视频也没有解释，而是卖了个关子。 在评论区很多都是说类似于「有理数不能表示成无限连分数的形式」的解释，但是只要 aaa 和 bbb 是实数，用同样的伎俩： a=aba+b−a=aba+b−aba+b−a=aba+b−aba+b−aba+b−…b=aba+b−b=aba+b−aba+b−b=aba+b−aba+b−aba+b−…}⇒a=b\\left. \\begin{aligned} a=\\dfrac{ab}{a+b-a}=\\dfrac{ab}{a+b-\\dfrac{ab}{a+b-a}}=\\dfrac{ab}{a+b-\\dfrac{ab}{a+b-\\dfrac{ab}{a+b-\\dots}}}\\\\ b=\\dfrac{ab}{a+b-b}=\\dfrac{ab}{a+b-\\dfrac{ab}{a+b-b}}=\\dfrac{ab}{a+b-\\dfrac{ab}{a+b-\\dfrac{ab}{a+b-\\dots}}} \\end{aligned} \\right\\}\\Rightarrow\\boxed{a=b} a=a+b−aab​=a+b−a+b−aab​ab​=a+b−a+b−a+b−…ab​ab​ab​b=a+b−bab​=a+b−a+b−bab​ab​=a+b−a+b−a+b−…ab​ab​ab​​⎭⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎬⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎫​⇒a=b​ 那么我们要怎么推翻它呢，当然是找出它的解了。 考虑到式子中包含本身，我们不妨设 g=aba+b−aba+b−aba+b−…g=\\dfrac{ab}{a+b-\\dfrac{ab}{a+b-\\dfrac{ab}{a+b-\\dots}}}g=a+b−a+b−a+b−…ab​ab​ab​，因此： g=aba+b−gg(a+b−g)=ab(−1)g2+(a+b)g+(−ab)=0g=−(a+b)±(a+b)2−4×(−1)×(−ab)2×(−1)g1=a , g2=b\\begin{aligned} g&amp;=\\dfrac{ab}{a+b-g}\\\\ g(a+b-g)&amp;=ab\\\\ (-1)g^2+(a+b)g+(-ab)&amp;=0\\\\ g&amp;=\\dfrac{-(a+b)\\pm\\sqrt{(a+b)^2-4\\times(-1)\\times(-ab)}}{2\\times(-1)}\\\\ g_1=a\\ &amp;,\\ g_2=b\\\\ \\end{aligned} gg(a+b−g)(−1)g2+(a+b)g+(−ab)gg1​=a ​=a+b−gab​=ab=0=2×(−1)−(a+b)±(a+b)2−4×(−1)×(−ab)​​, g2​=b​ 因此真相就水落石出了。 原式子是一个二次方程，因此有它两个解，我们将这两个解误认为是一个解，于是就认为他们相等。就像下面的「证明」： ∵(+2)2=4 , (−2)2=4∴(+2)=(−2)\\begin{aligned} &amp;\\because(+2)^2=4\\ ,\\ (-2)^2=4\\\\ &amp;\\therefore(+2)=(-2) \\end{aligned} ​∵(+2)2=4 , (−2)2=4∴(+2)=(−2)​ ","link":"https://zihim.me/post/62QaZTt4t/"},{"title":"[科普] 数字黑洞：从计数的智慧到数字根","content":"下面的内容主要来源于 Matrix67 博客内一篇文章。 文章内有这么一句话： 不断取数字英文表达的字符数，最后总会得到数字 444。 以 111111 为一个栗子，他的英文表达是 eleven。 eleven 有 666 个 字符，666 的英文表达是 six，six有 333 三个字符，333 的英文表达是 three… 我们可以画出 111111 变成 444 的全过程： 111111(eleven)→6\\to6→6(six)→3\\to3→3(three)→5\\to5→5(five)→4\\to4→4(four) 你会发现，无论是什么数字，它最终都会变成 444。 人类的古老智慧 如果要证明，你会怎么证明？ 其实稍加思索，你会发现其实挺好解释的。 古时候的人们，用一竖代表 111，用两竖代表 222，用三竖代表 333…但他们意识到，写 100010001000 的时候，总不可能写一千个竖吧，于是人们就想到了用特殊符号代表一个数，例如古罗马人就用 V 代表 555，中国人用百代表 100100100。 所以说，将数字写成英文的过程中，字符数一定比原数字要小（对于大部分数字来说，这是对的）。如果你花点时间尝试一下，对于 101010 以内的数字，最后也会变成 444。实际上，444 是唯一一个字符数与数字本身相等的数字。 从英文到其他语言 当然，这种聪明的计数方法并不是英文的权利。世界各国的语言，恐怕没有哪个语言在表示 100001000010000 的时候要写一万个竖吧。 在知名数列网站 oeis.org 数列号 A005589 中的 COMMENTS 一段可以看到这么一句话： 戴安娜·卡洛夫（Diane Karloff）对上面的观察结果的解释： 在许多语言中，都有一个数字 N，在 N 以后所有数字都用比数字本身少的字母书写。N在英语，德语和保加利亚语中为 4，在俄语中为 11。 如果在间隔 [1,N] 中存在等于其字母数的数字，则它们是吸引子。 在英语和德语中，唯一的吸引子是 4，在保加利亚语中是 3，在俄语中是 2、3 和 11。 在区间 [1,N] 中，也可能存在数字循环，例如保加利亚语中的 4（6 个字母）和 6（4 个字母）或俄语的 4、5 和 6（分别为 6、4 和 5 个字母）。英文没有循环，因此上述观察是正确的。 另外，我研究了一下中文（计算其笔画），发现有三个吸引子：一、二和三。以及一个循环：四和五。 数字之和？数字之积？ 这让我联想起大概是小学时，曾经试过将数字的每一位求和或求积。 数字之和 不断取数字每一位的和，最后总会小于 101010。 每一位的和，还有一个好听的名字：数字根。 还记得小学学习整除的时候，是怎么判断一个数是否能被三整除的吗？ 如果一个数字的每一位的和能被三整除，整个数字就能被三整除。 这个判断法则，我们曾经用过无数遍，加起来是因为数字变小了，数字也更好判断能否被三整除了。可是为什么数字会变小呢？ 证明很简单，任何一个数字 nnn 都能写成 (⋯+100a2+10a1+a0)(\\dots+100a_2+10a_1+a_0)(⋯+100a2​+10a1​+a0​) 的形式，其中 a0,a1,a2…a_0,a_1,a_2\\dotsa0​,a1​,a2​…是 nnn 从右往左的每一位数字。那么每位数字之和为 (⋯+a2+a1+a0)(\\dots+a_2+a_1+a_0)(⋯+a2​+a1​+a0​)，我们将每一个对应项进行比较： a0=a0a_0=a_0a0​=a0​。 a1≤10a1a_1\\le10a_1a1​≤10a1​，并且只有当 a1=0a_1=0a1​=0 时 a1=10a1a_1=10a_1a1​=10a1​。 a2≤100a2a_2\\le100a_2a2​≤100a2​，并且只有当 a2=0a_2=0a2​=0 时 a2=100a2a_2=100a_2a2​=100a2​。 后面的项以此类推。 所以说，数字 nnn 一定大于等于它的每一位数字之和，并且只有当 a1=a2=⋯=0a_1=a_2=\\dots=0a1​=a2​=⋯=0 时相等，此时 n&lt;10n&lt;10n&lt;10。 番外：为什么「如果一个数字的数字根能被三整除，整个数字就能被三整除」 拿上面的 nnn 继续讲，如果你用 nnn 减去它的数字根，你会得到⋯+99a2+9a1\\dots+99a_2+9a_1⋯+99a2​+9a1​，而这个大块头一定能被 333 整除，因为它每一项系数全都是九构成的。那么因为 nnn 等于大块头加上它的数字根，如果数字根能被三整除，那 nnn 就能被整除了。 了解更多：A031286 和 A10888。 数字之积 不断取数字每一位的积，最后总会小于 101010。 举个栗子， 728→7×2×8112→1×1×22728\\xrightarrow{7\\times2\\times8}112\\xrightarrow{1\\times1\\times2}27287×2×8​1121×1×2​2。 假设一个数字 nnn 有 mmm 位，它同样可以写成 10m−1am−1+10m−2am−2+⋯+102a2+10a1+a010^{m-1}a_{m-1}+10^{m-2}a_{m-2}+\\dots+10^2a_2+10a_1+a_010m−1am−1​+10m−2am−2​+⋯+102a2​+10a1​+a0​ 的形式。此时每位数字之积为 am−1×am−2×⋯×a2×a1×a0a_{m-1}\\times a_{m-2}\\times\\dots\\times a_2\\times a_1\\times a_0am−1​×am−2​×⋯×a2​×a1​×a0​。 注意到数字表达式的第一项 10m−1am−1=am−1×10×⋯×10⎵(m−1)个1010^{m-1}a_{m-1}=a_{m-1}\\times\\underbrace{10\\times\\dots\\times10}_{(m-1)个10}10m−1am−1​=am−1​×(m−1)个1010×⋯×10​​，将其与每位数字之积对应项进行比较： am−1=am−1a_{m-1}=a_{m-1}am−1​=am−1​。 am−2&lt;10a_{m-2}&lt;10am−2​&lt;10，因为 am−2a_{m-2}am−2​ 只是一位数字（即 0≤am−2≤90\\le a_{m-2}\\le90≤am−2​≤9）。 后面的项以此类推。 所以，我们可以知道数字 nnn 一定大于等于它的每一位数字之积，并且只有当 nnn 只有一位数字时相等。 了解更多：A031346 和 A031347。 ","link":"https://zihim.me/post/8VciGvj48/"},{"title":"[教程] 制作一个成语接龙AI","content":"最近闲的蛋疼，搞了个成语接龙 AI，现在让我来手把手教你搭建一个成语接龙 AI。 我搞这个的目的大概是： 跟QQQQQQ小冰玩 装逼 虐菜 说实在的，这个AI很菜。 注：这里的成语接龙定义： 成语的首字要与上个成语的末字相同，并非拼音相同！例如 稀奇古怪-怪声怪气 就是一个合法的例子 当有一方接不上时，另一方胜利 由玩家指定开头成语 成语库 若要想制作一个好的 AI，那么第一步一定是拥有一个完整的成语库。 寻找成语库 目前使用的是在githubgithubgithub上的一个成语库：戳我 首先点击右边的Download，等它加载完，然后一波Ctrl+A Ctrl+C，复制到文本文档，起名为data.txt。 加载完是指浏览器标签页图标不再是加载圈圈，顺便检查一下文本文档最后面是否是&quot;做张做智&quot;, &quot;abbreviation&quot;: &quot;zzzz&quot;}]这几个字。如果是，恭喜你可以进入下一步了。 筛选 你会发现复制过来有很多定义啊，来源啊这些。而我们只需要一样东西——成语 手筛非常麻烦（如果您很闲），肯定是让程序帮你筛啦！ 仔细观察可以发现：&quot;word&quot;: 后面都是成语。 所以利用find函数截取。 具体实现cut.cpp： #include&lt;bits/stdc++.h&gt; using namespace std; string s; int main(){ ifstream I(&quot;data.txt&quot;); ofstream O(&quot;data-fixed.txt&quot;); while(getline(I,s)){//整行读入 if(s.find(&quot;\\&quot;word\\&quot;: \\&quot;&quot;)==-1)continue;//如果没找到就结束开始下一次整行读入 else{//找到 int i=0;//初始化i while(s.find(&quot;\\&quot;word\\&quot;: \\&quot;&quot;,i)!=-1){//从i开始一直找&quot;word&quot;: &quot; int v=s.find(&quot;\\&quot;&quot;,s.find(&quot;\\&quot;word\\&quot;: \\&quot;&quot;,i)+10);//获取汉字右边的双引号 //if(v-s.find(&quot;\\&quot;word\\&quot;: \\&quot;&quot;,i)-9==8) //若只需要四字成语请将上面一行的注释去掉即可 O&lt;&lt;s.substr(s.find(&quot;\\&quot;word\\&quot;: \\&quot;&quot;,i)+9,v-s.find(&quot;\\&quot;word\\&quot;: \\&quot;&quot;,i)-9)&lt;&lt;&quot; &quot;;//截取汉字 i=v;//记得i要往前走，否则会导致死循环 } } } return 0; } 最后输出的应该在data-fixed.txt里面。 现在我们就有一个成语库了！(((包含非四字成语共308953089530895个成语))) 接龙AIAIAI 这个很简单，顺便使他会学习，当然这里没有用到什么神经网络之类的，只是用到了每个成语的权值，权值越大代表越难接上，每次接的时候就会选择权值最大的成语去接龙。 目前由四种情况（人类水平≤\\le≤电脑水平）： 电脑能接上人类的词：人类的词权值−1-1−1。 电脑不能接上人类的词：人类的词权值+100+100+100，因为当输入时如果人类输入的词在成语库找不到那么电脑不会判定这是一个成语，需要重新输入，所以人类的词必须都在成语库里存在，而电脑接词也是查找成语库，那么如果电脑接不上这个词，就说明这个词很强，所以权值+100+100+100，到以后如果电脑说这个词人类也会接不出来。 人类能接上电脑的词：电脑的词权值−1-1−1 人类接不上电脑的词（程序中输入awsl）：电脑的词权值+1+1+1，为什么不+100+100+100，因为人类水平≤\\le≤电脑水平，玩家接不上不代表电脑接不上。 权值表在learn.txt中，在第一次玩之前必须运行rebuild.exe来创建权值表。若需要清空权值表也可以运行rebuild.exe。 代码rebuild.cpp： #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ ofstream O(&quot;learn.txt&quot;); for(int i=0;i&lt;30000;i++)O&lt;&lt;&quot;0 &quot;;//清除或重建 } 代码成语接龙.cpp： #include&lt;bits/stdc++.h&gt; using namespace std; string s,now,last; int da; struct S{ string chinese;//成语 long long difficult;//权值 }Data[31000]; void read(){//读入成语和权值 string w; ifstream I(&quot;data-fixed.txt&quot;); ifstream I2(&quot;learn.txt&quot;); while(I&gt;&gt;w){ Data[da].chinese=w; I2&gt;&gt;Data[da].difficult; da++; } I.close(); I2.close(); } void save(){//保存权值 ofstream O(&quot;learn.txt&quot;); for(int i=0;i&lt;31000;i++)O&lt;&lt;Data[i].difficult&lt;&lt;&quot; &quot;; } int main(){ long long maxx=-pow(2,63),maxn=-1,si,ok; /*maxx最大权重 maxn最大权重的成语的下标 si玩家输入的成语在成语库的下标 ok成语是否在成语库里*/ read(); cout&lt;&lt;&quot;请输入开头成语\\n&quot;; while(1){ ok=0; cout&lt;&lt;&quot;你:&quot;; cin&gt;&gt;s; for(int i=0;i&lt;31000;i++){//查找成语是否在成语库里 if(s==Data[i].chinese){//如果有 si=i;//存下标 ok=1; } } cout&lt;&lt;&quot;AI:&quot;; if(s==&quot;awsl&quot;){//玩家接不上 cout&lt;&lt;&quot;很遗憾，你失败了！&quot;; Data[maxn].difficult++; save();//学习 while(1); } if(!ok){//找不到这个成语 cout&lt;&lt;&quot;输入错误！\\n&quot;; continue; } Data[maxn].difficult--;save();//合法，接上了电脑的成语，所以学习 maxx=-pow(2,63),maxn=-1;//初始化，准备找权值最大的成语 for(int i=0;i&lt;31000;i++){//在成语库找 if(Data[i].chinese.substr(0,2)==s.substr(6,2)){//前提是要能接上 if(Data[i].difficult&gt;maxx){//取最大值 maxx=Data[i].difficult; maxn=i; } } } if(maxn==-1){//没有找到，玩家胜利 cout&lt;&lt;&quot;恭喜你，你胜利了！\\n&quot;; Data[si].difficult+=100; save();//学习 while(1); } Data[si].difficult--;save();//电脑能接上，学习 cout&lt;&lt;Data[maxn].chinese&lt;&lt;endl;//输出电脑的词语 } } 经过多局电脑玩家对决后，AIAIAI会变得越来越强 自学成才 但是，玩家和电脑对决，电脑学习到的只是不多，而且效率慢，所以我们需要电脑自己学习（即自己和自己对决） 当时AlphaGo ZeroAlphaGo\\ ZeroAlphaGo Zero通过自我博弈，仅仅博弈了三天就超过了AlphaGoAlphaGoAlphaGo之前训练许久的LeeLeeLee版本，博弈404040天超过曾打败柯洁的AlphaGo MasterAlphaGo\\ MasterAlphaGo Master，还发现了新的围棋策略，为围棋这项古老游戏带来了新的见解。 说了这么多牛逼的东西，说实在我这个AI进行自我对决还只是老办法赋权值而已 主要思路还是赋权值 如果bbb接的上aaa，那么aaa权值−1-1−1 如果bbb接不上aaa，aaa权值+1+1+1 训练方法： 输入要训练的组数 每组以一个随机成语开头，然后不断接下去，直到接不下去为止 学习（赋权值）这轮的结果 现在真的怀疑我这到底是不是人工智能了，我认为这只是一个分辨出哪些词容易接哪些词难接的机器 代码： #include&lt;bits/stdc++.h&gt; #define ll long long//鸡肋的宏定义 using namespace std; int N; struct S{ string chinese; long long difficult; }Data[31000]; int da; int main(){ mt19937 gen(time(0));//随机数种子 uniform_int_distribution&lt;&gt;dis(0,30894);//范围是从0到30894 /*下面开始读取成语库及权值表*/ string w; ifstream I(&quot;data-fixed.txt&quot;); ifstream I2(&quot;learn.txt&quot;); while(I&gt;&gt;w){ Data[da].chinese=w;//读入成语 I2&gt;&gt;Data[da].difficult;//权值 da++; } I.close(); I2.close(); /*以上是读取数据*/ cout&lt;&lt;&quot;请输入练习次数（请勿在练习中中途关闭）:&quot;;//如果在中途关闭就是前功尽弃 cin&gt;&gt;N; for(ll i=1;i&lt;=N;i++){//进行N次练习 int noi=dis(gen);//生成一个随机数 S now=Data[noi];//上一个词 //若要显示每局对弈过程，注释掉下面这行 //cout&lt;&lt;&quot;\\n/*第&quot;&lt;&lt;i&lt;&lt;&quot;轮*/\\n&quot;&lt;&lt;now.chinese&lt;&lt;endl; while(1){//直到接不了 int maxx=-1,maxn=0;//权值最大及下标 S maxS;//权值最大的成语（这个很鸡肋） for(int i=0;i&lt;31000;i++){//寻找能接的成语 if(now.chinese.substr(now.chinese.size()-2,2)==Data[i].chinese.substr(0,2)){ if(maxx&lt;Data[i].difficult){//找权值最大的 maxx=Data[i].difficult; maxn=i; maxS=Data[i]; } } } if(maxx==-1){//居然接不上 Data[noi].difficult++; break; } //若要显示每局对弈过程，注释掉下面这行 //cout&lt;&lt;Data[maxn].chinese&lt;&lt;endl; Data[noi].difficult--;//接的上 noi=maxn;//现在接的成语变成上一个成语 now=maxS;//同上 } } ofstream O(&quot;learn.txt&quot;); for(int i=0;i&lt;31000;i++)O&lt;&lt;Data[i].difficult&lt;&lt;&quot; &quot;;//更新权值表 O.close(); //因为权值表在练习完后才更新，所以如果中途关闭就会前功尽弃 cout&lt;&lt;&quot;\\n\\n\\n\\n练习完成&quot;; } 当时，我只用这个训练了101010分钟，AIAIAI基本可以555步内结束接龙（除非第一个成语就接不上） 但是，他还是有可能会被玩家打败（不要跟我说你开两个AIAIAI互打）因为它只会选择最难的成语去接龙，而不会考虑到用这个成语接龙后被反杀的概率。这也是他的一个致命的缺点。 慰问 话说要开学了，你们作业写完没啊我还没动过 ","link":"https://zihim.me/post/4f4Yt5e2UQ/"},{"title":"[趣题] 将前520个素数分成差为521的两部分","content":"大家都知道，前几天是七夕（其实已经好久了）。我在网上看到一道趣题： 证明：可以将前 520 个素数分成两部分，使得这两部分的差恰等于 521。 证明是不可能的，我们用010101背包解决这个问题。 计算质数并求和 我们先计算出前520520520个质数，并将他们求和。 #include&lt;bits/stdc++.h&gt; using namespace std; bool prime[10000]; int main(){ freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout);//质数表存储的地方 for(int i=4;i&lt;10000;i+=2)prime[i]=1;//先筛偶数 for(int i=3;i&lt;100;i+=2){//筛奇数 for(int j=i&lt;&lt;1;j&lt;10000;j+=i)prime[j]=1; } int cnt=0,i=2; while(cnt!=520){//只要前520个 if(prime[i]==0){cnt++;cout&lt;&lt;i&lt;&lt;&quot; &quot;;}//输出并累加 i++;//下标加一 } return 0; } 在2.txt中： 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097 1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187 1193 1201 1213 1217 1223 1229 1231 1237 1249 1259 1277 1279 1283 1289 1291 1297 1301 1303 1307 1319 1321 1327 1361 1367 1373 1381 1399 1409 1423 1427 1429 1433 1439 1447 1451 1453 1459 1471 1481 1483 1487 1489 1493 1499 1511 1523 1531 1543 1549 1553 1559 1567 1571 1579 1583 1597 1601 1607 1609 1613 1619 1621 1627 1637 1657 1663 1667 1669 1693 1697 1699 1709 1721 1723 1733 1741 1747 1753 1759 1777 1783 1787 1789 1801 1811 1823 1831 1847 1861 1867 1871 1873 1877 1879 1889 1901 1907 1913 1931 1933 1949 1951 1973 1979 1987 1993 1997 1999 2003 2011 2017 2027 2029 2039 2053 2063 2069 2081 2083 2087 2089 2099 2111 2113 2129 2131 2137 2141 2143 2153 2161 2179 2203 2207 2213 2221 2237 2239 2243 2251 2267 2269 2273 2281 2287 2293 2297 2309 2311 2333 2339 2341 2347 2351 2357 2371 2377 2381 2383 2389 2393 2399 2411 2417 2423 2437 2441 2447 2459 2467 2473 2477 2503 2521 2531 2539 2543 2549 2551 2557 2579 2591 2593 2609 2617 2621 2633 2647 2657 2659 2663 2671 2677 2683 2687 2689 2693 2699 2707 2711 2713 2719 2729 2731 2741 2749 2753 2767 2777 2789 2791 2797 2801 2803 2819 2833 2837 2843 2851 2857 2861 2879 2887 2897 2903 2909 2917 2927 2939 2953 2957 2963 2969 2971 2999 3001 3011 3019 3023 3037 3041 3049 3061 3067 3079 3083 3089 3109 3119 3121 3137 3163 3167 3169 3181 3187 3191 3203 3209 3217 3221 3229 3251 3253 3257 3259 3271 3299 3301 3307 3313 3319 3323 3329 3331 3343 3347 3359 3361 3371 3373 3389 3391 3407 3413 3433 3449 3457 3461 3463 3467 3469 3491 3499 3511 3517 3527 3529 3533 3539 3541 3547 3557 3559 3571 3581 3583 3593 3607 3613 3617 3623 3631 3637 3643 3659 3671 3673 3677 3691 3697 3701 3709 3719 3727 总和是897745897745897745。 010101背包 我们用010101背包来计算这些质数相加都可以得到哪些数字。 证明 然后这个是本文中唯一的数学知识：算出这两组数的总和。 因为总和是897745897745897745，那么两组数的和一定是897745897745897745，列出方程a+b=897745a+b=897745a+b=897745。 然后他们的差是521521521。我们假使a&gt;ba&gt;ba&gt;b，那么又列出方程a−b=521a-b=521a−b=521。 解出这个方程：a=449133,b=448612a=449133,b=448612a=449133,b=448612。 这个代码检验是否可以有质数相加等于448612448612448612： #include&lt;bits/stdc++.h&gt; using namespace std; bool bag[1000000]={1};//记得0是一种放法 int a; int main(){ freopen(&quot;2.txt&quot;,&quot;r&quot;,stdin);//读入所有质数 for(int i=0;i&lt;520;i++){ cin&gt;&gt;a; for(int j=999999;j&gt;=0;j--){//从后面往前枚举 if(bag[j]==1)bag[j+a]=1;//放 } } cout&lt;&lt;bag[448612]&lt;&lt;endl;//检验 return 0; } 程序输出的是111，说明成立 计算 只证明怎么可以呢？像我这种强迫症肯定还要计算出这些数都是什么。 我们要怎么计算呢？看下面： #include&lt;bits/stdc++.h&gt; using namespace std; bool bag[1000000]={1}; int a[1000],num=448612;//初始化 int main(){ freopen(&quot;3.txt&quot;,&quot;w&quot;,stdout);//输出路径 freopen(&quot;2.txt&quot;,&quot;r&quot;,stdin);//质数 for(int i=0;i&lt;520;i++)cin&gt;&gt;a[i];//先读入所有质数 KKK://goto不要经常用 for(int i=0;i&lt;520;i++){ for(int j=999999;j&gt;=0;j--){ if(bag[j]==1){ bag[j+a[i]]=1; if(j+a[i]==num){//如果他是我们要的数 num=j;//记得要减去 等于num-=a[i] cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;//它就肯定是其中的一个 break;//直接结束循环 } } } } if(num==0)return 0;//如果分解完了结束 memset(bag,0,sizeof(bag));//初始化 bag[0]=1;//同上 goto KKK;//返回 return 0; } 在3.txt中： 2593 2609 2617 2621 2633 2647 2657 2659 2663 2671 2677 2683 2687 2689 2693 2699 2707 2711 2713 2719 2729 2731 2741 2749 2753 2767 2777 2789 2791 2797 2801 2803 2819 2833 2837 2843 2851 2857 2861 2879 2887 2897 2903 2909 2917 2927 2939 2953 2957 2963 2969 2971 2999 3001 3011 3019 3023 3037 3041 3049 3061 3067 3079 3083 3089 3109 3119 3121 3137 3163 3167 3169 3181 3187 3191 3203 3209 3217 3221 3229 3251 3253 3257 3259 3271 3299 3301 3307 3313 3319 3323 3329 3331 3343 3347 3359 3361 3371 3373 3389 3391 3407 3413 3433 3449 3457 3461 3463 3467 3469 3491 3499 3511 3517 3527 3529 3533 3539 3541 3547 3557 3559 3571 3581 3583 3593 3607 3613 3617 3623 3631 3637 3643 3659 3671 3673 3677 3691 3697 3701 3709 3719 89 97 101 103 107 109 113 127 13 11 计算另一部分并检验 #include&lt;bits/stdc++.h&gt; using namespace std; int ans,a,ans2,ans3,aa,aa2,aa3;//ans总和 aa个数 bool t[100000];//桶 int main(){ ifstream I(&quot;2.txt&quot;);//读入质数 while(I&gt;&gt;a){t[a]=1;ans3+=a;aa3++;}//质数置1 ifstream I2(&quot;3.txt&quot;);//读入第二组数 while(I2&gt;&gt;a){t[a]=0;ans2+=a;aa2++;}//质数置0 freopen(&quot;4.txt&quot;,&quot;w&quot;,stdout);//另一组的路径 for(int i=0;i&lt;10000;i++)if(t[i]){cout&lt;&lt;i&lt;&lt;&quot; &quot;;ans+=i;aa++;}//如果为1说明没被选中，也就是另一组 freopen(&quot;CON&quot;,&quot;w&quot;,stdout);//输出在控制台 cout&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;ans2&lt;&lt;&quot; &quot;&lt;&lt;ans3&lt;&lt;endl;//输出总和 cout&lt;&lt;aa&lt;&lt;&quot; &quot;&lt;&lt;aa2&lt;&lt;&quot; &quot;&lt;&lt;aa3&lt;&lt;endl;//个数 } 在4.txt中： 2 3 5 7 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097 1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187 1193 1201 1213 1217 1223 1229 1231 1237 1249 1259 1277 1279 1283 1289 1291 1297 1301 1303 1307 1319 1321 1327 1361 1367 1373 1381 1399 1409 1423 1427 1429 1433 1439 1447 1451 1453 1459 1471 1481 1483 1487 1489 1493 1499 1511 1523 1531 1543 1549 1553 1559 1567 1571 1579 1583 1597 1601 1607 1609 1613 1619 1621 1627 1637 1657 1663 1667 1669 1693 1697 1699 1709 1721 1723 1733 1741 1747 1753 1759 1777 1783 1787 1789 1801 1811 1823 1831 1847 1861 1867 1871 1873 1877 1879 1889 1901 1907 1913 1931 1933 1949 1951 1973 1979 1987 1993 1997 1999 2003 2011 2017 2027 2029 2039 2053 2063 2069 2081 2083 2087 2089 2099 2111 2113 2129 2131 2137 2141 2143 2153 2161 2179 2203 2207 2213 2221 2237 2239 2243 2251 2267 2269 2273 2281 2287 2293 2297 2309 2311 2333 2339 2341 2347 2351 2357 2371 2377 2381 2383 2389 2393 2399 2411 2417 2423 2437 2441 2447 2459 2467 2473 2477 2503 2521 2531 2539 2543 2549 2551 2557 2579 2591 3727 控制台输出： 449133 448612 897745 368 152 520 这是对的！ 小结 没什么好说的，就证明了可以将前520个素数分成两部分，使得这两部分的差恰等于521。 再发一下这两组数吧： 第一组数 2 3 5 7 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097 1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187 1193 1201 1213 1217 1223 1229 1231 1237 1249 1259 1277 1279 1283 1289 1291 1297 1301 1303 1307 1319 1321 1327 1361 1367 1373 1381 1399 1409 1423 1427 1429 1433 1439 1447 1451 1453 1459 1471 1481 1483 1487 1489 1493 1499 1511 1523 1531 1543 1549 1553 1559 1567 1571 1579 1583 1597 1601 1607 1609 1613 1619 1621 1627 1637 1657 1663 1667 1669 1693 1697 1699 1709 1721 1723 1733 1741 1747 1753 1759 1777 1783 1787 1789 1801 1811 1823 1831 1847 1861 1867 1871 1873 1877 1879 1889 1901 1907 1913 1931 1933 1949 1951 1973 1979 1987 1993 1997 1999 2003 2011 2017 2027 2029 2039 2053 2063 2069 2081 2083 2087 2089 2099 2111 2113 2129 2131 2137 2141 2143 2153 2161 2179 2203 2207 2213 2221 2237 2239 2243 2251 2267 2269 2273 2281 2287 2293 2297 2309 2311 2333 2339 2341 2347 2351 2357 2371 2377 2381 2383 2389 2393 2399 2411 2417 2423 2437 2441 2447 2459 2467 2473 2477 2503 2521 2531 2539 2543 2549 2551 2557 2579 2591 3727 第二组数 11 13 89 97 101 103 107 109 113 127 2593 2609 2617 2621 2633 2647 2657 2659 2663 2671 2677 2683 2687 2689 2693 2699 2707 2711 2713 2719 2729 2731 2741 2749 2753 2767 2777 2789 2791 2797 2801 2803 2819 2833 2837 2843 2851 2857 2861 2879 2887 2897 2903 2909 2917 2927 2939 2953 2957 2963 2969 2971 2999 3001 3011 3019 3023 3037 3041 3049 3061 3067 3079 3083 3089 3109 3119 3121 3137 3163 3167 3169 3181 3187 3191 3203 3209 3217 3221 3229 3251 3253 3257 3259 3271 3299 3301 3307 3313 3319 3323 3329 3331 3343 3347 3359 3361 3371 3373 3389 3391 3407 3413 3433 3449 3457 3461 3463 3467 3469 3491 3499 3511 3517 3527 3529 3533 3539 3541 3547 3557 3559 3571 3581 3583 3593 3607 3613 3617 3623 3631 3637 3643 3659 3671 3673 3677 3691 3697 3701 3709 3719 ","link":"https://zihim.me/post/CgFXD1eo2l/"},{"title":"[科普] 如何找单峰函数的峰值","content":"找单峰函数的峰值有什么用？ 怎么找单峰函数的峰值？ 别急，让这篇文章来告诉你. Update 8/9/2025: 重新润色和排版了整篇文章，对部分图片进行重绘. 什么是单峰函数？ 为什么要找峰值？ 怎么找峰值？ 暴力枚举 三分查找及其变体 不稳定的三分查找 稳定的三分查找 类二分查找 小瑕疵 求导后二分查找 0.618法 本节小结 复杂度比较 其他方法 例题 结束语 什么是单峰函数？ 肯定要先听听度娘的解释啦： 单峰函数是在所考虑的区间中只有一个严格局部极大值（峰值）的实值函数. 如果函数 f(x)f(x)f(x) 在区间 [a,b][a, b][a,b] 上只有唯一的最大值点 CCC，而： 在最大值点 CCC 的左侧，函数单调增加； 在点 CCC 的右侧，函数单调减少. 则称这个函数为区间 [a,b][a, b][a,b] 上的单峰函数. 就是函数的右侧单调下降，左侧单调上升，也可以这样解释： max⁡{f}=f(x) ⟺ {∀a&lt;b&lt;xf(b)≥f(a)∀x&gt;a&gt;bf(a)≥f(b)\\max\\{f\\}=f(x)\\iff\\left\\{\\begin{aligned} \\forall a&lt;b&lt;x\\qquad f(b)\\ge f(a) \\\\ \\forall x&gt;a&gt;b\\qquad f(a)\\ge f(b) \\\\ \\end{aligned}\\right. max{f}=f(x)⟺{∀a&lt;b&lt;xf(b)≥f(a)∀x&gt;a&gt;bf(a)≥f(b)​ 为什么要找峰值？ 某些题会让你求一个单峰函数的峰值，例如POJ2420、POJ3737、ZOJ2340等. 甚至洛谷还有一道模板题. 摘自 Matrix67 的漫话二分（下）： 生活中的很多东西都是这样，大了也不好，小了也不好，不多不少的时候最好。我最喜欢举的例子是，粉笔短了不好写且用得快，粉笔长了又容易断；为了贯彻拿 MM 打比方的精神，这里可以再举一些例子来说明这一情况的普遍性：陪 MM 出去玩的次数多了很快会腻，陪 MM 次数少了又会疏远；把握火候贯彻“半糖主义”方针是非常重要的。事实上，从硬盘缓存的大小到初期农民的个数，从每学期的学分到论文的长度，生活中几乎所有东西都是这样，就连饭量和睡眠时间也是。这些例子说穿了就是一个单峰函数，我们需要用尽可能少的试验次数快速找到极大点。永远不要以为决策者们面对的都是高中数学考卷上的“每涨 10 块钱就会少 100 个消费者”一类的屁话，这些屁话都是用来编二次函数题目的。现实生活中企业做决策时，样点实验、不断取舍、逐步逼近最优点仍然是最实在最有效的手段。 奥数填空题. 怎么找峰值？ 本节中以 f(x)f(x)f(x) 作为单峰函数在代码中呈现，并定义 f(x)=xxx∈[0,10]f(x)=\\sqrt[x]{x}\\qquad x\\in[0,10] f(x)=xx​x∈[0,10] 其峰值为 ee≈1.444667861\\sqrt[e]{e}\\approx1.444667861ee​≈1.444667861. #define f(x) pow(x,1.0/x) const int pre=7; // pre为精度 double l=0,r=10,p=pow(10,-pre); // p为误差限 暴力枚举 最普通的方法肯定是暴力，设置步长，从左到右扫记录最大值. 条目 内容 优点 相对稳定 缺点 耗时长，精度低 时间复杂度 O(10n)O(10^n)O(10n) double maxx=-1; for(double i=l+p;i&lt;=r;i+=p) // 由于使用x^(1/x)为f函数，所以i不能为0 maxx=max(maxx,f(i)); // 寻找最大值 cout&lt;&lt;fixed&lt;&lt;setprecision(pre)&lt;&lt;maxx&lt;&lt;endl; 三分查找及其变体 不稳定的三分查找 像这种带有单调性的函数，让人不由自主的想起二分. 但是我们不能只取一个点，因为这是无法得出峰值在哪里的，所以我们需要取两个点，通过比较这两个点来得出峰值的位置. 阮大佬曾在他的博客中介绍了三分查找，主要是分一半再分一半的思想： 取 m1=l+r2m_1=\\dfrac{l+r}{2}m1​=2l+r​，再取 m2=m1+r2m_2=\\dfrac{m_1+r}{2}m2​=2m1​+r​. 比较 f(m1)f(m_1)f(m1​) 和 f(m2)f(m_2)f(m2​) 的值： 当 f(m1)&gt;f(m2)f(m_1)&gt;f(m_2)f(m1​)&gt;f(m2​) 时，此时峰值必在 m2m_2m2​ 左侧，故更新 r=m2r=m_2r=m2​. 当 f(m1)&lt;f(m2)f(m_1)&lt;f(m_2)f(m1​)&lt;f(m2​) 时，此时峰值必在 m1m_1m1​ 右侧，故更新 l=m1l=m_1l=m1​. 证明在链接里有，这里就照着我的思路再讲一遍吧（其实是差不多的）： 当 f(m1)&gt;f(m2)f(m_1)&gt;f(m_2)f(m1​)&gt;f(m2​) 时，若峰值在 m2m_2m2​ 右侧，会导致有两个峰，否则 f(m1)f(m_1)f(m1​) 不会大于f(m2)f(m_2)f(m2​)，故峰值必在 m2m_2m2​ 左侧. 同样可以证第二个. 既然这样，我们就可以进行三分，每次可以舍去原长度的 12\\dfrac{1}{2}21​ 或 14\\dfrac{1}{4}41​. 另外，在原文里有提及到写法，一种是控制迭代次数，一种是直接控制精度，接下来的代码均以直接控制精度为例. 条目 内容 优点 速度快 缺点 不稳定 时间复杂度 最优 O(2log⁡2n)O(2\\log_2n)O(2log2​n)，最劣 O(2log⁡43n)O(2\\log_\\frac{4}{3}n)O(2log34​​n) while(r-l&gt;p){ double m1=l+(r-l)/2,m2=m1+(r-m1)/2; // 先计算区间长度再进行加减的优点是不容易溢出 // 如果确保不会溢出，使用定比分点公式也可以 if(f(m1)&lt;f(m2))l=m1; // 小于时舍去左边 else r=m2; // 舍去右边 } cout&lt;&lt;fixed&lt;&lt;setprecision(pre)&lt;&lt;max(f(l),f(r))&lt;&lt;endl; 稳定的三分查找 为了让算法变得更稳定，我们可以把这两个点设在三等分处，这样每次都一定会舍弃原长度的 13\\dfrac{1}{3}31​. 条目 内容 优点 速度快，相对更稳定 缺点 / 时间复杂度 O(2log⁡32n)O(2\\log_{\\frac32}n)O(2log23​​n) while(r-l&gt;p){ double d=(r-l)/3,m1=l+d,m2=r-d; // 同样出于溢出的考虑 if(f(m1)&lt;f(m2))l=m1; else r=m2; } cout&lt;&lt;fixed&lt;&lt;setprecision(pre)&lt;&lt;max(f(l),f(r))&lt;&lt;endl; 类二分查找 如果我们想需要速度更快，应该怎么处理呢？很容易可以想到，如果我们把 m1m_1m1​ 和 m2m_2m2​ 取得接近于中点，那么一次比较就可以舍去几乎12\\dfrac{1}{2}21​的长度了！ 所以我们可以考虑取中点 mmm，然后比较 f(m−c)f(m-c)f(m−c) 和 f(m+c)f(m+c)f(m+c)，其中 ccc 是一个很小的正数. 但是注意，如果 ccc 太小，那么浮点误差会导致计算得到 l=r=ml=r=ml=r=m，然后结束循环，最终你只会得到 f(m)f(m)f(m). 条目 内容 优点 速度比普通三分快 缺点 浮点误差会导致比较失败 时间复杂度 O(2log⁡2n)O(2\\log_2n)O(2log2​n) while(r-l&gt;=p){ double m=l+(r-l)/2; // 取中点 if(f(m-p)&lt;f(m+p))l=m; else r=m; } cout&lt;&lt;fixed&lt;&lt;setprecision(pre)&lt;&lt;max(f(l),f(r)); 小瑕疵 上述三分法及其变体存在一些小瑕疵，当取得的两个点的函数值相同时，峰值在哪一侧均有可能： 峰值在左侧的点的左侧，此时两点之间所有函数值相等，同理有峰值再右侧的点的右侧. 峰值在两点之间，只是恰好取的两点函数值相等. 幸运的是，在现实生活和问题中，我们常常遇到的是下面的情况，故无需过多理会. 求导后二分查找 我们知道，函数峰值处导数为 000. 因为是单峰，所以可以先对原函数求导，然后找 lll 和 rrr 之间使 f′(x)=0f&#x27;(x)=0f′(x)=0 的值. 此时问题就转化成了二分查找（或牛顿迭代法等函数求零点算法）. 问题就在于复杂的函数（以及多层复合的函数）很难求导. 而且在本例中 f(x)=xx⋅ln⁡x−1x2f(x)=\\sqrt[x]{x}\\cdot\\dfrac{\\ln x-1}{x^2}f(x)=xx​⋅x2lnx−1​，求完导后直接就能解得 x=ex=ex=e. 在数学上直接就得到答案了，何必再用算法进行迭代？ 实际上，由于一些超越方程不可在数学上解得，并且五次及以上的多项式方程无根式解，所以对于一些复杂的函数或高次的多项式方程而言，该方法展现出了一些独特优势. 条目 内容 优点 速度快 缺点 复杂函数难以求导，注意判断驻点 时间复杂度 O(log⁡2n)O(\\log_2n)O(log2​n)（未包含求导所需时间） 正如上面所说，本例没有必要使用求导二分的方法求解，故此处以P3382 【模板】三分法为例，直接给出小黑AWM大佬的题解. #include&lt;cstdio&gt; using namespace std; int n; double a[20],L,R,k; double f(double x){ double ans=0; for(int i=n;i&gt;=1;i--) ans=ans*x+a[i]; // 常数项没了 return ans; } int main(){ scanf(&quot;%d%lf%lf&quot;,&amp;n,&amp;L,&amp;R); for(int i=n;i&gt;=0;i--)scanf(&quot;%lf&quot;,&amp;a[i]),a[i]*=i; // a[i]*=i求导 while(R-L&gt;=1e-6){ // 二分 double mid=(R+L)/2; f(mid)&gt;0?L=mid:R=mid; // 等价于if(f(mid)&gt;0)L=mid;else R=mid; } printf(&quot;%.5lf\\n&quot;,L); return 0; } 代码中使用了秦九韶算法重新调整了计算顺序： anxn+⋯+a3x3+a2x2+a1x+a0= (anxn−1+⋯+a3x2+a2x+a1)x+a0= ((anxn−2+⋯+a3x+a2)x+a1)x+a0= (((anx+an−1)x+an−2)x+⋯+a1)x+a0\\begin{aligned} &amp; a_nx^n+\\cdots+a_3x^3+a_2x^2+a_1x+a_0 \\\\ =\\ &amp; (a_nx^{n-1}+\\cdots+a_3x^2+a_2x+a_1)x+a_0 \\\\ =\\ &amp; ((a_nx^{n-2}+\\cdots+a_3x+a_2)x+a_1)x+a_0 \\\\ =\\ &amp; (((a_nx+a_{n-1})x+a_{n-2})x+\\cdots+a_1)x+a_0 \\\\ \\end{aligned} = = = ​an​xn+⋯+a3​x3+a2​x2+a1​x+a0​(an​xn−1+⋯+a3​x2+a2​x+a1​)x+a0​((an​xn−2+⋯+a3​x+a2​)x+a1​)x+a0​(((an​x+an−1​)x+an−2​)x+⋯+a1​)x+a0​​ 将原本的 n(n+1)2\\dfrac{n(n+1)}{2}2n(n+1)​ 次乘法和 nnn 次加法化简为了 nnn 次乘法和 nnn 次加法. // 普通算法 int f(int x){ int ans=0; for(int i=0;i&lt;=n;i++) ans+=a[i]*pow(x,i); return ans; } // 秦九韶算法 int f(int x){ int ans=a[n]; for(int i=n-1;i&gt;=0;i--)ans=ans*x+a[i]; return ans; } 0.618法 除了求导二分这个比较特殊的算法外，上面提到的三分查找及其变体最大的缺点其实是每次比较都要进行两次函数值的计算. 假如有这么一种做法，通过循环利用上一次比较时剩下的点. 使一个点被去掉后另一个点正好是下一次比较的其中一个点. 那么这两个点应该满足一些性质. 如上图，假如第一次比较在原线段上对称的两个点 AAA 和 BBB，不妨假设去掉了 BBB 右侧的部分. 那么下一次就可以仅需新增一个 A′A&#x27;A′，并重复利用原先的 AAA 作为 B′B&#x27;B′ 进行比较. 可以发现一段相同的比例关系： LRLB=LBLB′\\dfrac{LR}{LB}=\\dfrac{LB}{LB&#x27;} LBLR​=LB′LB​ 由于 LB=ARLB=ARLB=AR，设 AAA 将 LRLRLR 分为左右长为 aaa 和 bbb 的两段，则 a+bb=ba1+ba=b2a2ba=5−12≈0.618\\begin{aligned} \\dfrac{a+b}{b}&amp;=\\dfrac{b}{a} \\\\ 1+\\dfrac ba&amp;=\\dfrac{b^2}{a^2} \\\\ \\dfrac ba&amp;=\\dfrac{\\sqrt{5}-1}{2} \\\\ &amp;\\approx0.618 \\end{aligned} ba+b​1+ab​ab​​=ab​=a2b2​=25​−1​≈0.618​ 这样，我们就确定了两个点的位置了. 这个比例大家一定不陌生，这是著名的黄金分割率. 上面这个方法叫做0.618法，是优选法的一种. 条目 内容 优点 重复利用已经计算过的点，速度极快 缺点 / 时间复杂度 O(log⁡1+52n)O(\\log_{\\frac{1+\\sqrt5}2}n)O(log21+5​​​n) #define F 0.38196601125010515179541316563436 // 较短的部分所占的比例 double d=F*(r-l),m1=l+d,m2=r-d; double fm1=f(m1),fm2=f(m2); while(r-l&gt;p){ if(fm1&gt;fm2){ // 舍去右边 r=m2; m2=m1; fm2=fm1; // 复用计算结果 m1=l+F*(r-l); fm1=f(m1); }else{ l=m1; m1=m2; fm1=fm2; m2=r-F*(r-l); fm2=f(m2); } } cout&lt;&lt;fixed&lt;&lt;setprecision(pre)&lt;&lt;max(f(l),f(r))&lt;&lt;endl; 本节小结 一般的三分题，其实只有几个关键步骤： 选择要三分的函数和自变量. 设置好左端点和右端点. 调整精度. 最后套模板就可以轻松 AC. 复杂度比较 可以看到除了暴力之外，上述其他方法基本是 O(log⁡n)O(\\log n)O(logn) 量级的，而优选法由于每次可以少计算一个点，进而在常数上获得优势： 方法 O(klog⁡2n)O(k\\log_2n)O(klog2​n) 时的常数 kkk kkk 的数值 不稳定的三分查找 [2,22−log⁡23]\\left[2,\\dfrac{2}{2-\\log_23}\\right][2,2−log2​32​] [2,4.819][2,4.819][2,4.819] 稳定的三分查找 2log⁡23−1\\dfrac{2}{\\log_23-1}log2​3−12​ 3.4193.4193.419 类二分查找 222 222 求导后二分查找 111 111 0.618法 1log⁡2(1+5)−1\\dfrac{1}{\\log_2{(1+\\sqrt5)}-1}log2​(1+5​)−11​ 1.4401.4401.440 如果说函数比较方便求导，首选求导二分，毕竟只需要 O(log⁡2n)O(\\log_2n)O(log2​n) 的时间，但同时需要注意求导所需的时间复杂度. 其他方法 直接看P3382的题解你就会发现有很多大法： 粒子群优化 by yuy_ 模拟退火 by Soulist 梯度下降法 by 平衡树森林 四分法 by Youngsc_AFO 感兴趣的读者请自行了解，顺便膜拜以上这些大佬. 例题 给定一张边长为 2n2n2n 的正方形纸，在四个角落各剪一个边长为 x (0&lt;x&lt;n)x\\ (0&lt;x&lt;n)x (0&lt;x&lt;n) 的小正方形，拼成一个无盖长方体，请输出这个长方体体积最大时的体积、高和底面边长（保留 5 位小数）. 我们知道，长方体的体积 V=x(2n−2x)2V=x(2n-2x)^2V=x(2n−2x)2，并且可以知道在 x∈[0,n]x\\in[0,n]x∈[0,n] 之间，体积先变大后变小. 所以可以对 xxx 的长度（即盒子的高）进行三分查找. #include&lt;bits/stdc++.h&gt; using namespace std; double n; double f(double x){ // 定义体积函数 return 4*x*(n-x)*(n-x); } int main(){ cin&gt;&gt;n; double l=0,r=n; while(r-l&gt;1e-5){ double d=(r-l)/3,m1=l+d,m2=r-d; double fm1=f(m1),fm2=f(m2); if(fm1-fm2&gt;=0)r=m2; if(fm1-fm2&lt;=0)l=m1; } cout&lt;&lt;fixed&lt;&lt;setprecision(5); cout&lt;&lt;f(l)&lt;&lt;&quot; &quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;sqrt(f(l)/l)&lt;&lt;endl; // a*a*h=f(h) return 0; } 当然，最快的还是求导： {V=227(2n)3h=16(2n)a=23(2n)\\left\\{\\begin{aligned} V&amp;=\\dfrac2{27}{(2n)}^3 \\\\ h&amp;=\\dfrac16 (2n) \\\\ a&amp;=\\dfrac23(2n) \\end{aligned}\\right. ⎩⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎧​Vha​=272​(2n)3=61​(2n)=32​(2n)​ 所以就有正解求导做法： #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ double n;cin&gt;&gt;n; cout&lt;&lt;fixed&lt;&lt;setprecision(5); cout&lt;&lt;16*n*n*n/27&lt;&lt;&quot; &quot;&lt;&lt;n/3&lt;&lt;&quot; &quot;&lt;&lt;4*n/3&lt;&lt;endl; // 直接套用公式 } 如果你想做更多三分题，戳我. 结束语 蒟蒻第一次写文章，可能还不够熟练，如果文章有什么问题欢迎各位大佬指正，如果有什么漏掉的也欢迎各位大佬补充！ ","link":"https://zihim.me/post/nOSQC7vMtx/"}]}